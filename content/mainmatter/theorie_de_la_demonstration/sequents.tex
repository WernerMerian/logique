\chapter[Calcul des séquents]{Théorème de complétude méta et
  calcul des séquents}\label{chp.sequents}

\minitoc

\lettrine{D}{ans} le \cref{chp.logpred}, nous avons prouvé le théorème de
complétude pour la déduction naturelle dans le cas de la logique du premier
ordre. La déduction naturelle, comme nous l'avons vu, est une syntaxe de
démonstration permettant de formaliser des étapes élémentaires de raisonnements
sous forme d'un arbre de preuve.

La structure de la preuve du théorème de complétude, du moins de sa partie
technique où l'on construit un modèle d'une théorie cohérente, se décompose
ainsi~:
\begin{itemize}
\item on ajoute des témoins de Henkin à la théorie~;
\item on complète la théorie~;
\item on construit le modèle syntaxique, dont les éléments sont les termes clos
  quotientés par l'égalité prouvable dans la théorie
\item on montre par induction que la théorie complétée prouve une formule si et
  seulement si le modèle syntaxique la satisfait.
\end{itemize}

Ce théorème est donc relativement long et technique à prouver, et notre preuve
ne fonctionne que dans le cas très précis de la déduction naturelle. Est-il
possible de généraliser ce résultat à d'autres syntaxes de preuves ? C'est en
répondant à cette question que nous introduisons une autre syntaxe, celle du
calcul des séquents, que nous étudierons ce chapitre.

Ce chapitre se compose donc d'abord d'une preuve d'un théorème de complétude
\og méta\fg, qui permet de prouver avec quelques conditions qu'une large classe
de syntaxes de preuves sont complètes vis à vis des modèles déjà présentés dans
le \cref{chp.logpred}. Grâce à cette preuve, nous abordons ensuite le calcul des
séquents classique, et son principal théorème~: l'élimination des coupures.

Enfin, nous présentons le calcul des séquents intuitionnistes. Pour cela, nous
préférons prendre un chemin légèrement plus long mais plus riche~: nous étudions
sommairement la logique modale et la sémantique de Kripke qui leur est associé.
Cela nous permet de conclure par un théorème de complétude similaire à celui du
calcul des séquents, mais entre sa version intuitionniste et la classe des
modèles de Kripke.

\section{Du théorème de complétude au calcul des séquents}[Complétude et
  séquents]

Pour commencer notre parcours de la théorie de la démonstration, on s'intéresse
au théorème de complétude. Sous la forme du \cref{thm.completude}, il énonce
qu'un système syntaxique donné coïncide avec la relation $\vDash$ de
conséquence sémantique. Comme ce théorème s'intéresse à la syntaxe, se
démonstration dépend entièrement du système syntaxique considéré. Cependant, on
peut adapter la preuve donnée d'un système à un autre, en cherchant des
conditions plus sémantiques sur les systèmes pour avoir une condition suffisante
à la complétude d'un système. C'est ce que nous nous proposons de faire.

\subsection{Construire un théorème de complétude généralisé}

On veut donc définir un ensemble de conditions sur une relation $\vdash$ de
prouvabilité, représentant un système syntaxique de démonstrations.
Nous nous autorisons à ajouter autant de conditions que nécessaire, mais nous
souhaitons garder un critère essentiel~: chaque condition doit être raisonnable,
au sens où un système nous paraissant refléter ce qu'est une preuve doit
forcément vérifier une telle condition.

Tout d'abord, des conditions dites structurelles s'imposent. On considère que
notre relation $\vdash$ de prouvabilité syntaxique relie une théorie et une
formule, on a donc, pour une signature $\Sigma$ donnée,
$\vdash \subseteq \powerset(\Prop(\Sigma))\times \Formula(\Sigma)$. Dire qu'une
théorie $\mathcal T$ prouve une formule $\varphi$ demande qu'on écrive
effectivement une preuve, ce qui signifie qu'on doit avoir un ensemble, qu'on
notera $\Proof{\mathcal T}(\Sigma)$, de preuves. Cet ensemble est muni d'une
relation donnant les hypothèses d'une preuves et sa conclusion, c'est-à-dire une
relation $\concl \subseteq \powerfin(\Formula(\Sigma))\times \Formula(\Sigma)$
de telle sorte qu'on puisse écrire
\[\forall \mathcal T, \varphi, \mathcal T \vdash \varphi \iff
\exists \pi \in \Proof{\mathcal T}(\Sigma), \pi \concl (\Gamma,\varphi) \land
\Gamma\subseteq\mathcal T\]
Remarquons ici qu'on choisit de considérer pour nos hypothèses un
ensemble fini de formules. Le fait de choisir un ensemble fini est poussé par
le fait qu'une preuve est toujours considérée comme un objet finitaire~: écrire
une démonstration repose sur un nombre fini de symboles. Le fait de considérer
des formules et non seulement des propositions permet de considérer des preuves
qui utilisent des formules non closes comme hypothèses.

Nous voyons donc plusieurs conditions apparaître grâce à cette structure.
Tout d'abord, cela force la propriété d'affaiblissement~:
\[
(\textit{Aff})\quad : \quad \forall \mathcal T,\mathcal T', \varphi,
(\mathcal T \vdash \varphi) \land (\mathcal T \subseteq \mathcal T') \implies
\mathcal T' \vdash \varphi
\]
ainsi que la propriété de compacité~:
\[
(\textit{Comp})\quad : \quad \forall \mathcal T, \varphi,
\mathcal T \vdash \varphi \implies \exists F \subfin \mathcal T,
F\vdash \varphi
\]

Au niveau structurel, il est aussi attendu d'une démonstration qu'elle permette
de faire deux choses considérées évidentes~: une démonstration peut utiliser une
hypothèse pour en faire sa conclusion, et une démonstration peut utiliser un
lemme. Ces deux principes de raisonnement élémentaires se traduisent par deux
conditions, l'axiome~:
\[
(\textit{Ax})\quad : \quad \forall \mathcal T, \varphi, \varphi \in \mathcal T
\implies \mathcal T \vdash \varphi
\]
et la coupure~:
\[
(\textit{Cut})\quad : \quad \forall \mathcal T, \varphi, \psi,
(\mathcal T \vdash \varphi) \land (\mathcal T \cup \{\varphi\}\vdash \psi)
\implies \mathcal T \vdash \psi
\]

On ajoute aussi une condition liée au fait qu'on travaille en logique
classique~: on admet le tiers exclu, ou plutôt ici une version équivalente
qu'est le raisonnement par l'absurde. Pour faciliter l'écriture de cette
condition, on définit deux nouvelles notations~: on notera $\mathcal T \vdash$
pour dire que $\mathcal T$ peut prouver une formule $\varphi$ et son contraire
$\lnot\varphi$, et on notera $\mathcal T\nvdash$ pour dire que ce n'est pas le
cas (ce qui correspond au fait que $\mathcal T$ est cohérente). On peut alors
formuler le raisonnement par l'absurde ainsi~:
\[
(\textit{Raa})\quad : \quad \forall \mathcal T, \varphi,
(\mathcal T\cup\{\lnot \varphi\}\vdash) \implies \mathcal T \vdash \varphi
\]

Avec ces conditions, toutes largement raisonnables pour considérer une notion de
prouvabilité entre une théorie et une formule, on peut déjà remarquer deux
éléments~:
\begin{itemize}
\item avec $(\textit{Raa})$, prouver que $\vDash\subseteq \vdash$ ne demande que
  de prouver que pour toute théorie $\mathcal T$, si $\mathcal T\nvdash$ alors
  il existe un modèle de $\mathcal T$. Cela revient au
  \cref{lem.vDashvdashabs} que nous avons vu avant.
\item sans reconstruire l'algèbre de Lindenbaum-Tarski pour la
  relation syntaxique, le fait d'avoir $(\textit{Aff})$ et $(\textit{Comp})$
  nous permet d'utiliser le lemme de Zorn pour étendre toute théorie en une
  théorie cohérente maximale pour $\vdash$, vu comme un pré-ordre grâce aux
  conditions $(\textit{Ax})$ et $(\textit{Cut})$ qui assurent respectivement
  la réflexivité et la transitivité de la relation.
\end{itemize}

Grâce à ces quatre conditions structurelles, on cherche maintenant des
conditions pour assurer que la construction effectuée dans le \cref{chp.logpred}
fonctionne encore. On souhaite donc construire le modèle syntaxique. Pour cela,
on a besoin de quotienter l'ensemble des termes clos par la relation
\[t \sim u \defeq \mathcal T \vdash t = u\]
Mais il faut donc vérifier que cette relation est à la fois une relation
d'équivalence, et une congruence pour les symboles de fonction et de relation.

On a déjà vu que deux règles suffisaient pour ça, qui sont la réflexivité~:
\[(\textit{r}=)\quad : \quad \forall \mathcal T, t, \mathcal T \vdash t = t\]
et la loi de Leibniz~:
\[(\textit{l}=)\quad : \quad \forall \mathcal T, t, u, \varphi,
(\mathcal T \vdash \varphi[u/x]) \implies
\mathcal T \cup\{ t = u \} \vdash \varphi[t/x]
\]

On peut donc construire notre modèle syntaxique. L'étape suivante est de prouver
par induction sur les formules que, en notant notre modèle syntaxique
$\mathcal M$ et notre théorie maximale $\mathcal T$, pour tout environnement
d'interprétation des variables du premier ordre $\rho$ et toute formule
$\varphi$ dont les variables libres sont dans le domaine de $\rho$, on a
\[\mathcal M, \rho \models \varphi \iff \mathcal T \vdash \rho(\varphi)\]
Sans s'attarder sur les substitutions de variables et en passant les cas
atomiques (le cas de $\top$ est automatique, le cas de $\bot$ est dû au fait
que la théorie $\mathcal T$ est cohérente, et les autres formules atomiques sont
données par définition de l'interprétation des relations), l'induction nous
donne~:
\[\begin{array}{ccccc}
\mathcal M \models \lnot \varphi 
& \overset{\textit{ind. hyp.}}{\iff} &
\mathcal T \nvdash \varphi & \overset{\text{?}}{\iff} &
\mathcal T \vdash \lnot\varphi \\
\mathcal M \models \varphi\land \psi
& \overset{\textit{ind. hyp.}}{\iff} &
(\mathcal T \vdash \varphi) \land (\mathcal T \vdash \psi)&
\overset{\text{?}}{\iff} &
\mathcal T \vdash \varphi \land \psi \\
\mathcal M \models \varphi\lor \psi
& \overset{\textit{ind. hyp.}}{\iff} &
(\mathcal T \vdash \varphi) \lor (\mathcal T \vdash \psi)&
\overset{\text{?}}{\iff} &
\mathcal T \vdash \varphi \lor \psi \\
\mathcal M \models \varphi\to \psi
& \overset{\textit{ind. hyp.}}{\iff} &
(\mathcal T \nvdash \varphi) \lor (\mathcal T \vdash \psi)&
\overset{\text{?}}{\iff} &
\mathcal T \vdash \varphi \lor \psi \\
\mathcal M \models \forall x, \varphi
& \overset{\textit{ind. hyp.}}{\iff} &
\forall m \in |\mathcal M |, \mathcal T \vdash \varphi[t/x]
& \overset{\text{?}}{\iff} &
\mathcal T \vdash \forall x, \varphi \\
\mathcal M \models \exists x, \varphi
& \overset{\textit{ind. hyp.}}{\iff} &
\exists m \in |\mathcal M |, \mathcal T \vdash \varphi[t/x]
& \overset{\text{?}}{\iff} &
\mathcal T \vdash \exists x, \varphi \\
\end{array}\]

On a ainsi une liste de nouvelles conditions à satisfaire pour assurer que
l'induction fonctionne. En séparant les équivalences en deux implications, et
en prenant la contraposée pour l'une des deux implications, on
obtient (en notant $\mathcal T, \varphi$ pour $\mathcal T \cup \{\varphi\}$)~:
\[\begin{array}{ccccc}
(l\lnot) & : & \mathcal T \vdash \varphi & \implies &
\mathcal T, \lnot \varphi \vdash \\
(r\lnot) & : & \mathcal T, \varphi \vdash & \implies &
\mathcal T \vdash \lnot \varphi \\
(l\land) & : & (\mathcal T, \varphi \vdash) \lor
(\mathcal T, \psi \vdash)
& \implies & \mathcal T, \varphi \land \psi\vdash \\
(r\land) & : & (\mathcal T \vdash \varphi) \land (\mathcal T \vdash \psi)
& \implies & \mathcal T \vdash \varphi \land \psi \\
(l\lor) & : & (\mathcal T, \varphi \vdash) \land (\mathcal T, \psi \vdash)
& \implies & \mathcal T, \varphi \lor \psi \vdash \\
(r\lor) & : & (\mathcal T \vdash \varphi) \lor (\mathcal T \vdash \psi)
& \implies & \mathcal T \vdash \varphi \lor \psi \\
(l\to) & : & (\mathcal T \vdash \varphi) \land (\mathcal T, \psi \vdash)
& \implies & \mathcal T, \varphi \to \psi \vdash \\
(r\to) & : & (\mathcal T,\varphi \vdash) \lor (\mathcal T \vdash \psi)
& \implies & \mathcal T \vdash \varphi \to \psi \\
(l\forall) & : & (\exists t \in |\mathcal M |, \mathcal T, \varphi[t/x] \vdash)
& \implies & \mathcal T, \forall x, \varphi \vdash \\
(r\forall) & : & (\forall t \in |\mathcal M |, \mathcal T \vdash \varphi [t/x])
& \overset{\text{?}}{\implies} & \mathcal T \vdash \forall x, \varphi \\
(l\exists) & : & (\forall t \in |\mathcal M |, \mathcal T, \varphi[t/x] \vdash)
& \overset{\text{?}}{\implies} & \mathcal T, \exists x, \varphi \vdash \\
(r\exists) & : & (\exists t \in |\mathcal M |, \mathcal T \vdash \varphi[t/x])
& \implies & \mathcal T \vdash \exists x, \varphi
\end{array}\]

Toutes ces conditions, à l'exceptions de deux marquées par un
$\overset{\text{?}}{\implies}$, sont des conditions parfaitement raisonnables à
attendre d'un système syntaxique de démonstration. Les deux autres conditions,
en revanche, n'ont pas de raison d'être vérifiées~: une implication telle que
$\forall t \in |\mathcal T|, \mathcal T \vdash \varphi[t/x] \implies \mathcal T
\vdash \forall x, \varphi$
signifie en particulier que tout objet du premier ordre est représenté par un
terme clos. On peut facilement se convaincre que ça n'est pas le cas en prenant
le langage et la théorie des groupes~: pour un certain groupe fixé, disons le
groupe $\mathbb Z$, seul $0$ peut s'écrire comme un terme clos.

On modifie donc les deux conditions $(r\forall)$ et $(l\exists)$ en demandant,
non pas que la prémisse soit vérifiée en quantifiant sur les termes clos,
mais qu'elle soit vérifiée en prenant une constante $c$ n'apparaissant pas dans
$\varphi$ ni dans $\mathcal T$~:
\[\begin{array}{ccccc}
(r\forall)^\dagger & : & \forall c \notin \Const(\mathcal T, \varphi),
\mathcal T \vdash \varphi[c/x]
& \implies & \mathcal T \vdash \forall x, \varphi \\
(l\exists)^\dagger & : & \forall c \notin \Const(\mathcal T, \varphi),
\mathcal T, \varphi[c/x]\vdash
& \implies & \mathcal T, \exists x, \varphi \vdash
\end{array}\]
Ces deux conditions sont, elles, raisonnables, puisqu'elles correspondent à une
généralisation sur une constante indépendante du contexte. Cependant, elles ne
suffisent pas à assurer l'implication initiale. Nous utilisons donc la
construction des témoins de Henkin. Dans le cas présent, comme le système
syntaxique n'est pas défini et qu'on ne connait que quelques unes de ses
propriétés, on préfère ajouter des témoins de façon plus parcimonieuse.

En effet, on considère maintenant les formules $\varphi$ à une variable libre
telle que $\exists x, \varphi$ appartient à $\mathcal T$ (ou est prouvable dans
$\mathcal T$, comme $\mathcal T$ est choisie maximale), on ajoute seulement
une constante $c_{\exists x, \varphi}$ dans ce cas, et la théorie $\mathcal T'$
enrichie est alors augmentée seulement de l'axiome
$\varphi[c_{\exists x, \varphi}/x]$.

On peut alors itérer cette construction pour, à partir de la théorie
$\mathcal T$, construire une théorie $\hclose{\mathcal T}$ qui possède la
propriété des témoins de Henkin, c'est-à-dire telle que pour toute formule
$\varphi$ à une variable libre telle que $\exists x, \varphi$ est prouvable
dans $\hclose{\mathcal T}$, il existe une constante $c$ telle que
$\varphi[c/x]$ est prouvable dans $\hclose{\mathcal T}$.

Il se pose alors un nouveau problème. Lorsque nous construisons la version à
la fois complète et possédant les témoins de Henkin de notre théorie initiale,
dans le \cref{chp.logpred}, nous utilisons le \cref{prop.henkin.ext} pour,
depuis le complété de la clôture par témoins de Henkin, avoir une théorie
possédant les deux propriétés. Dans le cas présent, cette propriété n'a pas de
raison d'être vérifiée~: augmenter par maximalité notre théorie
$\hclose{\mathcal T}$ dans le nouveau langage nous fait perdre la propriété des
témoins de Henkin, et ajouter des témoins de Henkin nous fait perdre la
maximalité de la théorie.

On décide donc de créer une suite de théorie et de langages (on ne précisera pas
les langages) $\mathcal T_n$ où $\mathcal T_{2n+1}$ est l'extension par témoins
de Henkin de $\mathcal T_{2n}$, et $\mathcal T_{2n+2}$ est l'extension par
maximalité de $\mathcal T_{2n+1}$. En prenant alors l'union de toutes ces
théories, qu'on notera $\mathcal T'$ ici, on sait que~:
\begin{itemize}
\item si $\exists x, \varphi$ appartient à $\mathcal T'$, alors elle appartient
  à une certaine théorie $\mathcal T_n$, et on trouve donc une constante
  $c_{\varphi}$ telle que $\varphi[c_{\varphi}/x] \in \mathcal T_{n+2}$, donc
  $\mathcal T'$ possède la propriété des témoins de Henkin~;
\item soit $\varphi$ une formule close, exprimée dans le langage de
  $\mathcal T'$. Comme $\varphi$ est un objet fini, ses symboles appartiennent
  tous à un certain langage $\Sigma_n$ (en notant $\Sigma_n$ la suite de
  langages lors de la construction des $\mathcal T_n$). On sait alors que,
  $\mathcal T_{2n+2}$ contenant l'extension maximale d'une théorie sur
  $\Sigma_n$, soit $\varphi$ soit $\lnot\varphi$ y appartient. L'extension est
  donc maximale.
\end{itemize}

Avec tous ces éléments, il est maintenant possible de généraliser l'énoncé du
\cref{thm.completude}.

\begin{theorem}[Théorème de complétude généralisé]\label{thm.completude.gen}
  Soit une relation $\vdash$ vérifiant les règles suivantes~:
  \[\begin{array}{ccc}
  \AxiomC{$\varphi \in \mathcal T$}
  \RightLabel{(\textit{Ax})}
  \UnaryInfC{$\mathcal T \vdash \varphi$}
  \DisplayProof
  & \qquad &
  \AxiomC{$\mathcal T \vdash \varphi$}
  \AxiomC{$\mathcal T, \varphi \vdash \psi$}
  \RightLabel{(\textit{Cut})}
  \BinaryInfC{$\mathcal T \vdash \psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T \vdash \varphi$}
  \AxiomC{$\mathcal T \subseteq \mathcal T'$}
  \RightLabel{(\textit{Aff})}
  \BinaryInfC{$\mathcal T' \vdash \varphi$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T \vdash \varphi$}
  \RightLabel{(\textit{Comp})}
  \UnaryInfC{$\exists F \subfin \mathcal T, F\vdash \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T\vdash \varphi$}
  \RightLabel{$(l\lnot)$}
  \UnaryInfC{$\mathcal T, \lnot\varphi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \RightLabel{$(r\lnot)$}
  \UnaryInfC{$\mathcal T\vdash \lnot \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \AxiomC{$\mathcal T, \psi \vdash$}
  \RightLabel{$(l\lor)$}
  \BinaryInfC{$\mathcal T, \varphi\lor\psi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T \vdash \varphi$}
  \RightLabel{$(r\lor_1)$}
  \UnaryInfC{$\mathcal T\vdash \varphi\lor\psi$}
  \DisplayProof
  \quad
  \AxiomC{$\mathcal T \vdash \psi$}
  \RightLabel{$(r\lor_2)$}
  \UnaryInfC{$\mathcal T\vdash \varphi \lor \psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \RightLabel{$(l\land_1)$}
  \UnaryInfC{$\mathcal T,\varphi\land\psi\vdash$}
  \DisplayProof
  \quad
  \AxiomC{$\mathcal T, \psi \vdash$}
  \RightLabel{$(l\land_2)$}
  \UnaryInfC{$\mathcal T,\varphi \land \psi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T\vdash \varphi$}
  \AxiomC{$\mathcal T \vdash \psi$}
  \RightLabel{$(r\land)$}
  \BinaryInfC{$\mathcal T\vdash \varphi\land\psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T \vdash \varphi$}
  \AxiomC{$\mathcal T, \psi \vdash$}
  \RightLabel{$(l\to)$}
  \BinaryInfC{$\mathcal T, \varphi\to\psi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \RightLabel{$(r\to_1)$}
  \UnaryInfC{$\mathcal T\vdash \varphi\to\psi$}
  \DisplayProof
  \quad
  \AxiomC{$\mathcal T \vdash \psi$}
  \RightLabel{$(r\to_2)$}
  \UnaryInfC{$\mathcal T\vdash \varphi \to \psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T, \varphi[t/x] \vdash$}
  \RightLabel{$(l\forall)$}
  \UnaryInfC{$\mathcal T, \forall x, \varphi \vdash$}
  \DisplayProof
  & &
  \AxiomC{$c \notin \Const(\mathcal T, \varphi)$}
  \AxiomC{$\mathcal T \vdash \varphi[c/x]$}
  \RightLabel{$(r\forall)^\dagger$}
  \BinaryInfC{$\mathcal T \vdash \forall x, \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$c \notin \Const(\mathcal T, \varphi)$}
  \AxiomC{$\mathcal T, \varphi[c/x] \vdash$}
  \RightLabel{$(l\exists)^\dagger$}
  \BinaryInfC{$\mathcal T, \exists x, \varphi \vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T \vdash \varphi[t/x]$}
  \RightLabel{$(r\exists)$}
  \UnaryInfC{$\mathcal T \vdash \exists x, \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T \vdash \varphi[u / x]$}
  \RightLabel{$(l=)$}
  \UnaryInfC{$\mathcal T, t = u \vdash \varphi[t / x]$}
  \DisplayProof
  & &
  \AxiomC{}
  \RightLabel{$(r=)$}
  \UnaryInfC{$\mathcal T \vdash t = t$}
  \DisplayProof
  \end{array}\]
  \[
  \AxiomC{$\mathcal T, \lnot\varphi \vdash$}
  \RightLabel{(\textit{Raa})}
  \UnaryInfC{$\mathcal T \vdash \varphi$}
  \DisplayProof\]
  Alors on a l'inclusion $\vDash \subseteq \vdash$.
\end{theorem}

\begin{remark}
  Le fait que les règles $l\exists$ et $r\forall$ utilisent des constantes
  n'apparaissant ni dans $\mathcal T$, ni dans $\varphi$, impose que notre
  relation $\vdash$ est définie uniformément sur toutes les signatures.
  Cependant, on peut aussi ajouter une règle tout aussi raisonnable que les
  précédentes, qui est celle qu'on peut tirer du \cref{lem.var.const}. La
  règle
  \[
  \AxiomC{$c \notin \Const(\mathcal T, \varphi)$}
  \AxiomC{$x \notin \VL(\mathcal T)$}
  \AxiomC{$\mathcal T \vdash \varphi$}
  \TrinaryInfC{$\mathcal T \vdash \varphi[c/x]$}
  \DisplayProof
  \]
  ainsi construite permet de remplacer la condition de
  $c\notin \Const(\mathcal T, \varphi)$ par la règle plus simple
  $x\notin \VL(\mathcal T)$. Comme la quantification lie la variable $x$, on
  remarque aussi qu'il n'est pas nécessaire de demander que $x$ soit libre
  dans $\varphi$, et de substituer $x$ par une autre variable~: on peut
  directement travailler comme on le faisait dans le \cref{chp.logpred}.
\end{remark}

Il nous est donc possible, désormais, de prouver des théorèmes de complétude
bien plus facilement, en montrant simplement la validité d'un ensemble de
conditions. On remarque en fait que toutes ces conditions peuvent déjà donner
lieu à un premier système syntaxique. A la place de considérer une théorie
$\mathcal T$, on considère des séquents de la forme $\Gamma \vdash [\varphi]$
où $[\varphi]$ signifie que la conclusion est soit vide (dans le cas d'une
contradiction), soit la formule $\varphi$, et la relation $\vdash$ donnée par
les conditions modulo cette réécriture est déjà un système syntaxique de
démonstration complet vis à vis de $\vDash$. Il est possible de prouver qu'il
est correct, par un argument similaire au \cref{thm.correction}.

Cependant, plusieurs éléments méritent d'être relevés~:
\begin{itemize}
\item en supprimant simplement la règle $(Raa)$ du système, on obtient un
  système syntaxique intuitionniste, puisque l'affaiblissement permet à partir
  de $\mathcal T \vdash$, de déduire $\mathcal T \vdash \varphi$ pour n'importe
  quelle formule $\varphi$~;
\item il est donc possible d'avoir une théorie intuitionniste, mais le théorème
  de complétude ne s'y applique alors plus, car ce qui nous permet de passer de
  la construction d'un modèle à l'inclusion $\vDash\subseteq\vdash$ est le fait
  que, si $\mathcal T \cup\{\lnot\varphi\}$ n'a pas de modèle, alors
  $\mathcal T, \lnot\varphi\vdash$, donc que
  $\mathcal T \vdash \lnot\lnot\varphi$ sans la règle de raisonnement par
  l'absurde~;
\item une symétrie peut s'observer entre les règles droites et les règles
  gauches~: les règles $\lnot$ permettent de changer de côté du $\vdash$ en
  ajoutant un $\lnot$, les règles $\lor$ et $\land$ sont exactement identiques
  modulo une inversion des positions, et la même chose peut être dite pour les
  règles $\exists$ et $\forall$. Ces couples $\lor/\land$ et $\exists/\forall$
  sont ce qu'on appelle des duaux de De Morgan, c'est-à-dire qu'on a par exemple
  $\varphi \lor \psi \equiv \lnot (\lnot \varphi \land \lnot \psi)$~;
\item contrairement au \cref{chp.logpred}, les règles $(r\forall)^\dagger$ et
  $(l\exists)^\dagger$ utilisent des symboles de constantes, ce qui permet en
  fait avant tout de faciliter la preuve que nous avons donnée du théorème de
  complétude~: cela nous évite d'ajouter le théorème de simulation d'une
  constante par une variable, mais ce théorème est généralement vérifié pour
  un système syntaxique raisonnable, et on prendra donc généralement plutôt
  cette version~;
\item à l'exception des règles sur l'égalité, qui ont un statut particulier du
  fait que l'égalité n'est pas un symbole logique aussi simple à étudier que les
  autres, et de la règle $(Raa)$, toutes les autres règles ont la propriété dite
  de la sous-formule~: les séquents en haut d'une règle sont constitués de
  sous-formules du séquent en bas de la règle. C'est en fait un critère central
  pour considérer qu'un formalisme est un calcul des séquents, comme nous le
  verrons~;
\item le fait que notre théorème prouve la complétude en supposant la compacité
  du système indique que le théorème de compacité est lui-même vérifié. Il
  serait possible, au contraire, de démontrer d'abord le théorème de compacité,
  puis de construire une preuve de complétude n'utilisant que des jugements
  du type $\Gamma\vdash \varphi$, où $\Gamma$ est fini, mais la démonstration
  actuelle est plus puissante puisqu'elle donne bel et bien les deux faits à
  la fois. On peut donc décomposer la complétude de la façon suivante~:
  \begin{quote}
    Compacité $+$ Complétude faible $=$ Complétude forte
  \end{quote}
  où, dans le \cref{thm.completude.gen}, on prouve la complétude forte
  directement.
\end{itemize}

Nous avons donc deux options, que nous allons explorer au fil de ce chapitres~:
créer des séquents symétriques, ou travailler dans un système intuitionniste.

\subsection{Calcul des séquents LK}

La recherche d'un théorème de complétude plus général nous a en fait poussé vers
un nouveau formalisme~: en considérant les conditions du
\cref{thm.completude.gen}, on peut remplacer les séquents de la forme
$\mathcal T \vdash \varphi$ par des séquents de la forme $\Gamma \vdash \varphi$
où $\Gamma$ est un ensemble fini de formules, pour obtenir un système
syntaxique (finitaire). Compte tenu des nombreuses symétries entre le côté
gauche et le côté droit du $\vdash$ dans les règles, il est alors naturel de
vouloir construire des séquents de la forme $\Gamma\vdash \Delta$, où
$\Delta$ est aussi un ensemble fini de formules. S'il est assez clair que
$\Gamma$, dans le séquent $\Gamma\vdash \Delta$, se lit comme une conjonction
(on lit le séquent \og en supposant vraies toutes les formules de $\Gamma$\fg,
c'est-à-dire qu'on suppose la conjonction de toutes les formules), le dual
naturel est alors une disjonction sur $\Delta$~: ainsi le séquent
$\Gamma\vdash \Delta$ s'interprète comme l'énoncé \og en supposant vraies toutes
les formules de $\Gamma$, une au moins des formules de $\Delta$ est vraie\fg.
Naturellement, le cas où $\Gamma$ est vide donne alors une conclusion toujours
valide, et le cas où $\Delta$ est vide donne alors une contradiction des
hypothèses, les deux pouvant donc se réécrire respectivement comme
$\top \vdash \Delta$ et $\Gamma\vdash \bot$.

On peut maintenant définir notre premier calcul des séquents, $\LK$.

\begin{table}[t]
  \centering
  %\hrule
  \resizebox{\textwidth}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\Gamma, \varphi\vdLK \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \Delta, \varphi$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \lnot\varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\lor\psi \vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \RightLabel{$r\lor_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\lor\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLK \Delta,\psi$}
      \RightLabel{$r\lor_2$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi \lor \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \RightLabel{$l\land_1$}
      \UnaryInfC{$\Gamma,\varphi\land\psi\vdLK \Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma, \psi \vdLK \Delta$}
      \RightLabel{$l\land_2$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \AxiomC{$\Theta\vdLK \Xi,\psi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi, \varphi\land\psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\to\psi\vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$r\to_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\to\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma \vdLK \Delta,\psi$}
      \RightLabel{$r\to_2$}
      \UnaryInfC{$\Gamma\vdLK\Delta, \varphi \to \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\forall x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi[t/x]$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\exists x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLK t = t$}
      \DisplayProof
  \end{tabular}}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles du calcul des séquents $\LK$}
  \label{tbl.LK}
  \hrule
\end{table}

\begin{definition}[Calcul des séquents $\LK$ \cite{Gentzen1935}]
  Soit $\Sigma$ une signature du premier ordre. On définit inductivement
  l'ensemble $\ProofLK(\Sigma)$ par les règles de la \cref{tbl.LK}, où les
  règles $l\exists^\dagger$ et $r\forall^\dagger$ demandent que $x$ soit libre
  dans $\Gamma$ et $\Delta$. Le séquent le plus en bas d'un arbre
  $\pi\in\ProofLK(\Sigma)$ est appelé le séquent conclusion, et on note
  $\pi \concl \Gamma\vdLK\Delta$ pour signifier que $\Gamma\vdLK\Delta$ est
  la conclusion de $\pi$. On définit la relation de prouvabilité pour $\LK$
  par
  \[\Gamma\vdLK \Delta \defeq \exists \pi \in \ProofLK(\Sigma),
  \pi\concl \Gamma\vdLK\Delta\]
\end{definition}

\begin{remark}
  Dans notre formulation actuelle, les règles sont dites multiplicatives, ce
  qui signifie que les contextes s'accumulent au fil des utilisations de
  règles. Une autre version est la version additive, dans laquelle les contextes
  restent les mêmes. Par exemple, la version additive de $l\to$ est
  \begin{prooftree}
    \AxiomC{$\Gamma\vdLK \Delta, \varphi$}
    \AxiomC{$\Gamma, \psi \vdLK \Delta$}
    \RightLabel{$l\to$}
    \BinaryInfC{$\Gamma, \varphi \to \psi \vdLK \Delta$}
  \end{prooftree}
  En l'état, puisqu'on travaille avec le weakening et des ensembles de formules
  (où ni l'ordre ni le nombre d'occurrences des formules n'importe), les deux
  règles sont dérivables l'une à partir de l'autre. Les versions additives et
  multiplicatives sont donc équivalentes du point de vue logique, mais elles
  peuvent avoir un impact sur de la recherche de preuve, ou dans des logiques
  sous-structurelles comme la logique linéaire que nous aborderons plus tard.

  Nous choisissons une présentation multiplicative ici car le
  \cref{thm.completude.gen} induit naturellement une accumulation de contextes,
  en considérant
  \[\mathcal T \vdLK \varphi \defeq
  \exists \Gamma \subfin \mathcal T, \Gamma\vdLK \varphi\]
  En effet, les prémisses d'une règle telle que $l\to$ sont alors qu'il
  existe $\Gamma\subfin \mathcal T$ tel que $\Gamma\vdLK\varphi$ et qu'il
  existe $\Delta \subfin \mathcal T$ tel que $\Delta\vdLK\psi$, mais les
  deux contextes $\Gamma$ et $\Delta$ ne sont pas \latinexpr{a priori} les
  mêmes.
\end{remark}

\begin{remark}
  Contrairement au \cref{chp.logpred} ou au théorème de complétude, on définit
  l'ensemble des arbres de preuves pour définir ensuite la relation de
  prouvabilité. Cette approche se justifie par notre besoin de réécrire les
  arbres de preuves, et plus généralement d'étudier les arbres comme objet
  mathématiques et non simplement comme des relations.
\end{remark}

Le système $\LK$ est précisément conçu pour vérifier le
\cref{thm.completude.gen}, il est donc complet (et correct par une induction
sans difficulté).

\begin{proposition}
  Pour toute théorie $\mathcal T \subseteq \Formula(\Sigma)$ sur une signature
  $\Sigma$ fixée, la relation $\vdLK$ définie par
  \[\mathcal T \vdLK \varphi \defeq \exists \Gamma \in \powerfin(\mathcal T),
  \Gamma \vdLK \varphi\]
  coïncide avec la relation $\vDash$.
\end{proposition}

\begin{proof}
  L'induction pour prouver la correction de $\vdLK$ est très similaire à celle
  du \cref{thm.cor.logprop}, et nous ne la détaillons pas. Pour la complétude,
  il suffit de vérifier les règles~: la plupart se vérifient automatiquement
  de par la forme des règles de $\vdLK$, mais la règle $(Raa)$ n'a pas de
  règle correspondante dans $\vdLK$. On prouve donc qu'elle est malgré tout
  dérivable~:
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{$ax$}
    \UnaryInfC{$\varphi\vdLK\varphi$}
    \RightLabel{$r\lnot$}
    \UnaryInfC{$\vdLK\varphi,\lnot\varphi$}
    \AxiomC{$\Gamma,\lnot \varphi \vdLK$}
    \RightLabel{$cut$}
    \BinaryInfC{$\Gamma\vdLK\varphi$}
  \end{prooftree}
  On déduit donc que $\mathcal T \vDash \varphi \iff \mathcal T\vdLK \varphi$.
\end{proof}

La règle $cut$, outre son utilisation dans la preuve précédente, est un outil
central de démonstration. C'est grâce à cette règle qu'on a la possibilité,
en écrivant une preuve, de rajouter un résultat intermédiaire~: la règle permet
de faire le lien entre une hypothèse et une conclusion, en montrant que pour
deux séquents $\Gamma,\varphi\vdLK\Delta$ et $\Theta\vdLK\varphi,\Xi$, on peut
supprimer les deux occurrences de $\varphi$ et concaténer les contextes, pour
avoir $\Gamma,\Theta\vdLK\Delta,\Xi$.

La propriété centrale du calcul des séquents, qui a motivé l'étude de ce système
et qui date d'aussi loin que son introduction dans \cite{Gentzen1935}, est
l'élimination des coupures~: on peut en fait prouver que la relation $\vdLK$
prouve les mêmes formules si on supprime la règle $cut$. Autrement dit,
$cut$ est une règle admissible pour $\LK - cut$. On va prouver ce théorème, mais
on se propose d'abord d'explorer les conséquences de ce théorème, pour
comprendre son importance qui lui donne son nom de \foreignexpr{Hauptsatz}
(théorème principal, en allemand) dans l'article original.

On se donne donc pour l'instant l'élimination des coupures en tant qu'axiome.

\begin{axiom}[\'Elimination des coupures]
  Pour tout arbre de preuve $\pi$ de conclusion $\Gamma\vdLK \varphi$, il
  existe un arbre de preuve $\pi'$ de même conclusion mais ne contenant aucune
  occurrence de la règle $cut$.
\end{axiom}

La première conséquence est l'une des plus importantes pour justifier le bon
fonctionnement d'un système syntaxique~: la cohérence de $\LK$.

\begin{theorem}[Cohérence de $\LK$]
  Il est impossible de prouver le séquent $\vdLK$, ou de façon équivalente de
  prouver $\top\vdLK\bot$.
\end{theorem}

\begin{proof}
  On suppose qu'il existe une preuve de $\vdLK$. On trouve donc $\pi$ dont la
  conclusion est le séquent $\vdLK$, et par élimination des coupures on
  suppose que $\pi$ ne contient aucune règle $cut$. On voit alors que toutes
  les règles ont au moins une formule dans leur séquent conclusion. Il est
  donc impossible d'avoir une telle preuve sans coupure, et donc d'avoir une
  preuve de $\vdLK$. Le séquent $\top\vdLK\bot$ ne peut être obtenu que par
  affaiblissement depuis le séquent $\vdLK$, d'où le résultat.
\end{proof}

Ainsi, on ne peut pas tout prouver dans $\LK$. Ce résultat peut être directement
obtenu comme une conséquence du théorème de correction, puisque tout énoncé
prouvé dans $\LK$ doit être vrai aussi dans les modèles du séquent considéré.
La différence est qu'ici, le théorème nécessite uniquement l'utilisation de
l'élimination des coupures. Quand on prouvera l'élimination des coupures, on
verra que le procédé de transformation d'arbre est entièrement algorithmique,
et peut ainsi de définir de façon finitaire. La preuve de cohérence qui en
résultat est donc plus robuste que celle utilisant le théorème de correction,
dans laquelle on a besoin de quantifier nos résultats sur la classe de toutes
les structures, donnant lieu à une preuve bien plus infinitaire dans l'esprit.

La preuve de la cohérence de $\LK$ repose donc sur l'élimination des coupures et
sur une analyse des règles. On peut considérer les arbres sans coupures comme
des formes normales, dont la construction est en quelque sorte imposée par les
formules contenues dans la conclusion~: on doit ainsi remonter en utilisant des
règles décomposant les formules au fur et à mesure. En fait, on remarque un fait
important~: quand on monte dans l'arbre, en l'absence de coupures, toutes les
règles construisent des sous-formules des formules déjà présentes en bas de
l'arbre.

\begin{definition}[Ordre de sous-formule]
  Soit $\Sigma$ une signature.
  On définit sur $\Formula(\Sigma)$ un ordre, défini comme l'ordre des
  sous-formules, comme la plus petite relation de pré-oordre (non forcément
  antisymétrique) telle que~:
  \begin{itemize}
  \item $\varphi$ est une sous-formule de $\lnot\varphi$~;
  \item $\varphi$ et $\psi$ sont des sous-formules de $\varphi \land \psi$,
    $\varphi \lor \psi$ et $\varphi \to \psi$~;
  \item $\varphi[t/x]$ est une sous-formule de $\forall x, \varphi$ et de
    $\exists x, \varphi$, pour tout terme $t$~;
  \item si $t,u$ sont des termes, $x$ une variable et $\varphi$ une formule,
    alors $\varphi[t/x]$ est une sous-formule de $\varphi[u/x]$.
  \end{itemize}
\end{definition}

On peut ainsi énoncer la propriété de la sous-formule, dont la preuve est une
simple vérification des règles.

\begin{property}[Sous-formule]
  Soit $\pi$ un arbre de preuve de $\LK$ sans occurrence de la règle $cut$.
  Soit $\varphi_1,\ldots,\varphi_n \vdLK \psi_1,\ldots,\psi_k$ le séquent
  conclusion de $\pi$. Tout séquent apparaissant dans $\pi$ n'est constitué que
  de sous-formules des $\varphi_i$ et $\psi_i$.
\end{property}

\begin{remark}
  Ce fait est plus général de la cohérence, puisqu'une preuve sans coupure de
  $\vdLK$ serait une preuve acceptant la propriété de la sous-formule, ce qui
  est absurde.
\end{remark}

Combinons maintenant ce résultat et le résultat important de
l'\cref{exo.prenexe}. On peut remplacer les formules du séquent conclusion par
des formules équivalentes, toutes sous forme normale. Par la propriété de la
sous-formule, on sait alors que toutes les formules qui apparaissent sont
des sous-formules de formes prénexes~: il est facile en considérant la relation
de sous-formule de remarquer que ce sont des formules elles-mêmes sous forme
prénexe. Ainsi, tout séquent prouvable $\Gamma \vdLK \Delta$ est équivalent à
un arbre de preuve contenant uniquement des formules sous forme prénexe.

\begin{figure}[t]
  \resizebox{\textwidth}{!}{
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    $\rOne$ & $\Sigma^l$ & $\Sigma^r$ & $\Phi^l$ & $\Phi^r$ \\
    \hline
    $lw$ & $\varnothing$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ \\
    $rw$ & $\varnothing$ & $\varnothing$ & $\varnothing$ & $\{\varphi\}$ \\
    $l\lnot$ & $\varnothing$ & $\{\varphi\}$ & $\{\lnot\varphi\}$ &
    $\varnothing$ \\
    $r\lnot$ & $\{\varphi\}$ & $\varnothing$ & $\varnothing$ &
    $\{\lnot\varphi\}$ \\
    $r\lor_1$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ &
    $\{\varphi \lor \psi\}$ \\
    $r\lor_2$ & $\varnothing$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi\lor\psi\}$ \\
    $l\land_1$ & $\{\varphi\}$ & $\varnothing$ & $\{\varphi\land\psi\}$ &
    $\varnothing$ \\
    $l\land_2$ & $\{\psi\}$ & $\varnothing$ & $\{\varphi\land\psi\}$ &
    $\varnothing$ \\
    $r\to_1$ & $\{\varphi\}$ & $\varnothing$ & $\varnothing$ &
    $\{\varphi \to \psi\}$ \\
    $r\to_2$ & $\varnothing$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi\to\psi\}$ \\
    $l\forall$ & $\{\varphi[t/x]\}$ & $\varnothing$ &
    $\{\forall x, \varphi\}$ & $\varnothing$ \\
    $r\forall$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ &
    $\{\forall x, \varphi\}$ \\
    $l\exists$ & $\{\varphi\}$ & $\varnothing$ & $\{\exists x, \varphi\}$ &
    $\varnothing$ \\
    $r\exists$ & $\varnothing$ & $\{\varphi[t/x]\}$ & $\varnothing$ &
    $\{\exists x, \varphi\}$ \\
    \hline
  \end{tabular}
  \quad
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    $\rTwo$ & $\Sigma_1^l$ & $\Sigma_1^r$ & $\Sigma_2^l$ & $\Sigma_2^r$ &
    $\Phi^l$ & $\Phi^r$ \\
    \hline
    $l\lor$ & $\{\varphi\}$ & $\varnothing$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi \lor \psi\}$ & $\varnothing$ \\
    $r\land$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ &
    $\{\psi\}$ & $\varnothing$ & $\{\varphi\land \psi\}$ \\
    $l\to$ & $\varnothing$ & $\{\varphi\}$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi\to\psi\}$ & $\varnothing$\\
    \hline
  \end{tabular}
  }
  \caption{Tables de typologie des règles de $\LK$}
  \label{fig.typologie1}
\end{figure}

En analysant plus précisément les règles successives, on peut relever des
réécritures posibles pour commuter certaines règles. Ces réécritures permettent
de \og faire descendre dans l'arbre \fg les règles portant sur les
quantificateurs, de sorte qu'on puisse transformer notre arbre de preuve en
un arbre en deux blocs~: le bas de l'arbre ne contient que des règles
$l\forall / r\forall / l\exists / r\exists$ ainsi que des règles $lw / rw$,
et le haut de l'arbre ne contient que d'autres règles que les $6$ précédentes
(et aucun $cut$ puisqu'on considère des arbres sans coupure).

\subsection[Théorème de Herbrand]{Théorème du séquent du milieu et
  théorème de Herbrand}

Pour prouver ce théorème, il nous faut d'abord donner une typologie des règles,
de sorte à pouvoir écrire plus facilement les transformations. Pour cela, on
commence par définir plusieurs blocs de règles.

\begin{definition}[Groupes de règles]
  On appelle règles structurelles les règles $lw/rw$. On appelle règles
  logiques les règles
  $l\lnot/r\lnot/l\lor/r\lor_1/r\lor_2/l\land_1/l\land_2/r\land
  /l\to/r\to_1/r\to_2/l\forall/r\forall/l\exists/r\exists/l=/r=$.

  Parmi les règles logiques, on appelles règles quantifiantes les règles
  $l\forall/r\forall/l\exists/r\exists$, règles égalitaires les règles
  $l=/r=$ et règles connectives les autres règles logiques.

  On dira qu'une règle est de type $\rOne$ si elle a une seule prémisse, et
  de type $\rTwo$ si elle a deux prémisses.
\end{definition}

Toutes les règles non égalitaires de type $\rOne$ peuvent alors s'écrire de la
façon suivante~:
\[
\AxiomC{$\Gamma,\Sigma^l \vdLK \Sigma^r,\Delta$}
\RightLabel{$l\rOne$}
\UnaryInfC{$\Gamma,\varphi \vdLK \Delta$}
\DisplayProof
\qquad
\AxiomC{$\Gamma,\Sigma^l \vdLK\Sigma^r, \Delta$}
\RightLabel{$r\rOne$}
\UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
\DisplayProof
\]
où $\Sigma^l$ et $\Sigma^r$ contiennent des sous-formules de $\varphi$ (et
chacun contient au plus une formule). On appelle contexte d'une règle les
formules dans $\Gamma,\Delta$, qui sont inchangées lors de l'application de la
règle.

Les règles de type $\rTwo$ peuvent s'écrire de façon similaire~:
\begin{center}
  \resizebox{\textwidth}{!}{\(
    \AxiomC{$\Gamma_1,\Sigma^l_1 \vdLK \Sigma^r_1,\Delta_1$}
    \AxiomC{$\Gamma_2,\Sigma^l_2 \vdLK \Sigma^r_2,\Delta_2$}
    \RightLabel{$l\rTwo$}
    \BinaryInfC{$\Gamma_1,\Gamma_2,\varphi \vdLK \Delta_1,\Delta_2$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma_1,\Sigma^l_1 \vdLK \Sigma^r_1,\Delta_1$}
    \AxiomC{$\Gamma_2,\Sigma^l_2 \vdLK \Sigma^r_2,\Delta_2$}
    \RightLabel{$r\rTwo$}
    \BinaryInfC{$\Gamma_1,\Gamma_2\vdLK \varphi,\Delta_1,\Delta_2$}
    \DisplayProof
    \)}
\end{center}

Quitte à abstraire $\varphi$, on peut considérer que les règles gauches et
droites s'écrivent avec en séquent conclusion
$\Gamma, \Phi^l\vdLK\Phi^r,\Delta$ où $\Phi^l,\Phi^r$ sont deux ensembles de
formules tels que $\Phi^l \cup \Phi^r = \{\varphi\}$ et
$\Phi^l\cap \Phi^r = \varnothing$. On obtient ainsi les deux règles
\[
\AxiomC{$\Gamma,\Sigma^l \vdLK \Sigma^r,\Delta$}
\RightLabel{$\rOne$}
\UnaryInfC{$\Gamma,\Phi^l \vdLK \Phi^r,\Delta$}
\DisplayProof
\qquad
\AxiomC{$\Gamma_1,\Sigma^l_1 \vdLK \Sigma^r_1,\Delta_1$}
\AxiomC{$\Gamma_2,\Sigma^l_2 \vdLK \Sigma^r_2,\Delta_2$}
\RightLabel{$\rTwo$}
\BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK \Phi^r,\Delta_1,\Delta_2$}
\DisplayProof
\]
qui permettent de réécrire toutes les règles non égalitaires. On donne en
\cref{fig.typologie1} les instances de $\rOne$ et $\rTwo$ pour obtenir les
différentes règles.

On peut maintenant introduire le procédé de réécriture permettant de faire
remonter les règles connectives.

\begin{definition}[Commutation quantitative]
  On donne les réécritures suivantes de suites d'arbres, où
  $\quantif\in\{\forall,\exists\}$~:
  \begin{center}\resizebox{\textwidth}{!}{
      $\begin{array}{ccc}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma,\Sigma^l\vdLK\Sigma^r,\Delta$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\, \varphi, \Gamma, \Sigma^l\vdLK\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
        \DisplayProof
        & \reecr{l\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma,\Sigma^l\vdLK\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\varphi[t/x],\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\, \varphi, \Gamma_1,
          \Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK \Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{l\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\varphi[t/x],\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK \Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\, \varphi, \Gamma_2,
          \Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{l\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\varphi[t/x],\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof

        \\
        \\

        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x][u/y],\Gamma[u/y]\vdLK\Delta[u/y]$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi[u/y],\Gamma[u/y]\vdLK\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\quantif x\,\varphi[v/y], \Gamma[v/y],
          u = v\vdLK\Delta[v/y]$}
        \DisplayProof
        &\reecr{l=\quantif \downarrow} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x][u/y],\Gamma[u/y]\vdLK\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\varphi[t/x][v/y],\Gamma[v/y], u = v\vdLK\Delta[v/y]$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi[v/y], \Gamma[v/y],
          u = v\vdLK\Delta[v/y]$}
        \DisplayProof
      \end{array}
      $}
  \end{center}
  \begin{center}\resizebox{\textwidth}{!}{
      $\begin{array}{ccc}
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\Sigma^l\vdLK\varphi[t/x],\Sigma^r,\Delta$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma, \Sigma^l\vdLK
          \quantif x\,\varphi,\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\Gamma,\Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta$}
        \DisplayProof
        & \reecr{r\quantif \downarrow} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\Sigma^l\vdLK\varphi[t/x],\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\Gamma,\Phi^l\vdLK\varphi[t/x],\Phi^r,\Delta$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma,\Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\varphi[t/x],\Sigma^r_1,\Delta_1$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_1,
          \Sigma^l_1\vdLK\quantif x\, \varphi, \Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK \Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{r\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\varphi[t/x],\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\varphi[t/x],
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\quantif x\,\varphi,
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK \Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\varphi[t/x],\Sigma^r_2,\Delta_2$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_2,
          \Sigma^l_2\vdLK\quantif x\, \varphi, \Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{r\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\varphi[t/x],\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\varphi[t/x],
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\quantif x\,\varphi,
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof

        \\
        \\

        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma[u/y]\vdLK\varphi[u/y][t/x],\Delta[u/y]$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma[u/y]\vdLK\quantif x\,\varphi[u/y],\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma[v/y],
          u = v\vdLK\quantif x\,\varphi[v/y], \Delta[v/y]$}
        \DisplayProof
        &\reecr{r=\quantif \downarrow} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma[u/y]\vdLK\varphi[u/y][t/x],\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma[v/y], u = v\vdLK\varphi[v/y][t/x],\Delta[v/y]$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma[v/y],
          u = v\vdLK\quantif x\,\varphi[v/y], \Delta[v/y]$}
        \DisplayProof
      \end{array}$
    }
  \end{center}
\end{definition}

\begin{remark}
  Cette réécriture d'arbres de preuve est bien définie. Pour la plupart des
  règles, cette bonne définition est claire. Relevons cependant que dans le
  cas où, par exemple, on fait la réécriture $l\quantif\downarrow$ où
  $\quantif = \exists$, il convient de vérifier que la variable $x$ est
  bien libre dans les autres séquents des règles une fois écrites~: c'est le
  cas si la règle initiale était bien applicable.

  De même, pour les règles $=\quantif\downarrow$, il faut vérifier que l'on peut
  bien faire commuter les deux substitutions $[t/x]$ et $[u/y]$
  (respectivement $[v/y]$). Si le cas est tel $l\forall$, où le terme introduit
  n'importe pas, on peut toujours réécrire la formule en $\varphi[u/y]$
  (respectivement $[v/y]$) au moment d'introduire la quantification. Si le cas
  est tel $l\exists$, où le terme $t$ est en fait exactement $x$, on sait donc
  que $x$ est une variable libre uniquement de $v$ (puisque la possibilité
  d'appliquer $l\exists$ par exemple présuppose que $\Gamma[u/y]$ et
  $\Delta[u/y]$ ne possèdent pas $x$ comme variable libre), et on peut donc
  remplacer $x$ dans $v$ par n'importe quelle autre variable qui n'est pas
  encore apparue.
\end{remark}

Il est ainsi possible de réécrire des arbres de preuves par les règles
$l\quantif\downarrow$ et $r\quantif\downarrow$. Pour l'instant on a seulement
défini les règles de réécriture sur des arbres fixés, qui sont des instances
locales d'une réécriture qu'on souhaite effectuer de façon globale. Il faut
donc définir une notion de réécriture globale. On introduit pour ça la notion
de relation compatible.

\begin{definition}[Relation compatible]
  Soit $R\subseteq \ProofLK \times \ProofLK$ une relation sur des arbres de
  preuves. $R$ est dite compatibles si, pour chaque règle de construction de
  $\LK$, de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma_1\vdLK \Delta_1$}
    \AxiomC{$\cdots$}
    \AxiomC{$\Gamma_n\vdLK\Delta_n$}
    \RightLabel{$r$}
    \TrinaryInfC{$\Theta\vdLK\Xi$}
  \end{prooftree}
  pour tous $i$, $\pi_i \concl \Gamma_i\vdLK\Delta_i$ et
  $\pi' \concl\Gamma_j\vdLK\Delta_j$ pour un certain $j$, si $\pi_j R \pi'$
  alors on a
  \begin{center}
    \resizebox{0.4\textwidth}{!}{$
      \AxiomC{$\pi_1$}
      \noLine
      \UnaryInfC{$\Gamma_1\vdLK\Delta_1$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi_j$}
      \noLine
      \UnaryInfC{$\Gamma_j\vdLK\Delta_n$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi_n$}
      \noLine
      \UnaryInfC{$\Gamma_n\vdLK\Delta_n$}
      \RightLabel{$r$}
      \QuinaryInfC{$\Theta\vdLK\Xi$}
      \DisplayProof
      $}
    \quad
    \raisebox{-0.2cm}{$R$}
    \quad
    \resizebox{0.4\textwidth}{!}{$
      \AxiomC{$\pi_1$}
      \noLine
      \UnaryInfC{$\Gamma_1\vdLK\Delta_1$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi'$}
      \noLine
      \UnaryInfC{$\Gamma_j\vdLK\Delta_j$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi_n$}
      \noLine
      \UnaryInfC{$\Gamma_n\vdLK\Delta_n$}
      \RightLabel{$r$}
      \QuinaryInfC{$\Theta\vdLK\Xi$}
      \DisplayProof
      $}
  \end{center}
\end{definition}

Une relation compatible est donc une relation telle que, par exemple, si
$\pi R \pi'$ alors
$\AxiomC{$\pi$}\RightLabel{$lw$}\UnaryInfC{$\Gamma\vdLK\Delta$}\DisplayProof R
\AxiomC{$\pi'$}\RightLabel{$lw$}\UnaryInfC{$\Gamma\vdLK\Delta$}\DisplayProof$.
C'est cette notion de relation compatible qui va permettre de considérer des
réduction dans des sous-arbres des arbres de preuve.

\begin{definition}[Réduction des commutations quantitatives]
  On définit la relation $\reecr{\quantif\downarrow}$ comme la plus petite
  relation compatible contenant les instances de $\reecr{l\quantif\downarrow}$,
  de $\reecr{r\quantif\downarrow}$, de $\reecr{l=\quantif\downarrow}$ et
  $\reecr{r=\quantif\downarrow}$.
\end{definition}

Notre relation $\reecr{\quantif\downarrow}$ nous permet donc de faire descendre
des règles quantitatives dans un arbre de preuve. On souhaite maintenant réduire
autant que possible nos arbres pour cette réécriture. Ce processus est
algorithmique, et il nécessite donc deux preuves algorithmiques pour assurer
qu'il permet d'obtenir le résultat qu'on recherche~:
\begin{itemize}
\item la terminaison, qui indique que la réduction s'opère un nombre fini de
  fois, et qui se prouve en montrant qu'il n'existe pas de suite infinie de
  la forme
  $\pi_1 \reecr{\quantif\downarrow}\pi_2\reecr{\quantif\downarrow}\cdots$
\item la correction, qui indique que la réduction se termine par un arbre de
  preuve qui vérifie la propriété qu'on recherche, ici que toute règle
  connective est située au-dessus de toute règle quantitative.
\end{itemize}

Pour prouver la terminaison, plusieurs méthodes sont possibles. La méthode la
plus difficile consiste à prouver que la réduction, ici
$\reecr{\quantif\downarrow}$, est une relation bien fondée. Ce fait n'est pas
toujours vrai, mais le prouver signifie alors que tout choix de suite de
réductions s'arrêtera à un moment (il peut pour autant y avoir des choix plus
efficaces que d'autres). La seconde méthode est d'assigner à toute instance de
notre problème de réécriture (ici, à tout arbre de preuve) une \og mesure\fg
qui est un élément d'un ensemble bien ordonné, et de prouver que pour tout
élément $\pi$ il existe un élément $\pi'$ tel que
$\pi\reecr{\quantif\downarrow} \pi'$ et tel que la mesure de $\pi'$ est
strictement inférieure à celle de $\pi$, ou alors que $\pi$ n'a pas de
successeur pour la réduction considérée.

On définit donc une mesure sur les arbres.

\begin{definition}[Poids d'une règle connective, d'un arbre]
  Soit $r$ une règle connective apparaissant dans un arbre de preuve $\pi$.
  On définit $w(r)$, le poids de $r$, comme le nombre de règles
  $r\quantif / l\quantif$ qui sont
  dans les sous-arbres des prémisses de $r$. On définit $w(\pi)$, le poids de
  l'arbre $\pi$, comme la somme des poids des règles qui composent $\pi$.
\end{definition}

\begin{proposition}\label{prop.weight.midsequent}
  Si $\pi\reecr{\quantif\downarrow}\pi'$, alors $w(\pi') = w(\pi) - 1$.
\end{proposition}

\begin{proof}
  Il suffit de regarder les différentes règles dans
  $\reecr{\quantif\downarrow}$. Si on est dans un cas inductif, l'hypothèse
  d'induction nous donne le résultat directement. Si on est dans l'un des
  cas de base, on vérifie qu'à chaque cas une règle connective est déplacée
  sous une règle quantitative, ce qui diminue le poids de la règle connective
  de $1$ et laisse inchangés tous les autres poids.
\end{proof}

On peut donc montrer le théorème du séquent du milieu.

\begin{theorem}[Séquent du milieu]\label{thm.midsequent}
  Soit $\Gamma\vdLK\Delta$ un séquent composé de formules sous forme prénexe.
  S'il existe un arbre de preuve $\pi\in\ProofLK$ tel que
  $\pi\concl \Gamma\vdLK\Delta$, alors il existe un arbre de preuve
  $\pi'\in\ProofLK$ tel que $\pi'\concl\Gamma\vdLK\Delta$ et ne contenant
  des règles quantitatives qu'en bas de l'arbre, c'est-à-dire qu'il existe un
  entier $n$ tel que les $n$ règles les plus basses de $\pi'$ sont des règles
  quantitatives, et toutes les autres règles sont des règles connectives,
  d'affaiblissement ou égalitaires.
\end{theorem}

\begin{proof}
  D'après la \cref{prop.weight.midsequent}, on sait qu'il est possible de
  trouver depuis $\pi$ un arbre $\pi'$ tel que
  $\pi\reecr{\quantif\downarrow}^\star \pi'$ et $\pi'$ ne se réduit en
  aucun autre arbre.

  On veut prouver qu'il n'existe aucune règle quantitative au-dessus d'une
  règle connective ou d'affaiblissement. Supposons qu'une telle suite de deux
  règles arrive. En utilisant les notations avec
  $\Sigma^l,\Sigma^r,\Phi^l,\Phi^r$, on sait que si
  la formule $\varphi[t/x]$ utilisée pour la règle $\quantif$ est dans
  le contexte, alors une réduction $\reecr{\quantif\downarrow}$ peut
  s'appliquer, contredisant le fait que $\pi'$ ne peut pas se réduire.
  On en déduit donc, sans perte de généralité, que $\varphi[t/x]$ est dans
  $\Sigma^l$. Mais alors, cela signifie que $\quantif x\,\varphi$ est une
  sous-formule de la règle du dessus. Si la règle du dessous est une règle
  logique, on obtient alors une formule qui n'est pas sous forme prénexe, ce
  qui contredit le fait que $\Gamma\vdLK\Delta$ est sous forme prénexe et la
  propriété de la sous-formule (et la règle ne peut pas être un affaiblissement
  si $\quantif x\,\varphi \in \Sigma^l$).

  Enfin, si $\pi_1\reecr{\quantif\downarrow} \pi_2$, alors $\pi_1$ et
  $\pi_2$ ont le même séquent conclusion, donc $\pi'$ a le même séquent
  conclusion que $\pi$.

  On en déduit que $\pi'$ vérifie les hypothèses.
\end{proof}

\begin{figure}[t]
  \centering
  \begin{tikzpicture}
    \node (A) at (0,-5) {$\Gamma\vdLK\Delta$};
    \node (B) at (0,0) {Séquent du milieu};
    \draw (A) -- (B)
    node[midway,rotate=90,below]{Règles quantitatives};
    \node (C) at (0,3) {Règles connectives et};
    \node (D) at (0,2.5) {d'affaiblissement};
    \draw[dashed] (B) -- (-5,5) -- (5,5) -- (B);
  \end{tikzpicture}
  \caption{Arbre de preuve avec séquent du milieu}
  \label{fig.midsequent}
\end{figure}

On donne en \cref{fig.midsequent} la silhouette d'un arbre de preuve respectant
le séquent du milieu. La forme purement verticale des règles quantitatives est
dû au fait qu'elles sont toutes de type $\rOne$.

En particulier, cela signifie qu'une preuve d'une formule existentielle ne peut
pas utiliser de données connectives pour s'effectuer~: elle doit pouvoir se
dérouler en introduisant directement les témoins à l'aide des règles
$l\exists/r\exists$. Cela entraine directement le théorème d'Herbrand.

\begin{theorem}[Herbrand]\label{thm.Herbrand}
  Soit $\exists x, \varphi$ une formule. Cette formule est prouvable
  si et seulement s'il existe des termes $t_1,\ldots,t_n$ tels que
  le séquent $\vdLK\varphi[t_1/x],\ldots,\varphi[t_n/x]$ est
  prouvable.
\end{theorem}

\begin{proof}
  Si le séquent $\vdLK\varphi[t_1/x],\ldots,\varphi[t_n/x]$ est prouvable, alors
  il est clair que
  $\exists x,\varphi$ est prouvable. Réciproquement, supposons que
  $\vdLK\exists x,\varphi$. Ce séquent est sous forme prénexe~: on y applique
  le \cref{thm.midsequent} pour obtenir un arbre de preuve
  $\pi\concl\vdLK\exists x, \varphi$ commençant par des règles
  quantitatives. Le séquent du milieu est donc constitué uniquement de
  sous-formules de $\varphi$. S'il contient $\exists x, \varphi$, alors
  tous les arbres au-dessus de ce séquent contiendront
  $\exists x, \varphi$ (puisqu'aucune règle non connective ne peut
  introduire $\exists$) ou appliqueront un affaiblissement sur cette
  dernière formule. On en déduit donc, quitte à supprimer la dernière
  formule $\exists x, \varphi$, que le séquent du milieu est constitué
  uniquement de sous-formules de $\exists x, \varphi$ et n'est pas
  constitué de $\exists x, \varphi$.

  On sait, de plus, que toutes les règles appliquées entre la conclusion
  $\vdLK\exists x, \varphi$ et le séquent du milieu, sont des règles
  $r\exists$, aucune autre règle quantitative n'étant applicable. On en déduit
  finalement que le séquent du milieu est
  $\vdLK \varphi[t_1/x],\ldots,\varphi[t_n/x]$ pour certains termes
  $t_1,\ldots,t_n$.
\end{proof}

Ce théorème peut sembler légèrement contre-intuitif. Lorsqu'on considère le
séquent $\vdLK\exists x, \varphi$, on peut être tenté de dire que, dans l'arbre
de preuve dont ce séquent est la conclusion, la dernière règle est $r\exists$
et le séquent au-dessus est donc $\vdLK \varphi[t/x]$. Ainsi, on s'attendrait à
ce qu'il n'existe qu'un seul terme $t$.

Contrairement aux attentes, la règle $r\exists$ ne ressemble pas forcément à
\begin{prooftree}
  \AxiomC{$\vdLK\varphi[t/x]$}
  \RightLabel{$r\exists$}
  \UnaryInfC{$\vdLK\exists x, \varphi$}
\end{prooftree}
mais peut aussi être de la forme
\begin{prooftree}
  \AxiomC{$\vdLK\exists x\, \varphi, \varphi[t/x]$}
  \RightLabel{$r\exists$}
  \UnaryInfC{$\vdLK\exists x, \varphi$}
\end{prooftree}
étant donné que nous manipulons des ensembles finis de formules. C'est ainsi, en
répétant le dernier arbre, qu'on peut engendrer un ensemble de termes
$t_1,\ldots,t_n$ et le séquent $\vdLK \varphi[t_1/x],\ldots,\varphi[t_n/x]$.

Ce théorème peut donc être renforcé dans le cas où tout séquent contient au plus
une formule à droite de $\vdLK$, ce qui est précisément le cas du calcul
intuitionniste, que nous abordons en SECTION INTUITIONNISTE.

\subsection{Formulations alternatives de LK}

On voit aussi apparaître un défaut de l'utilisation d'ensembles de formules~:
le fait de dupliquer une formule n'est pas anodin et devrait donc être explicité
plutôt que d'être une conséquence du type de données utilisé. Pour y remédier,
on peut utiliser au choix des listes de formules, comme on l'a fait dans le
\cref{chp.logpred}, ou des multi-ensembles.

\begin{table}[t]
  \centering
  %\hrule
  \resizebox{\textwidth}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\varphi\vdLK \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLK\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \Delta, \varphi$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \lnot\varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\lor\psi \vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \RightLabel{$r\lor_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\lor\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLK \Delta,\psi$}
      \RightLabel{$r\lor_2$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi \lor \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \RightLabel{$l\land_1$}
      \UnaryInfC{$\Gamma,\varphi\land\psi\vdLK \Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma, \psi \vdLK \Delta$}
      \RightLabel{$l\land_2$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \AxiomC{$\Theta\vdLK \Xi,\psi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi, \varphi\land\psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\to\psi\vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$r\to_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\to\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma \vdLK \Delta,\psi$}
      \RightLabel{$r\to_2$}
      \UnaryInfC{$\Gamma\vdLK\Delta, \varphi \to \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\forall x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi[t/x]$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\exists x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLK t = t$}
      \DisplayProof
  \end{tabular}}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LK$ avec multi-ensembles}
  \label{tbl.LK.multiset}

  \hrule
\end{table}

\begin{definition}[Multi-ensembles]
  Soit $X$ un ensemble.
  On appelle multi-ensemble d'éléments de $X$, ou juste multi-ensemble,
  une fonction $Y : X \to \bN$, et on note $\powermul(X)$ l'ensemble des
  multi-ensembles sur $X$. On définit sur les multi-ensembles les
  opérations
  \[
  \makeFun{\cup}{\powermul(X)\times\powermul(X)}{\powermul(X)}{(Y,Z)}
          {x \mapsto \max(Y(x),Z(x))}
  \]
  \[
  \makeFun{\cap}{\powermul(X)\times\powermul(X)}{\powermul(X)}{(Y,Z)}
          {x \mapsto \min(Y(x),Z(x))}
  \]
  \[
  \makeFun{+}{\powermul(X)\times\powermul(X)}{\powermul(X)}{(Y,Z)}
          {x \mapsto Y(x) + Z(x)}
  \]
  On dit qu'un multi-ensemble $Y$ est fini si son support
  $\Supp(Y) \defeq \{ x \in X \mid Y(x) \neq 0 \}$ est fini.
\end{definition}

\begin{remark}
  Les parties d'un ensemble peuvent être vues comme des multi-ensembles dont
  le codomaine est $\btwo$, grâce à leur fonction caractéristique. On a même
  un moyen de transformer un multi-ensemble en ensemble, en ramenant toutes les
  valeurs strictement positives à $1$. Cette opération commute alors avec les
  opérations d'union et d'intersection, et $+$ devient alors $\cup$ une fois
  interprété dans les ensembles.
\end{remark}

Dans le cas des multi-ensembles, l'ordre n'importe pas, mais le nombre
d'occurrences d'une formule importe. On doit donc ajouter une règle permettant
de transformer deux occurrences en une seule~: c'est la règle de contraction.

\begin{definition}[Calcul des séquents $\LK$ avec multi-ensembles]
  On définit le calcul des séquents $\LK$ avec multi-ensembles par l'ensemble
  $\ProofLK$ construit d'après les règles de la \cref{tbl.LK.multiset} où
  les séquents $\Gamma\vdLK\Delta$ sont constitués de multi-ensembles finis, et
  où $\Gamma,\Delta$ est le multi-ensemble $\Gamma + \Delta$.
\end{definition}

Le \cref{thm.Herbrand} dans ce cadre se prouve alors en considérant que les
dernières règles sont des successions de $r\exists$ et de $rc$, d'où la
multiplication des termes $t_1,\ldots,t_n$.

En utilisant des arbres sans coupure, et encore plus en utilisant le
\cref{thm.midsequent}, il est donc possible de faire de la recherche de
preuves~: si on considère un séquent $\Gamma\vdLK\Delta$, on sait qu'il est
prouvable si et seulement s'il l'est par un arbre sans coupure, et commençant
uniquement par des règles quantitatives (quitte à mettres les formules de
$\Gamma$ et $\Delta$ sous forme prénexe). Cette approche de la synthèse d'arbres
de preuves motive alors une présentation \og vers le haut\fg de $\LK$. Dans
cette présentation, les règles sont construites de sorte à favoriser le
parcours de l'arbre en partant de la conclusion, et en cherchant à construire
les sous-arbres. On conserve donc au maximum les hypothèses, au lieu de les
scinder comme dans la présentation précédente (on a donc un style additif).

\begin{table}[t]
  \centering
  %\hrule
  %\resizebox{!}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\Gamma,\varphi\vdLK \varphi,\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLK\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi,\psi,\Gamma'\vdLK\Delta$}
      \RightLabel{\textit{le}}
      \UnaryInfC{$\Gamma,\psi,\varphi,\Gamma'\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\Delta,\varphi,\psi,\Delta'$}
      \RightLabel{\textit{re}}
      \UnaryInfC{$\Gamma\vdLK\Delta,\psi,\varphi,\Delta'$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \lnot\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Gamma, \psi \vdLK \Delta$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \varphi\lor\psi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\psi,\Delta$}
      \RightLabel{$r\lor$}
      \UnaryInfC{$\Gamma\vdLK \varphi \lor \psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi,\psi \vdLK \Delta$}
      \RightLabel{$l\land$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \AxiomC{$\Gamma\vdLK \psi,\Delta$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma\vdLK \varphi\land\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Gamma \psi \vdLK \Delta$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \varphi\to\psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\psi,\Delta$}
      \RightLabel{$r\to$}
      \UnaryInfC{$\Gamma\vdLK \varphi\to\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \forall x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi[t/x],\Delta$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \exists x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\Gamma \vdLK t = t,\Delta$}
      \DisplayProof
  \end{tabular}%}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LK$ présenté vers le haut avec listes}
  \label{tbl.LK.upward}

  \hrule
\end{table}

On donne donc la version vers le haut de $\LK$, dans laquelle on considère des
listes plutôt que des multi-ensembles, pour offrir une version la plus formelle
possible du système syntaxique.

\begin{definition}[Calcul des séquents $\LK$ présenté vers le haut avec listes]
  Le calcul des séquents $\LK$ présenté vers le haut avec listes est l'ensemble
  $\ProofLK$ décrit par les règles de la \cref{tbl.LK.upward}, où les
  séquents $\Gamma\vdLK\Delta$ sont donnés par des listes de formules, et où
  $\Gamma,\Delta$ est la concaténation des listes $\Gamma$ et $\Delta$.
\end{definition}

\begin{remark}
  Le fait de considérer des listes nous pousse à ajouter les règles d'échange
  $le/re$. On peut prouver grâce à elles, et en sachant que toute permutation
  s'écrit comme produit de transpositions, que si $\sigma,\rho$ sont deux
  permutations respectivement de $\Gamma$ et de $\Delta$, alors
  \begin{prooftree}
    \AxiomC{$\Gamma\vdLK\Delta$}
    \RightLabel{\textit{exch}}
    \UnaryInfC{$\sigma(\Gamma)\vdLK\rho(\Delta)$}
  \end{prooftree}
  est dérivable.

  Au contraire, les deux règles $lw/rw$ ne sont ici pas considérées. Cela est
  dû au fait que ces règles sont directement dérivables~: comme les règles
  préservent toutes leur contexte et que $ax$ et $r=$ sont contextuelles (au
  sens où on n'a pas simplement $\varphi \vdLK \varphi$ mais un contexte
  autour de ce séquent), tout ajout de formules dans le contexte peut se
  conserver des feuilles à la conclusion.
\end{remark}

\begin{table}[t!]
  \centering
  %\hrule
  %\resizebox{!}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\varphi\vdLK \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLK\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi,\psi,\Gamma'\vdLK\Delta$}
      \RightLabel{\textit{le}}
      \UnaryInfC{$\Gamma,\psi,\varphi,\Gamma'\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\Delta,\varphi,\psi,\Delta'$}
      \RightLabel{\textit{re}}
      \UnaryInfC{$\Gamma\vdLK\Delta,\psi,\varphi,\Delta'$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLK \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \lnot\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\lor\psi \vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\psi,\Delta$}
      \RightLabel{$r\lor$}
      \UnaryInfC{$\Gamma\vdLK \varphi \lor \psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi,\psi \vdLK \Delta$}
      \RightLabel{$l\land$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \AxiomC{$\Theta\vdLK \psi,\Xi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLK \varphi\land\psi,\Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\to\psi\vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\psi,\Delta$}
      \RightLabel{$r\to$}
      \UnaryInfC{$\Gamma\vdLK \varphi\to\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \forall x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi[t/x],\Delta$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \exists x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLK t = t$}
      \DisplayProof
  \end{tabular}%}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LK$ présenté vers le bas avec listes}
  \label{tbl.LK.upward}

  \hrule
\end{table}

Une autre présentation est possible, celle-ci orientée vers le bas, dont
l'objectif est au contraire de favoriser l'écriture d'un arbre dont on
connait déjà la forme au préalable, en particulier les feuilles, pour pouvoir
facilement dériver l'ensemble des formules qui suivent.

L'équivalence entre toutes les présentations de $\LK$ données jusque là tient à
plusieurs éléments~:
\begin{itemize}
\item d'abord, on a des façons canoniques de relier les listes, les
  multi-ensembles finis et les ensembles finis. A l'utilisation de règles
  d'échange près, les arbres par listes et par multi-ensembles sont les mêmes,
  et les arbres par multi-ensembles et par ensembles sont les mêmes à
  l'utilisation de règles de contraction près.
\item on remarque cependant que les
  règles d'échange peuvent mener à des arbres particulièrement longs si les
  règles sont de la forme $\Gamma,\varphi\vdLK\Delta$ plutôt que
  $\Gamma,\varphi,\Gamma'\vdLK\Delta$ par exemple, puisqu'alors il faudrait
  des suites de règles d'échange pour placer la formule impliquée dans la
  règle en tête de la liste de gauche, puis des suites de règles d'échange
  pour replacer la formule à sa place initiale. Il vaut mieux donc considérer
  une version plus lâche des règles dans laquelle on applique les règles sur
  n'importe quelle formule occurrant dans l'une des listes, plutôt que toujours
  la plus proche du symbole $\vdLK$.
\item pour simuler les règles additives à partir des règles multiplicatives,
  il suffit d'enrichir les contextes des prémisses avec des affaiblissements
  jusqu'à avoir le même contexte des deux côtés~:
  \begin{center}
    \resizebox{0.9\textwidth}{!}{$
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_2,\Delta$}
    \AxiomC{$\Theta,\Sigma^l_2\vdLK \Sigma^r_2,\Xi$}
    \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLK \Phi^r,\Delta,\Xi$}
    \DisplayProof
    \quad\reecr{}\quad
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_1,\Delta$}
    \doubleLine
    \RightLabel{$lw/rw$}
    \UnaryInfC{$\Gamma,\Theta,\Sigma^l_1\vdLK\Sigma^r_1\Delta,\Xi$}
    \AxiomC{$\Theta,\Sigma^l_2\vdLK\Sigma^r_2,\Xi$}
    \doubleLine
    \RightLabel{$lw/rw$}
    \UnaryInfC{$\Gamma,\Theta,\Sigma^l_2\vdLK\Sigma^r_2,\Delta,\Xi$}
    \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLK\Phi^r,\Delta,\Xi$}
    \DisplayProof
    $}
  \end{center}
\item pour simuler les règles multiplicatives à partir des règles additives,
  il suffit d'utiliser des règles de contraction pour dédoubler le contexte et
  le répartir uniformément entre les deux prémisses~:
  \begin{center}
    \resizebox{0.9\textwidth}{!}{$
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_2,\Delta$}
    \AxiomC{$\Gamma,\Sigma^l_2\vdLK \Sigma^r_2,\Delta$}
    \BinaryInfC{$\Gamma,\Phi^l\vdLK \Phi^r,\Delta$}
    \DisplayProof
    \quad\reecr{}\quad
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_1,\Delta$}
    \AxiomC{$\Gamma,\Sigma^l_2\vdLK \Sigma^r_2,\Delta$}
    \BinaryInfC{$\Gamma,\Gamma,\Phi^l\vdLK\Phi^r,\Delta,\Delta$}
    \doubleLine
    \RightLabel{$lc/rc$}
    \UnaryInfC{$\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
    \DisplayProof
    $}
  \end{center}
\end{itemize}

On souhaite maintenant prouver le théorème d'élimination des coupures.

\subsection{L'élimination des coupures}

On a déjà vu comment réécrire des arbres en faisant descendre des règles
quantifiantes. Pour l'élimination des coupures, l'objectif sera au contraire de
faire monter les règles $cut$.

Avant de donner la preuve de l'élimination des coupures, on va d'abord
développer le calcul des séquents sur lequel on va effectuer la preuve. On a
déjà vu plusieurs présentations possibles, et chaque présentation demande que
l'on prouve un théorème d'élimination des coupures qui lui est propre. En plus
de cela, si l'on s'intéresse à la version intuitionniste du calcul des
séquents, il faut encore prouver un théorème d'élimination des coupures pour
chaque nouveau calcul introduit.

Comme la preuve est technique, on préfère ménager nos efforts et construire un
calcul suffisamment général en amont, pour que toutes nos présentations soient
des fragments de notre calcul général. Ce calcul, $\LS$, sera constitué des
fragments suivants~:
\begin{itemize}
\item les constructeurs $\parr/\land$ sont la disjonction et la conjonction
  multiplicatives, leurs règles séparent donc les contextes quand on les
  lit du bas vers le haut~;
\item les constructeurs $\lor/\with$ sont la disjonction et la conjonction
  additives, leurs règles copient donc les contextes dans les prémisses,
  quand on les lit du bas vers le haut~;
\item la version multiplicative de l'implication sera notée $\multimap$~;
\item les constructeurs $\diamond/\square$ sont ce qu'on appelle des modalités,
  qu'on présente plus en détaille dans la suite du chapitre, mais qui doivent
  se lire comme des constructeurs unaires de formules évoquant respectivement
  la possibilité d'une formule et sa nécessité. Le choix de la notation
  $\square$ dans la \cref{def.HB.cond} vient directement de cette notion de
  modalité, le prédicat $\Th(\encode{\godcod{\varphi}})$ pouvant se voir
  comme une nécessitation de la vérité de $\varphi$.
\end{itemize}
Le fait d'inclure les constructeurs à la fois additifs et multiplicatifs permet
de déduire de l'élimination des coupures pour $\LS$ la propriété pour les
présentations de $\LK$ données jusqu'alors. Le fait d'ajouter les modalités
nous permet d'introduire plusieurs sous fragments d'intérêt. Enfin, cela nous
permet de mettre l'accent sur le principe suivant
\begin{quote}
  La propriété d'élimination des coupures ne s'intéresse aucunement à la
  sémantique des règles, elle ne dépend que de la façon dont les règles se
  structurent.
\end{quote}
C'est pour cette raison que, par exemple, l'élimination des coupures pour
$\with$ et pour $\land$ sont bien différentes malgré le fait que les deux
connecteurs logiques sont logiquement équivalents.

\begin{table}[t!]
  \centering
  %\hrule
  \resizebox{\textwidth}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\varphi\vdLS \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLS \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLS \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLS \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLS\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi,\psi,\Gamma'\vdLS\Delta$}
      \RightLabel{\textit{le}}
      \UnaryInfC{$\Gamma,\psi,\varphi,\Gamma'\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\Delta,\varphi,\psi,\Delta'$}
      \RightLabel{\textit{re}}
      \UnaryInfC{$\Gamma\vdLS\Delta,\psi,\varphi,\Delta'$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLS \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLS \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLS \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLS \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLS \varphi,\Delta$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLS \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLS \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLS \lnot\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \AxiomC{$\Gamma,\psi\vdLS\Delta$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma,\varphi\lor\psi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \RightLabel{$r\lor_1$}
      \UnaryInfC{$\Gamma\vdLS \varphi\lor\psi,\Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLS\psi,\Delta$}
      \RightLabel{$r\lor_2$}
      \UnaryInfC{$\Gamma\vdLS\varphi\lor\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLS \Delta$}
      \AxiomC{$\Theta, \psi \vdLS \Xi$}
      \RightLabel{$l\parr$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\parr\psi \vdLS \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS \varphi,\psi,\Delta$}
      \RightLabel{$r\parr$}
      \UnaryInfC{$\Gamma\vdLS \varphi \parr \psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi,\psi \vdLS \Delta$}
      \RightLabel{$l\land$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLS \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS \varphi,\Delta$}
      \AxiomC{$\Theta\vdLS \psi,\Xi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLS \varphi\land\psi,\Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$l\with_1$}
      \UnaryInfC{$\Gamma,\varphi\with\psi\vdLS\Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma,\psi\vdLS\Delta$}
      \RightLabel{$l\with_2$}
      \UnaryInfC{$\Gamma,\varphi\with\psi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \AxiomC{$\Gamma,\psi\vdLS\Delta$}
      \RightLabel{$r\with$}
      \BinaryInfC{$\Gamma,\varphi\with\psi\vdLS\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \AxiomC{$\Gamma,\psi\vdLS\Delta$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma,\varphi\to\psi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$r\to_1$}
      \UnaryInfC{$\Gamma\vdLS\varphi\to\psi,\Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLS\psi,\Delta$}
      \RightLabel{$r\to_2$}
      \UnaryInfC{$\Gamma\vdLS\varphi\to\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLS \varphi,\Delta$}
      \AxiomC{$\Theta, \psi \vdLS \Xi$}
      \RightLabel{$l\multimap$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\multimap\psi\vdLS \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLS\psi,\Delta$}
      \RightLabel{$r\multimap$}
      \UnaryInfC{$\Gamma\vdLS \varphi\multimap\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLS\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS \varphi,\Delta$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLS \forall x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLS\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLS \varphi[t/x],\Delta$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLS \exists x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$l\square$}
      \UnaryInfC{$\Gamma,\square\varphi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \RightLabel{$r\square^\ddagger$}
      \UnaryInfC{$\Gamma\vdLS\square\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$l\diamond^\ddagger$}
      \UnaryInfC{$\Gamma,\diamond\varphi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \RightLabel{$r\diamond$}
      \UnaryInfC{$\Gamma\vdLS\diamond\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLS \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLS \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLS t = t$}
      \DisplayProof
  \end{tabular}}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LS$}
  \label{tbl.LS}

  \hrule
\end{table}

\begin{definition}[Calcul des séquents $\LS$]
  On définit le calcul des séquents $\LS$ par les règles de la \cref{tbl.LS},
  en conditionnant les règles marquées d'un $\dagger$ au fait que $x$ est libre
  dans $\Gamma,\Delta$ et en conditionnant les règles marquées d'un
  $\ddagger$ au fait que toutes les formules de $\Gamma$ sont de la forme
  $\square\psi$ et toutes les formules de $\Delta$ sont de la forme
  $\diamond\psi$.
\end{definition}

On a ainsi défini une nouvelle syntaxe. La première chose à faire, pour pouvoir
étudier plus efficacement les règles, est de donner une typologie des règles
présentes. Comme auparavant, on considère $\Sigma^l$ et $\Sigma^r$ les ensembles
des sous-formules des prémisses, et $\Phi^l$ et $\Phi^r$ les ensembles de
formules de la conclusion, pour une règle donnée.

Puisque nous avons des règles additives et multiplicatives, trois types
de règles apparaissent plutôt que deux~:
\begin{itemize}
\item les règles de type $\rOne$ restent inchangées, elles sont de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma,\Sigma^l\vdLS\Sigma^r,\Delta$}
    \RightLabel{$\rOne$}
    \UnaryInfC{$\Gamma,\Phi^l\vdLS\Phi^r,\Delta$}
  \end{prooftree}
\item les règles multiplicatives à deux prémisses sont de type $\rTwo$, et elles
  sont de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma,\Sigma^l_1\vdLS\Sigma^r_1,\Delta$}
    \AxiomC{$\Theta,\Sigma^l_2\vdLS\Sigma^r_2,\Xi$}
    \RightLabel{$\rTwo$}
    \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLS\Phi^r,\Delta,\Xi$}
  \end{prooftree}
\item les règles additives à deux prémisses sont de type $\rTwoB$, et elles sont
  de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma,\Sigma^l_1\vdLS\Sigma^r_1,\Delta$}
    \AxiomC{$\Gamma,\Sigma^l_2\vdLS\Sigma^r_2,\Delta$}
    \RightLabel{$\rTwoB$}
    \BinaryInfC{$\Gamma,\Phi^l\vdLS\Phi^r,\Delta$}
  \end{prooftree}
\end{itemize}
Techniquement, on pourrait considérer que $cut$ est une règle de type $\rTwo$,
mais on va traiter à part la règle $cut$, puisque c'est elle que l'on souhaite
éliminer.

Puisqu'on souhaite déplacer les $cut$ vers le haut, on considère des suites de
règles où une règle quelconque est au-dessus d'une règle $cut$. La situation
est alors très différente suivant la place de la conclusion d'une règle par
rapport à la formule sur laquelle s'effectuer le $cut$. On introduit donc
d'abord une nomenclature pour distinguer cette situation.

\begin{notation}
  Pour faciliter la lecture vis à vis des positions latérales (gauche / droite),
  on réécrit la règle $cut$ en échangeant ses prémisses~:
  \begin{prooftree}
    \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
    \AxiomC{$\Theta\vdLS\varphi,\Xi$}
    \RightLabel{$cut$}
    \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
  \end{prooftree}
\end{notation}

\begin{definition}[Coupure logique, formule de coupure]
  Soit une instance de la règle $cut$. La formule apparaissant dans les deux
  séquents de la prémisse et disparaissant dans la conclusion est appelée la
  formule de coupure.

  Pour une instance $C$ de $cut$ dont la formule de coupure est $\varphi$, on
  dira que $C$ est~:
  \begin{itemize}
  \item $l$-logique si la règle en haut à gauche de $C$ est une règle logique
    qui crée la formule $\varphi$ (c'est donc une règle $l$-logique puisque
    $\varphi$ est à gauche de $\vdLS$)
  \item $r$-logique si la règle en haut à droite de $C$ est une règle logique
    qui crée la formule $\varphi$
  \end{itemize}
  $C$ sera dite logique si elle est à la fois $l$-logique et $r$-logique.
\end{definition}

On peut alors commencer par éliminer les règles logique.

\begin{definition}
  On définit la réécriture des coupures logiques par les règles suivantes~:
  \begin{center}
    \resizebox{\textwidth}{!}{\(
      \begin{array}{ccc}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \RightLabel{$l\lnot$}
        \UnaryInfC{$\Gamma,\lnot\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS \Xi$}
        \RightLabel{$r\lnot$}
        \UnaryInfC{$\Theta\vdLS\lnot\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\lnot} &
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS\Xi$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Theta,\Gamma\vdLS\Xi,\Delta$}
        \doubleLine
        \RightLabel{$le/re$}
        \UnaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_1\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_2\vdLS\Delta$}
        \RightLabel{$l\lor$}
        \BinaryInfC{$\Gamma,\varphi_1\lor\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_i,\Xi$}
        \RightLabel{$r\lor_i$}
        \UnaryInfC{$\Theta\vdLS\varphi_1\lor\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\lor_i} &
        \AxiomC{$\mathlarger{\pi_i}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_i\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_i,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
%      \end{array}
%    \)}
%  \end{center}
%  \begin{center}
%    \resizebox{\textwidth}{!}{\(
        %      \begin{array}{ccc}
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\varphi_1\vdLS\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \RightLabel{$l\parr$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\varphi_1\parr\varphi_2\vdLS
          \Delta_1,\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_1,\varphi_2,\Xi$}
        \RightLabel{$r\parr$}
        \UnaryInfC{$\Theta\vdLS\varphi_1\parr\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        & \reecr{log\parr} &
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\varphi_1\vdLS\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_1,\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_2,\Theta\vdLS\varphi_1,\Delta_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_1,\varphi_2\vdLS\Delta$}
        \RightLabel{$l\land$}
        \UnaryInfC{$\Gamma,\varphi_1\land\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1\vdLS\varphi_1,\Xi_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2\vdLS\varphi_2,\Xi_2$}
        \RightLabel{$r\land$}
        \BinaryInfC{$\Theta_1,\Theta_2\vdLS\varphi_1\land\varphi_2,\Xi_1,\Xi_2$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2\vdLS\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        & \reecr{log\land} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_1,\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1\vdLS\varphi_1,\Xi_1$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\varphi_2\vdLS\Delta,\Xi_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2\vdLS\varphi_2,\Xi_2$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2\vdLS\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_i\vdLS\Delta$}
        \RightLabel{$l\with_i$}
        \UnaryInfC{$\Gamma,\varphi_1\with\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_1\vdLS\Xi$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_2\vdLS\Xi$}
        \RightLabel{$r\with$}
        \BinaryInfC{$\Theta,\varphi_1\with\varphi_2\vdLS\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\with_i} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_i\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_i}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_i\vdLS\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\psi\vdLS\Delta$}
        \RightLabel{$l\to$}
        \BinaryInfC{$\Gamma,\varphi\to\psi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS\Xi$}
        \RightLabel{$r\to_1$}
        \UnaryInfC{$\Theta\vdLS\varphi\to\psi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\to_1} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS\Xi$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\psi\vdLS\Delta$}
        \RightLabel{$l\to$}
        \BinaryInfC{$\Gamma,\varphi\to\psi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\psi,\Xi$}
        \RightLabel{$r\to_2$}
        \UnaryInfC{$\Theta\vdLS\varphi\to\psi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\to_2} &
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\psi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\psi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1\vdLS\varphi_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \RightLabel{$l\multimap$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\varphi\multimap\psi
          \vdLS\Delta_1,\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_1\vdLS\varphi_2,\Xi$}
        \RightLabel{$r\multimap$}
        \UnaryInfC{$\Theta\vdLS\varphi_1\multimap\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        & \reecr{log\multimap} &
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_1\vdLS\varphi_2,\Xi$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1\vdLS\varphi_1,\Delta_1$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Theta,\Gamma_1\vdLS\varphi_2,\Xi,\Delta_1$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_2,\Theta,\Gamma_1\vdLS\Delta_2,\Xi,\Delta_1$}
        \doubleLine
        \RightLabel{$le/re$}
        \UnaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi[t/x]\vdLS\Delta$}
        \RightLabel{$l\forall$}
        \UnaryInfC{$\Gamma,\forall x\,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS \varphi,\Xi$}
        \RightLabel{$r\forall^\dagger$}
        \UnaryInfC{$\Theta\vdLS\forall x\,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\forall} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi[t/x]\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'[t/x]}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi[t/x],\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \RightLabel{$l\exists^\dagger$}
        \UnaryInfC{$\Gamma,\exists x\,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi[t/x],\Xi$}
        \RightLabel{$r\exists$}
        \UnaryInfC{$\Theta\vdLS\exists x\,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\exists} &
        \AxiomC{$\mathlarger{\pi[t/x]}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi[t/x]\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\vdLS\varphi[t/x],\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \RightLabel{$l\square$}
        \UnaryInfC{$\Gamma,\square\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$r\square^\ddagger$}
        \UnaryInfC{$\Theta\vdLS\square\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\square} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \RightLabel{$l\diamond^\ddagger$}
        \UnaryInfC{$\Gamma,\diamond\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$r\diamond$}
        \UnaryInfC{$\Theta\vdLS\diamond\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\diamond} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\Delta$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma,t=t\vdLS\Delta$}
        \AxiomC{}
        \RightLabel{$r=$}
        \UnaryInfC{$\vdLS t = t$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma\vdLS\Delta$}
        \DisplayProof
        & \reecr{log=} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\Delta$}
        \DisplayProof
      \end{array}
    \)}
  \end{center}

  La règle de réécriture $\reecr{log}$ est l'union de toutes les règles
  ci-dessus.
\end{definition}
