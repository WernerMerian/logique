\chapter[Calcul des séquents]{Théorème de complétude méta et
  calcul des séquents}\label{chp.sequents}

\minitoc

\lettrine{D}{ans} le \cref{chp.logpred}, nous avons prouvé le théorème de
complétude pour la déduction naturelle dans le cas de la logique du premier
ordre. La déduction naturelle, comme nous l'avons vu, est une syntaxe de
démonstration permettant de formaliser des étapes élémentaires de raisonnements
sous forme d'un arbre de preuve.

La structure de la preuve du théorème de complétude, du moins de sa partie
technique où l'on construit un modèle d'une théorie cohérente, se décompose
ainsi~:
\begin{itemize}
\item on ajoute des témoins de Henkin à la théorie~;
\item on complète la théorie~;
\item on construit le modèle syntaxique, dont les éléments sont les termes clos
  quotientés par l'égalité prouvable dans la théorie
\item on montre par induction que la théorie complétée prouve une formule si et
  seulement si le modèle syntaxique la satisfait.
\end{itemize}

Ce théorème est donc relativement long et technique à prouver, et notre preuve
ne fonctionne que dans le cas très précis de la déduction naturelle. Est-il
possible de généraliser ce résultat à d'autres syntaxes de preuves ? C'est en
répondant à cette question que nous introduisons une autre syntaxe, celle du
calcul des séquents, que nous étudierons ce chapitre.

Ce chapitre se compose donc d'abord d'une preuve d'un théorème de complétude
\og méta\fg, qui permet de prouver avec quelques conditions qu'une large classe
de syntaxes de preuves sont complètes vis à vis des modèles déjà présentés dans
le \cref{chp.logpred}. Grâce à cette preuve, nous abordons ensuite le calcul des
séquents classique, et son principal théorème~: l'élimination des coupures.

Enfin, nous présentons le calcul des séquents intuitionnistes. Pour cela, nous
préférons prendre un chemin légèrement plus long mais plus riche~: nous étudions
sommairement la logique modale et la sémantique de Kripke qui leur est associé.
Cela nous permet de conclure par un théorème de complétude similaire à celui du
calcul des séquents, mais entre sa version intuitionniste et la classe des
modèles de Kripke.

\section{Du théorème de complétude au calcul des séquents}[Complétude et
  séquents]

Pour commencer notre parcours de la théorie de la démonstration, on s'intéresse
au théorème de complétude. Sous la forme du \cref{thm.completude}, il énonce
qu'un système syntaxique donné coïncide avec la relation $\vDash$ de
conséquence sémantique. Comme ce théorème s'intéresse à la syntaxe, se
démonstration dépend entièrement du système syntaxique considéré. Cependant, on
peut adapter la preuve donnée d'un système à un autre, en cherchant des
conditions plus sémantiques sur les systèmes pour avoir une condition suffisante
à la complétude d'un système. C'est ce que nous nous proposons de faire.

\subsection{Construire un théorème de complétude généralisé}

On veut donc définir un ensemble de conditions sur une relation $\vdash$ de
prouvabilité, représentant un système syntaxique de démonstrations.
Nous nous autorisons à ajouter autant de conditions que nécessaire, mais nous
souhaitons garder un critère essentiel~: chaque condition doit être raisonnable,
au sens où un système nous paraissant refléter ce qu'est une preuve doit
forcément vérifier une telle condition.

Tout d'abord, des conditions dites structurelles s'imposent. On considère que
notre relation $\vdash$ de prouvabilité syntaxique relie une théorie et une
formule, on a donc, pour une signature $\Sigma$ donnée,
$\vdash \subseteq \powerset(\Prop(\Sigma))\times \Formula(\Sigma)$. Dire qu'une
théorie $\mathcal T$ prouve une formule $\varphi$ demande qu'on écrive
effectivement une preuve, ce qui signifie qu'on doit avoir un ensemble, qu'on
notera $\Proof{\mathcal T}(\Sigma)$, de preuves. Cet ensemble est muni d'une
relation donnant les hypothèses d'une preuves et sa conclusion, c'est-à-dire une
relation $\concl \subseteq \powerfin(\Formula(\Sigma))\times \Formula(\Sigma)$
de telle sorte qu'on puisse écrire
\[\forall \mathcal T, \varphi, \mathcal T \vdash \varphi \iff
\exists \pi \in \Proof{\mathcal T}(\Sigma), \pi \concl (\Gamma,\varphi) \land
\Gamma\subseteq\mathcal T\]
Remarquons ici qu'on choisit de considérer pour nos hypothèses un
ensemble fini de formules. Le fait de choisir un ensemble fini est poussé par
le fait qu'une preuve est toujours considérée comme un objet finitaire~: écrire
une démonstration repose sur un nombre fini de symboles. Le fait de considérer
des formules et non seulement des propositions permet de considérer des preuves
qui utilisent des formules non closes comme hypothèses.

Nous voyons donc plusieurs conditions apparaître grâce à cette structure.
Tout d'abord, cela force la propriété d'affaiblissement~:
\[
(\textit{Aff})\quad : \quad \forall \mathcal T,\mathcal T', \varphi,
(\mathcal T \vdash \varphi) \land (\mathcal T \subseteq \mathcal T') \implies
\mathcal T' \vdash \varphi
\]
ainsi que la propriété de compacité~:
\[
(\textit{Comp})\quad : \quad \forall \mathcal T, \varphi,
\mathcal T \vdash \varphi \implies \exists F \subfin \mathcal T,
F\vdash \varphi
\]

Au niveau structurel, il est aussi attendu d'une démonstration qu'elle permette
de faire deux choses considérées évidentes~: une démonstration peut utiliser une
hypothèse pour en faire sa conclusion, et une démonstration peut utiliser un
lemme. Ces deux principes de raisonnement élémentaires se traduisent par deux
conditions, l'axiome~:
\[
(\textit{Ax})\quad : \quad \forall \mathcal T, \varphi, \varphi \in \mathcal T
\implies \mathcal T \vdash \varphi
\]
et la coupure~:
\[
(\textit{Cut})\quad : \quad \forall \mathcal T, \varphi, \psi,
(\mathcal T \vdash \varphi) \land (\mathcal T \cup \{\varphi\}\vdash \psi)
\implies \mathcal T \vdash \psi
\]

On ajoute aussi une condition liée au fait qu'on travaille en logique
classique~: on admet le tiers exclu, ou plutôt ici une version équivalente
qu'est le raisonnement par l'absurde. Pour faciliter l'écriture de cette
condition, on définit deux nouvelles notations~: on notera $\mathcal T \vdash$
pour dire que $\mathcal T$ peut prouver une formule $\varphi$ et son contraire
$\lnot\varphi$, et on notera $\mathcal T\nvdash$ pour dire que ce n'est pas le
cas (ce qui correspond au fait que $\mathcal T$ est cohérente). On peut alors
formuler le raisonnement par l'absurde ainsi~:
\[
(\textit{Raa})\quad : \quad \forall \mathcal T, \varphi,
(\mathcal T\cup\{\lnot \varphi\}\vdash) \implies \mathcal T \vdash \varphi
\]

Avec ces conditions, toutes largement raisonnables pour considérer une notion de
prouvabilité entre une théorie et une formule, on peut déjà remarquer deux
éléments~:
\begin{itemize}
\item avec $(\textit{Raa})$, prouver que $\vDash\subseteq \vdash$ ne demande que
  de prouver que pour toute théorie $\mathcal T$, si $\mathcal T\nvdash$ alors
  il existe un modèle de $\mathcal T$. Cela revient au
  \cref{lem.vDashvdashabs} que nous avons vu avant.
\item sans reconstruire l'algèbre de Lindenbaum-Tarski pour la
  relation syntaxique, le fait d'avoir $(\textit{Aff})$ et $(\textit{Comp})$
  nous permet d'utiliser le lemme de Zorn pour étendre toute théorie en une
  théorie cohérente maximale pour $\vdash$, vu comme un pré-ordre grâce aux
  conditions $(\textit{Ax})$ et $(\textit{Cut})$ qui assurent respectivement
  la réflexivité et la transitivité de la relation.
\end{itemize}

Grâce à ces quatre conditions structurelles, on cherche maintenant des
conditions pour assurer que la construction effectuée dans le \cref{chp.logpred}
fonctionne encore. On souhaite donc construire le modèle syntaxique. Pour cela,
on a besoin de quotienter l'ensemble des termes clos par la relation
\[t \sim u \defeq \mathcal T \vdash t = u\]
Mais il faut donc vérifier que cette relation est à la fois une relation
d'équivalence, et une congruence pour les symboles de fonction et de relation.

On a déjà vu que deux règles suffisaient pour ça, qui sont la réflexivité~:
\[(\textit{r}=)\quad : \quad \forall \mathcal T, t, \mathcal T \vdash t = t\]
et la loi de Leibniz~:
\[(\textit{l}=)\quad : \quad \forall \mathcal T, t, u, \varphi,
(\mathcal T \vdash \varphi[u/x]) \implies
\mathcal T \cup\{ t = u \} \vdash \varphi[t/x]
\]

On peut donc construire notre modèle syntaxique. L'étape suivante est de prouver
par induction sur les formules que, en notant notre modèle syntaxique
$\mathcal M$ et notre théorie maximale $\mathcal T$, pour tout environnement
d'interprétation des variables du premier ordre $\rho$ et toute formule
$\varphi$ dont les variables libres sont dans le domaine de $\rho$, on a
\[\mathcal M, \rho \models \varphi \iff \mathcal T \vdash \rho(\varphi)\]
Sans s'attarder sur les substitutions de variables et en passant les cas
atomiques (le cas de $\top$ est automatique, le cas de $\bot$ est dû au fait
que la théorie $\mathcal T$ est cohérente, et les autres formules atomiques sont
données par définition de l'interprétation des relations), l'induction nous
donne~:
\[\begin{array}{ccccc}
\mathcal M \models \lnot \varphi 
& \overset{\textit{ind. hyp.}}{\iff} &
\mathcal T \nvdash \varphi & \overset{\text{?}}{\iff} &
\mathcal T \vdash \lnot\varphi \\
\mathcal M \models \varphi\land \psi
& \overset{\textit{ind. hyp.}}{\iff} &
(\mathcal T \vdash \varphi) \land (\mathcal T \vdash \psi)&
\overset{\text{?}}{\iff} &
\mathcal T \vdash \varphi \land \psi \\
\mathcal M \models \varphi\lor \psi
& \overset{\textit{ind. hyp.}}{\iff} &
(\mathcal T \vdash \varphi) \lor (\mathcal T \vdash \psi)&
\overset{\text{?}}{\iff} &
\mathcal T \vdash \varphi \lor \psi \\
\mathcal M \models \varphi\to \psi
& \overset{\textit{ind. hyp.}}{\iff} &
(\mathcal T \nvdash \varphi) \lor (\mathcal T \vdash \psi)&
\overset{\text{?}}{\iff} &
\mathcal T \vdash \varphi \lor \psi \\
\mathcal M \models \forall x, \varphi
& \overset{\textit{ind. hyp.}}{\iff} &
\forall m \in |\mathcal M |, \mathcal T \vdash \varphi[t/x]
& \overset{\text{?}}{\iff} &
\mathcal T \vdash \forall x, \varphi \\
\mathcal M \models \exists x, \varphi
& \overset{\textit{ind. hyp.}}{\iff} &
\exists m \in |\mathcal M |, \mathcal T \vdash \varphi[t/x]
& \overset{\text{?}}{\iff} &
\mathcal T \vdash \exists x, \varphi \\
\end{array}\]

On a ainsi une liste de nouvelles conditions à satisfaire pour assurer que
l'induction fonctionne. En séparant les équivalences en deux implications, et
en prenant la contraposée pour l'une des deux implications, on
obtient (en notant $\mathcal T, \varphi$ pour $\mathcal T \cup \{\varphi\}$)~:
\[\begin{array}{ccccc}
(l\lnot) & : & \mathcal T \vdash \varphi & \implies &
\mathcal T, \lnot \varphi \vdash \\
(r\lnot) & : & \mathcal T, \varphi \vdash & \implies &
\mathcal T \vdash \lnot \varphi \\
(l\land) & : & (\mathcal T, \varphi \vdash) \lor
(\mathcal T, \psi \vdash)
& \implies & \mathcal T, \varphi \land \psi\vdash \\
(r\land) & : & (\mathcal T \vdash \varphi) \land (\mathcal T \vdash \psi)
& \implies & \mathcal T \vdash \varphi \land \psi \\
(l\lor) & : & (\mathcal T, \varphi \vdash) \land (\mathcal T, \psi \vdash)
& \implies & \mathcal T, \varphi \lor \psi \vdash \\
(r\lor) & : & (\mathcal T \vdash \varphi) \lor (\mathcal T \vdash \psi)
& \implies & \mathcal T \vdash \varphi \lor \psi \\
(l\to) & : & (\mathcal T \vdash \varphi) \land (\mathcal T, \psi \vdash)
& \implies & \mathcal T, \varphi \to \psi \vdash \\
(r\to) & : & (\mathcal T,\varphi \vdash) \lor (\mathcal T \vdash \psi)
& \implies & \mathcal T \vdash \varphi \to \psi \\
(l\forall) & : & (\exists t \in |\mathcal M |, \mathcal T, \varphi[t/x] \vdash)
& \implies & \mathcal T, \forall x, \varphi \vdash \\
(r\forall) & : & (\forall t \in |\mathcal M |, \mathcal T \vdash \varphi [t/x])
& \overset{\text{?}}{\implies} & \mathcal T \vdash \forall x, \varphi \\
(l\exists) & : & (\forall t \in |\mathcal M |, \mathcal T, \varphi[t/x] \vdash)
& \overset{\text{?}}{\implies} & \mathcal T, \exists x, \varphi \vdash \\
(r\exists) & : & (\exists t \in |\mathcal M |, \mathcal T \vdash \varphi[t/x])
& \implies & \mathcal T \vdash \exists x, \varphi
\end{array}\]

Toutes ces conditions, à l'exceptions de deux marquées par un
$\overset{\text{?}}{\implies}$, sont des conditions parfaitement raisonnables à
attendre d'un système syntaxique de démonstration. Les deux autres conditions,
en revanche, n'ont pas de raison d'être vérifiées~: une implication telle que
$\forall t \in |\mathcal T|, \mathcal T \vdash \varphi[t/x] \implies \mathcal T
\vdash \forall x, \varphi$
signifie en particulier que tout objet du premier ordre est représenté par un
terme clos. On peut facilement se convaincre que ça n'est pas le cas en prenant
le langage et la théorie des groupes~: pour un certain groupe fixé, disons le
groupe $\mathbb Z$, seul $0$ peut s'écrire comme un terme clos.

On modifie donc les deux conditions $(r\forall)$ et $(l\exists)$ en demandant,
non pas que la prémisse soit vérifiée en quantifiant sur les termes clos,
mais qu'elle soit vérifiée en prenant une constante $c$ n'apparaissant pas dans
$\varphi$ ni dans $\mathcal T$~:
\[\begin{array}{ccccc}
(r\forall)^\dagger & : & \forall c \notin \Const(\mathcal T, \varphi),
\mathcal T \vdash \varphi[c/x]
& \implies & \mathcal T \vdash \forall x, \varphi \\
(l\exists)^\dagger & : & \forall c \notin \Const(\mathcal T, \varphi),
\mathcal T, \varphi[c/x]\vdash
& \implies & \mathcal T, \exists x, \varphi \vdash
\end{array}\]
Ces deux conditions sont, elles, raisonnables, puisqu'elles correspondent à une
généralisation sur une constante indépendante du contexte. Cependant, elles ne
suffisent pas à assurer l'implication initiale. Nous utilisons donc la
construction des témoins de Henkin. Dans le cas présent, comme le système
syntaxique n'est pas défini et qu'on ne connait que quelques unes de ses
propriétés, on préfère ajouter des témoins de façon plus parcimonieuse.

En effet, on considère maintenant les formules $\varphi$ à une variable libre
telle que $\exists x, \varphi$ appartient à $\mathcal T$ (ou est prouvable dans
$\mathcal T$, comme $\mathcal T$ est choisie maximale), on ajoute seulement
une constante $c_{\exists x, \varphi}$ dans ce cas, et la théorie $\mathcal T'$
enrichie est alors augmentée seulement de l'axiome
$\varphi[c_{\exists x, \varphi}/x]$.

On peut alors itérer cette construction pour, à partir de la théorie
$\mathcal T$, construire une théorie $\hclose{\mathcal T}$ qui possède la
propriété des témoins de Henkin, c'est-à-dire telle que pour toute formule
$\varphi$ à une variable libre telle que $\exists x, \varphi$ est prouvable
dans $\hclose{\mathcal T}$, il existe une constante $c$ telle que
$\varphi[c/x]$ est prouvable dans $\hclose{\mathcal T}$.

Il se pose alors un nouveau problème. Lorsque nous construisons la version à
la fois complète et possédant les témoins de Henkin de notre théorie initiale,
dans le \cref{chp.logpred}, nous utilisons le \cref{prop.henkin.ext} pour,
depuis le complété de la clôture par témoins de Henkin, avoir une théorie
possédant les deux propriétés. Dans le cas présent, cette propriété n'a pas de
raison d'être vérifiée~: augmenter par maximalité notre théorie
$\hclose{\mathcal T}$ dans le nouveau langage nous fait perdre la propriété des
témoins de Henkin, et ajouter des témoins de Henkin nous fait perdre la
maximalité de la théorie.

On décide donc de créer une suite de théorie et de langages (on ne précisera pas
les langages) $\mathcal T_n$ où $\mathcal T_{2n+1}$ est l'extension par témoins
de Henkin de $\mathcal T_{2n}$, et $\mathcal T_{2n+2}$ est l'extension par
maximalité de $\mathcal T_{2n+1}$. En prenant alors l'union de toutes ces
théories, qu'on notera $\mathcal T'$ ici, on sait que~:
\begin{itemize}
\item si $\exists x, \varphi$ appartient à $\mathcal T'$, alors elle appartient
  à une certaine théorie $\mathcal T_n$, et on trouve donc une constante
  $c_{\varphi}$ telle que $\varphi[c_{\varphi}/x] \in \mathcal T_{n+2}$, donc
  $\mathcal T'$ possède la propriété des témoins de Henkin~;
\item soit $\varphi$ une formule close, exprimée dans le langage de
  $\mathcal T'$. Comme $\varphi$ est un objet fini, ses symboles appartiennent
  tous à un certain langage $\Sigma_n$ (en notant $\Sigma_n$ la suite de
  langages lors de la construction des $\mathcal T_n$). On sait alors que,
  $\mathcal T_{2n+2}$ contenant l'extension maximale d'une théorie sur
  $\Sigma_n$, soit $\varphi$ soit $\lnot\varphi$ y appartient. L'extension est
  donc maximale.
\end{itemize}

Avec tous ces éléments, il est maintenant possible de généraliser l'énoncé du
\cref{thm.completude}.

\begin{theorem}[Théorème de complétude généralisé]\label{thm.completude.gen}
  Soit une relation $\vdash$ vérifiant les règles suivantes~:
  \[\begin{array}{ccc}
  \AxiomC{$\varphi \in \mathcal T$}
  \RightLabel{(\textit{Ax})}
  \UnaryInfC{$\mathcal T \vdash \varphi$}
  \DisplayProof
  & \qquad &
  \AxiomC{$\mathcal T \vdash \varphi$}
  \AxiomC{$\mathcal T, \varphi \vdash \psi$}
  \RightLabel{(\textit{Cut})}
  \BinaryInfC{$\mathcal T \vdash \psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T \vdash \varphi$}
  \AxiomC{$\mathcal T \subseteq \mathcal T'$}
  \RightLabel{(\textit{Aff})}
  \BinaryInfC{$\mathcal T' \vdash \varphi$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T \vdash \varphi$}
  \RightLabel{(\textit{Comp})}
  \UnaryInfC{$\exists F \subfin \mathcal T, F\vdash \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T\vdash \varphi$}
  \RightLabel{$(l\lnot)$}
  \UnaryInfC{$\mathcal T, \lnot\varphi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \RightLabel{$(r\lnot)$}
  \UnaryInfC{$\mathcal T\vdash \lnot \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \AxiomC{$\mathcal T, \psi \vdash$}
  \RightLabel{$(l\lor)$}
  \BinaryInfC{$\mathcal T, \varphi\lor\psi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T \vdash \varphi$}
  \RightLabel{$(r\lor_1)$}
  \UnaryInfC{$\mathcal T\vdash \varphi\lor\psi$}
  \DisplayProof
  \quad
  \AxiomC{$\mathcal T \vdash \psi$}
  \RightLabel{$(r\lor_2)$}
  \UnaryInfC{$\mathcal T\vdash \varphi \lor \psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \RightLabel{$(l\land_1)$}
  \UnaryInfC{$\mathcal T,\varphi\land\psi\vdash$}
  \DisplayProof
  \quad
  \AxiomC{$\mathcal T, \psi \vdash$}
  \RightLabel{$(l\land_2)$}
  \UnaryInfC{$\mathcal T,\varphi \land \psi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T\vdash \varphi$}
  \AxiomC{$\mathcal T \vdash \psi$}
  \RightLabel{$(r\land)$}
  \BinaryInfC{$\mathcal T\vdash \varphi\land\psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T \vdash \varphi$}
  \AxiomC{$\mathcal T, \psi \vdash$}
  \RightLabel{$(l\to)$}
  \BinaryInfC{$\mathcal T, \varphi\to\psi\vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T, \varphi \vdash$}
  \RightLabel{$(r\to_1)$}
  \UnaryInfC{$\mathcal T\vdash \varphi\to\psi$}
  \DisplayProof
  \quad
  \AxiomC{$\mathcal T \vdash \psi$}
  \RightLabel{$(r\to_2)$}
  \UnaryInfC{$\mathcal T\vdash \varphi \to \psi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T, \varphi[t/x] \vdash$}
  \RightLabel{$(l\forall)$}
  \UnaryInfC{$\mathcal T, \forall x, \varphi \vdash$}
  \DisplayProof
  & &
  \AxiomC{$c \notin \Const(\mathcal T, \varphi)$}
  \AxiomC{$\mathcal T \vdash \varphi[c/x]$}
  \RightLabel{$(r\forall)^\dagger$}
  \BinaryInfC{$\mathcal T \vdash \forall x, \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$c \notin \Const(\mathcal T, \varphi)$}
  \AxiomC{$\mathcal T, \varphi[c/x] \vdash$}
  \RightLabel{$(l\exists)^\dagger$}
  \BinaryInfC{$\mathcal T, \exists x, \varphi \vdash$}
  \DisplayProof
  & &
  \AxiomC{$\mathcal T \vdash \varphi[t/x]$}
  \RightLabel{$(r\exists)$}
  \UnaryInfC{$\mathcal T \vdash \exists x, \varphi$}
  \DisplayProof
  \\
  \\
  \AxiomC{$\mathcal T \vdash \varphi[u / x]$}
  \RightLabel{$(l=)$}
  \UnaryInfC{$\mathcal T, t = u \vdash \varphi[t / x]$}
  \DisplayProof
  & &
  \AxiomC{}
  \RightLabel{$(r=)$}
  \UnaryInfC{$\mathcal T \vdash t = t$}
  \DisplayProof
  \end{array}\]
  \[
  \AxiomC{$\mathcal T, \lnot\varphi \vdash$}
  \RightLabel{(\textit{Raa})}
  \UnaryInfC{$\mathcal T \vdash \varphi$}
  \DisplayProof\]
  Alors on a l'inclusion $\vDash \subseteq \vdash$.
\end{theorem}

\begin{remark}
  Le fait que les règles $l\exists$ et $r\forall$ utilisent des constantes
  n'apparaissant ni dans $\mathcal T$, ni dans $\varphi$, impose que notre
  relation $\vdash$ est définie uniformément sur toutes les signatures.
  Cependant, on peut aussi ajouter une règle tout aussi raisonnable que les
  précédentes, qui est celle qu'on peut tirer du \cref{lem.var.const}. La
  règle
  \[
  \AxiomC{$c \notin \Const(\mathcal T, \varphi)$}
  \AxiomC{$x \notin \VL(\mathcal T)$}
  \AxiomC{$\mathcal T \vdash \varphi$}
  \TrinaryInfC{$\mathcal T \vdash \varphi[c/x]$}
  \DisplayProof
  \]
  ainsi construite permet de remplacer la condition de
  $c\notin \Const(\mathcal T, \varphi)$ par la règle plus simple
  $x\notin \VL(\mathcal T)$. Comme la quantification lie la variable $x$, on
  remarque aussi qu'il n'est pas nécessaire de demander que $x$ soit libre
  dans $\varphi$, et de substituer $x$ par une autre variable~: on peut
  directement travailler comme on le faisait dans le \cref{chp.logpred}.
\end{remark}

Il nous est donc possible, désormais, de prouver des théorèmes de complétude
bien plus facilement, en montrant simplement la validité d'un ensemble de
conditions. On remarque en fait que toutes ces conditions peuvent déjà donner
lieu à un premier système syntaxique. A la place de considérer une théorie
$\mathcal T$, on considère des séquents de la forme $\Gamma \vdash [\varphi]$
où $[\varphi]$ signifie que la conclusion est soit vide (dans le cas d'une
contradiction), soit la formule $\varphi$, et la relation $\vdash$ donnée par
les conditions modulo cette réécriture est déjà un système syntaxique de
démonstration complet vis à vis de $\vDash$. Il est possible de prouver qu'il
est correct, par un argument similaire au \cref{thm.correction}.

Cependant, plusieurs éléments méritent d'être relevés~:
\begin{itemize}
\item en supprimant simplement la règle $(Raa)$ du système, on obtient un
  système syntaxique intuitionniste, puisque l'affaiblissement permet à partir
  de $\mathcal T \vdash$, de déduire $\mathcal T \vdash \varphi$ pour n'importe
  quelle formule $\varphi$~;
\item il est donc possible d'avoir une théorie intuitionniste, mais le théorème
  de complétude ne s'y applique alors plus, car ce qui nous permet de passer de
  la construction d'un modèle à l'inclusion $\vDash\subseteq\vdash$ est le fait
  que, si $\mathcal T \cup\{\lnot\varphi\}$ n'a pas de modèle, alors
  $\mathcal T, \lnot\varphi\vdash$, donc que
  $\mathcal T \vdash \lnot\lnot\varphi$ sans la règle de raisonnement par
  l'absurde~;
\item une symétrie peut s'observer entre les règles droites et les règles
  gauches~: les règles $\lnot$ permettent de changer de côté du $\vdash$ en
  ajoutant un $\lnot$, les règles $\lor$ et $\land$ sont exactement identiques
  modulo une inversion des positions, et la même chose peut être dite pour les
  règles $\exists$ et $\forall$. Ces couples $\lor/\land$ et $\exists/\forall$
  sont ce qu'on appelle des duaux de De Morgan, c'est-à-dire qu'on a par exemple
  $\varphi \lor \psi \equiv \lnot (\lnot \varphi \land \lnot \psi)$~;
\item contrairement au \cref{chp.logpred}, les règles $(r\forall)^\dagger$ et
  $(l\exists)^\dagger$ utilisent des symboles de constantes, ce qui permet en
  fait avant tout de faciliter la preuve que nous avons donnée du théorème de
  complétude~: cela nous évite d'ajouter le théorème de simulation d'une
  constante par une variable, mais ce théorème est généralement vérifié pour
  un système syntaxique raisonnable, et on prendra donc généralement plutôt
  cette version~;
\item à l'exception des règles sur l'égalité, qui ont un statut particulier du
  fait que l'égalité n'est pas un symbole logique aussi simple à étudier que les
  autres, et de la règle $(Raa)$, toutes les autres règles ont la propriété dite
  de la sous-formule~: les séquents en haut d'une règle sont constitués de
  sous-formules du séquent en bas de la règle. C'est en fait un critère central
  pour considérer qu'un formalisme est un calcul des séquents, comme nous le
  verrons~;
\item le fait que notre théorème prouve la complétude en supposant la compacité
  du système indique que le théorème de compacité est lui-même vérifié. Il
  serait possible, au contraire, de démontrer d'abord le théorème de compacité,
  puis de construire une preuve de complétude n'utilisant que des jugements
  du type $\Gamma\vdash \varphi$, où $\Gamma$ est fini, mais la démonstration
  actuelle est plus puissante puisqu'elle donne bel et bien les deux faits à
  la fois. On peut donc décomposer la complétude de la façon suivante~:
  \begin{quote}
    Compacité $+$ Complétude faible $=$ Complétude forte
  \end{quote}
  où, dans le \cref{thm.completude.gen}, on prouve la complétude forte
  directement.
\end{itemize}

Nous avons donc deux options, que nous allons explorer au fil de ce chapitres~:
créer des séquents symétriques, ou travailler dans un système intuitionniste.

\subsection{Calcul des séquents LK}

La recherche d'un théorème de complétude plus général nous a en fait poussé vers
un nouveau formalisme~: en considérant les conditions du
\cref{thm.completude.gen}, on peut remplacer les séquents de la forme
$\mathcal T \vdash \varphi$ par des séquents de la forme $\Gamma \vdash \varphi$
où $\Gamma$ est un ensemble fini de formules, pour obtenir un système
syntaxique (finitaire). Compte tenu des nombreuses symétries entre le côté
gauche et le côté droit du $\vdash$ dans les règles, il est alors naturel de
vouloir construire des séquents de la forme $\Gamma\vdash \Delta$, où
$\Delta$ est aussi un ensemble fini de formules. S'il est assez clair que
$\Gamma$, dans le séquent $\Gamma\vdash \Delta$, se lit comme une conjonction
(on lit le séquent \og en supposant vraies toutes les formules de $\Gamma$\fg,
c'est-à-dire qu'on suppose la conjonction de toutes les formules), le dual
naturel est alors une disjonction sur $\Delta$~: ainsi le séquent
$\Gamma\vdash \Delta$ s'interprète comme l'énoncé \og en supposant vraies toutes
les formules de $\Gamma$, une au moins des formules de $\Delta$ est vraie\fg.
Naturellement, le cas où $\Gamma$ est vide donne alors une conclusion toujours
valide, et le cas où $\Delta$ est vide donne alors une contradiction des
hypothèses, les deux pouvant donc se réécrire respectivement comme
$\top \vdash \Delta$ et $\Gamma\vdash \bot$.

On peut maintenant définir notre premier calcul des séquents, $\LK$.

\begin{table}[t]
  \centering
  %\hrule
  \resizebox{\textwidth}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\Gamma, \varphi\vdLK \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \Delta, \varphi$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \lnot\varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\lor\psi \vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \RightLabel{$r\lor_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\lor\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLK \Delta,\psi$}
      \RightLabel{$r\lor_2$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi \lor \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \RightLabel{$l\land_1$}
      \UnaryInfC{$\Gamma,\varphi\land\psi\vdLK \Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma, \psi \vdLK \Delta$}
      \RightLabel{$l\land_2$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \AxiomC{$\Theta\vdLK \Xi,\psi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi, \varphi\land\psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\to\psi\vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$r\to_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\to\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma \vdLK \Delta,\psi$}
      \RightLabel{$r\to_2$}
      \UnaryInfC{$\Gamma\vdLK\Delta, \varphi \to \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\forall x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi[t/x]$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\exists x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLK t = t$}
      \DisplayProof
  \end{tabular}}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles du calcul des séquents $\LK$}
  \label{tbl.LK}
  \hrule
\end{table}

\begin{definition}[Calcul des séquents $\LK$ \cite{Gentzen1935}]
  Soit $\Sigma$ une signature du premier ordre. On définit inductivement
  l'ensemble $\ProofLK(\Sigma)$ par les règles de la \cref{tbl.LK}, où les
  règles $l\exists^\dagger$ et $r\forall^\dagger$ demandent que $x$ soit libre
  dans $\Gamma$ et $\Delta$. Le séquent le plus en bas d'un arbre
  $\pi\in\ProofLK(\Sigma)$ est appelé le séquent conclusion, et on note
  $\pi \concl \Gamma\vdLK\Delta$ pour signifier que $\Gamma\vdLK\Delta$ est
  la conclusion de $\pi$. On définit la relation de prouvabilité pour $\LK$
  par
  \[\Gamma\vdLK \Delta \defeq \exists \pi \in \ProofLK(\Sigma),
  \pi\concl \Gamma\vdLK\Delta\]
\end{definition}

\begin{remark}
  Dans notre formulation actuelle, les règles sont dites multiplicatives, ce
  qui signifie que les contextes s'accumulent au fil des utilisations de
  règles. Une autre version est la version additive, dans laquelle les contextes
  restent les mêmes. Par exemple, la version additive de $l\to$ est
  \begin{prooftree}
    \AxiomC{$\Gamma\vdLK \Delta, \varphi$}
    \AxiomC{$\Gamma, \psi \vdLK \Delta$}
    \RightLabel{$l\to$}
    \BinaryInfC{$\Gamma, \varphi \to \psi \vdLK \Delta$}
  \end{prooftree}
  En l'état, puisqu'on travaille avec le weakening et des ensembles de formules
  (où ni l'ordre ni le nombre d'occurrences des formules n'importe), les deux
  règles sont dérivables l'une à partir de l'autre. Les versions additives et
  multiplicatives sont donc équivalentes du point de vue logique, mais elles
  peuvent avoir un impact sur de la recherche de preuve, ou dans des logiques
  sous-structurelles comme la logique linéaire que nous aborderons plus tard.

  Nous choisissons une présentation multiplicative ici car le
  \cref{thm.completude.gen} induit naturellement une accumulation de contextes,
  en considérant
  \[\mathcal T \vdLK \varphi \defeq
  \exists \Gamma \subfin \mathcal T, \Gamma\vdLK \varphi\]
  En effet, les prémisses d'une règle telle que $l\to$ sont alors qu'il
  existe $\Gamma\subfin \mathcal T$ tel que $\Gamma\vdLK\varphi$ et qu'il
  existe $\Delta \subfin \mathcal T$ tel que $\Delta\vdLK\psi$, mais les
  deux contextes $\Gamma$ et $\Delta$ ne sont pas \latinexpr{a priori} les
  mêmes.
\end{remark}

\begin{remark}
  Contrairement au \cref{chp.logpred} ou au théorème de complétude, on définit
  l'ensemble des arbres de preuves pour définir ensuite la relation de
  prouvabilité. Cette approche se justifie par notre besoin de réécrire les
  arbres de preuves, et plus généralement d'étudier les arbres comme objet
  mathématiques et non simplement comme des relations.
\end{remark}

Le système $\LK$ est précisément conçu pour vérifier le
\cref{thm.completude.gen}, il est donc complet (et correct par une induction
sans difficulté).

\begin{proposition}
  Pour toute théorie $\mathcal T \subseteq \Formula(\Sigma)$ sur une signature
  $\Sigma$ fixée, la relation $\vdLK$ définie par
  \[\mathcal T \vdLK \varphi \defeq \exists \Gamma \in \powerfin(\mathcal T),
  \Gamma \vdLK \varphi\]
  coïncide avec la relation $\vDash$.
\end{proposition}

\begin{proof}
  L'induction pour prouver la correction de $\vdLK$ est très similaire à celle
  du \cref{thm.cor.logprop}, et nous ne la détaillons pas. Pour la complétude,
  il suffit de vérifier les règles~: la plupart se vérifient automatiquement
  de par la forme des règles de $\vdLK$, mais la règle $(Raa)$ n'a pas de
  règle correspondante dans $\vdLK$. On prouve donc qu'elle est malgré tout
  dérivable~:
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{$ax$}
    \UnaryInfC{$\varphi\vdLK\varphi$}
    \RightLabel{$r\lnot$}
    \UnaryInfC{$\vdLK\varphi,\lnot\varphi$}
    \AxiomC{$\Gamma,\lnot \varphi \vdLK$}
    \RightLabel{$cut$}
    \BinaryInfC{$\Gamma\vdLK\varphi$}
  \end{prooftree}
  On déduit donc que $\mathcal T \vDash \varphi \iff \mathcal T\vdLK \varphi$.
\end{proof}

La règle $cut$, outre son utilisation dans la preuve précédente, est un outil
central de démonstration. C'est grâce à cette règle qu'on a la possibilité,
en écrivant une preuve, de rajouter un résultat intermédiaire~: la règle permet
de faire le lien entre une hypothèse et une conclusion, en montrant que pour
deux séquents $\Gamma,\varphi\vdLK\Delta$ et $\Theta\vdLK\varphi,\Xi$, on peut
supprimer les deux occurrences de $\varphi$ et concaténer les contextes, pour
avoir $\Gamma,\Theta\vdLK\Delta,\Xi$.

La propriété centrale du calcul des séquents, qui a motivé l'étude de ce système
et qui date d'aussi loin que son introduction dans \cite{Gentzen1935}, est
l'élimination des coupures~: on peut en fait prouver que la relation $\vdLK$
prouve les mêmes formules si on supprime la règle $cut$. Autrement dit,
$cut$ est une règle admissible pour $\LK - cut$. On va prouver ce théorème, mais
on se propose d'abord d'explorer les conséquences de ce théorème, pour
comprendre son importance qui lui donne son nom de \foreignexpr{Hauptsatz}
(théorème principal, en allemand) dans l'article original.

On se donne donc pour l'instant l'élimination des coupures en tant qu'axiome.

\begin{axiom}[\'Elimination des coupures]\label{ax.cut.elim}
  Pour tout arbre de preuve $\pi$ de conclusion $\Gamma\vdLK \varphi$, il
  existe un arbre de preuve $\pi'$ de même conclusion mais ne contenant aucune
  occurrence de la règle $cut$.
\end{axiom}

La première conséquence est l'une des plus importantes pour justifier le bon
fonctionnement d'un système syntaxique~: la cohérence de $\LK$.

\begin{theorem}[Cohérence de $\LK$]
  Il est impossible de prouver le séquent $\vdLK$, ou de façon équivalente de
  prouver $\top\vdLK\bot$.
\end{theorem}

\begin{proof}
  On suppose qu'il existe une preuve de $\vdLK$. On trouve donc $\pi$ dont la
  conclusion est le séquent $\vdLK$, et par élimination des coupures on
  suppose que $\pi$ ne contient aucune règle $cut$. On voit alors que toutes
  les règles ont au moins une formule dans leur séquent conclusion. Il est
  donc impossible d'avoir une telle preuve sans coupure, et donc d'avoir une
  preuve de $\vdLK$. Le séquent $\top\vdLK\bot$ ne peut être obtenu que par
  affaiblissement depuis le séquent $\vdLK$, d'où le résultat.
\end{proof}

Ainsi, on ne peut pas tout prouver dans $\LK$. Ce résultat peut être directement
obtenu comme une conséquence du théorème de correction, puisque tout énoncé
prouvé dans $\LK$ doit être vrai aussi dans les modèles du séquent considéré.
La différence est qu'ici, le théorème nécessite uniquement l'utilisation de
l'élimination des coupures. Quand on prouvera l'élimination des coupures, on
verra que le procédé de transformation d'arbre est entièrement algorithmique,
et peut ainsi de définir de façon finitaire. La preuve de cohérence qui en
résultat est donc plus robuste que celle utilisant le théorème de correction,
dans laquelle on a besoin de quantifier nos résultats sur la classe de toutes
les structures, donnant lieu à une preuve bien plus infinitaire dans l'esprit.

La preuve de la cohérence de $\LK$ repose donc sur l'élimination des coupures et
sur une analyse des règles. On peut considérer les arbres sans coupures comme
des formes normales, dont la construction est en quelque sorte imposée par les
formules contenues dans la conclusion~: on doit ainsi remonter en utilisant des
règles décomposant les formules au fur et à mesure. En fait, on remarque un fait
important~: quand on monte dans l'arbre, en l'absence de coupures, toutes les
règles construisent des sous-formules des formules déjà présentes en bas de
l'arbre.

\begin{definition}[Ordre de sous-formule]
  Soit $\Sigma$ une signature.
  On définit sur $\Formula(\Sigma)$ un ordre, défini comme l'ordre des
  sous-formules, comme la plus petite relation de pré-oordre (non forcément
  antisymétrique) telle que~:
  \begin{itemize}
  \item $\varphi$ est une sous-formule de $\lnot\varphi$~;
  \item $\varphi$ et $\psi$ sont des sous-formules de $\varphi \land \psi$,
    $\varphi \lor \psi$ et $\varphi \to \psi$~;
  \item $\varphi[t/x]$ est une sous-formule de $\forall x, \varphi$ et de
    $\exists x, \varphi$, pour tout terme $t$~;
  \item si $t,u$ sont des termes, $x$ une variable et $\varphi$ une formule,
    alors $\varphi[t/x]$ est une sous-formule de $\varphi[u/x]$.
  \end{itemize}
\end{definition}

On peut ainsi énoncer la propriété de la sous-formule, dont la preuve est une
simple vérification des règles.

\begin{property}[Sous-formule]
  Soit $\pi$ un arbre de preuve de $\LK$ sans occurrence de la règle $cut$.
  Soit $\varphi_1,\ldots,\varphi_n \vdLK \psi_1,\ldots,\psi_k$ le séquent
  conclusion de $\pi$. Tout séquent apparaissant dans $\pi$ n'est constitué que
  de sous-formules des $\varphi_i$ et $\psi_i$.
\end{property}

\begin{remark}
  Ce fait est plus général de la cohérence, puisqu'une preuve sans coupure de
  $\vdLK$ serait une preuve acceptant la propriété de la sous-formule, ce qui
  est absurde.
\end{remark}

Combinons maintenant ce résultat et le résultat important de
l'\cref{exo.prenexe}. On peut remplacer les formules du séquent conclusion par
des formules équivalentes, toutes sous forme normale. Par la propriété de la
sous-formule, on sait alors que toutes les formules qui apparaissent sont
des sous-formules de formes prénexes~: il est facile en considérant la relation
de sous-formule de remarquer que ce sont des formules elles-mêmes sous forme
prénexe. Ainsi, tout séquent prouvable $\Gamma \vdLK \Delta$ est équivalent à
un arbre de preuve contenant uniquement des formules sous forme prénexe.

\begin{figure}[t]
  \resizebox{\textwidth}{!}{
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    $\rOne$ & $\Sigma^l$ & $\Sigma^r$ & $\Phi^l$ & $\Phi^r$ \\
    \hline
    $lw$ & $\varnothing$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ \\
    $rw$ & $\varnothing$ & $\varnothing$ & $\varnothing$ & $\{\varphi\}$ \\
    $l\lnot$ & $\varnothing$ & $\{\varphi\}$ & $\{\lnot\varphi\}$ &
    $\varnothing$ \\
    $r\lnot$ & $\{\varphi\}$ & $\varnothing$ & $\varnothing$ &
    $\{\lnot\varphi\}$ \\
    $r\lor_1$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ &
    $\{\varphi \lor \psi\}$ \\
    $r\lor_2$ & $\varnothing$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi\lor\psi\}$ \\
    $l\land_1$ & $\{\varphi\}$ & $\varnothing$ & $\{\varphi\land\psi\}$ &
    $\varnothing$ \\
    $l\land_2$ & $\{\psi\}$ & $\varnothing$ & $\{\varphi\land\psi\}$ &
    $\varnothing$ \\
    $r\to_1$ & $\{\varphi\}$ & $\varnothing$ & $\varnothing$ &
    $\{\varphi \to \psi\}$ \\
    $r\to_2$ & $\varnothing$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi\to\psi\}$ \\
    $l\forall$ & $\{\varphi[t/x]\}$ & $\varnothing$ &
    $\{\forall x, \varphi\}$ & $\varnothing$ \\
    $r\forall$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ &
    $\{\forall x, \varphi\}$ \\
    $l\exists$ & $\{\varphi\}$ & $\varnothing$ & $\{\exists x, \varphi\}$ &
    $\varnothing$ \\
    $r\exists$ & $\varnothing$ & $\{\varphi[t/x]\}$ & $\varnothing$ &
    $\{\exists x, \varphi\}$ \\
    \hline
  \end{tabular}
  \quad
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    $\rTwo$ & $\Sigma_1^l$ & $\Sigma_1^r$ & $\Sigma_2^l$ & $\Sigma_2^r$ &
    $\Phi^l$ & $\Phi^r$ \\
    \hline
    $l\lor$ & $\{\varphi\}$ & $\varnothing$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi \lor \psi\}$ & $\varnothing$ \\
    $r\land$ & $\varnothing$ & $\{\varphi\}$ & $\varnothing$ &
    $\{\psi\}$ & $\varnothing$ & $\{\varphi\land \psi\}$ \\
    $l\to$ & $\varnothing$ & $\{\varphi\}$ & $\{\psi\}$ & $\varnothing$ &
    $\{\varphi\to\psi\}$ & $\varnothing$\\
    \hline
  \end{tabular}
  }
  \caption{Tables de typologie des règles de $\LK$}
  \label{fig.typologie1}
\end{figure}

En analysant plus précisément les règles successives, on peut relever des
réécritures posibles pour commuter certaines règles. Ces réécritures permettent
de \og faire descendre dans l'arbre \fg les règles portant sur les
quantificateurs, de sorte qu'on puisse transformer notre arbre de preuve en
un arbre en deux blocs~: le bas de l'arbre ne contient que des règles
$l\forall / r\forall / l\exists / r\exists$ ainsi que des règles $lw / rw$,
et le haut de l'arbre ne contient que d'autres règles que les $6$ précédentes
(et aucun $cut$ puisqu'on considère des arbres sans coupure).

\subsection[Théorème de Herbrand]{Théorème du séquent du milieu et
  théorème de Herbrand}

Pour prouver ce théorème, il nous faut d'abord donner une typologie des règles,
de sorte à pouvoir écrire plus facilement les transformations. Pour cela, on
commence par définir plusieurs blocs de règles.

\begin{definition}[Groupes de règles]
  On appelle règles structurelles les règles $lw/rw$. On appelle règles
  logiques les règles
  $l\lnot/r\lnot/l\lor/r\lor_1/r\lor_2/l\land_1/l\land_2/r\land
  /l\to/r\to_1/r\to_2/l\forall/r\forall/l\exists/r\exists/l=/r=$.

  Parmi les règles logiques, on appelles règles quantifiantes les règles
  $l\forall/r\forall/l\exists/r\exists$, règles égalitaires les règles
  $l=/r=$ et règles connectives les autres règles logiques.

  On dira qu'une règle est de type $\rOne$ si elle a une seule prémisse, et
  de type $\rTwo$ si elle a deux prémisses.
\end{definition}

Toutes les règles non égalitaires de type $\rOne$ peuvent alors s'écrire de la
façon suivante~:
\[
\AxiomC{$\Gamma,\Sigma^l \vdLK \Sigma^r,\Delta$}
\RightLabel{$l\rOne$}
\UnaryInfC{$\Gamma,\varphi \vdLK \Delta$}
\DisplayProof
\qquad
\AxiomC{$\Gamma,\Sigma^l \vdLK\Sigma^r, \Delta$}
\RightLabel{$r\rOne$}
\UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
\DisplayProof
\]
où $\Sigma^l$ et $\Sigma^r$ contiennent des sous-formules de $\varphi$ (et
chacun contient au plus une formule). On appelle contexte d'une règle les
formules dans $\Gamma,\Delta$, qui sont inchangées lors de l'application de la
règle.

Les règles de type $\rTwo$ peuvent s'écrire de façon similaire~:
\begin{center}
  \resizebox{\textwidth}{!}{\(
    \AxiomC{$\Gamma_1,\Sigma^l_1 \vdLK \Sigma^r_1,\Delta_1$}
    \AxiomC{$\Gamma_2,\Sigma^l_2 \vdLK \Sigma^r_2,\Delta_2$}
    \RightLabel{$l\rTwo$}
    \BinaryInfC{$\Gamma_1,\Gamma_2,\varphi \vdLK \Delta_1,\Delta_2$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma_1,\Sigma^l_1 \vdLK \Sigma^r_1,\Delta_1$}
    \AxiomC{$\Gamma_2,\Sigma^l_2 \vdLK \Sigma^r_2,\Delta_2$}
    \RightLabel{$r\rTwo$}
    \BinaryInfC{$\Gamma_1,\Gamma_2\vdLK \varphi,\Delta_1,\Delta_2$}
    \DisplayProof
    \)}
\end{center}

Quitte à abstraire $\varphi$, on peut considérer que les règles gauches et
droites s'écrivent avec en séquent conclusion
$\Gamma, \Phi^l\vdLK\Phi^r,\Delta$ où $\Phi^l,\Phi^r$ sont deux ensembles de
formules tels que $\Phi^l \cup \Phi^r = \{\varphi\}$ et
$\Phi^l\cap \Phi^r = \varnothing$. On obtient ainsi les deux règles
\[
\AxiomC{$\Gamma,\Sigma^l \vdLK \Sigma^r,\Delta$}
\RightLabel{$\rOne$}
\UnaryInfC{$\Gamma,\Phi^l \vdLK \Phi^r,\Delta$}
\DisplayProof
\qquad
\AxiomC{$\Gamma_1,\Sigma^l_1 \vdLK \Sigma^r_1,\Delta_1$}
\AxiomC{$\Gamma_2,\Sigma^l_2 \vdLK \Sigma^r_2,\Delta_2$}
\RightLabel{$\rTwo$}
\BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK \Phi^r,\Delta_1,\Delta_2$}
\DisplayProof
\]
qui permettent de réécrire toutes les règles non égalitaires. On donne en
\cref{fig.typologie1} les instances de $\rOne$ et $\rTwo$ pour obtenir les
différentes règles.

On peut maintenant introduire le procédé de réécriture permettant de faire
remonter les règles connectives.

\begin{definition}[Commutation quantitative]
  On donne les réécritures suivantes de suites d'arbres, où
  $\quantif\in\{\forall,\exists\}$~:
  \begin{center}\resizebox{\textwidth}{!}{
      $\begin{array}{ccc}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma,\Sigma^l\vdLK\Sigma^r,\Delta$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\, \varphi, \Gamma, \Sigma^l\vdLK\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
        \DisplayProof
        & \reecr{l\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma,\Sigma^l\vdLK\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\varphi[t/x],\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\, \varphi, \Gamma_1,
          \Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK \Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{l\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\varphi[t/x],\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK \Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\, \varphi, \Gamma_2,
          \Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{l\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x],\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\varphi[t/x],\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi,\Gamma_1,\Gamma_2,\Phi^l\vdLK
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof

        \\
        \\

        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x][u/y],\Gamma[u/y]\vdLK\Delta[u/y]$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi[u/y],\Gamma[u/y]\vdLK\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\quantif x\,\varphi[v/y], \Gamma[v/y],
          u = v\vdLK\Delta[v/y]$}
        \DisplayProof
        &\reecr{l=\quantif \downarrow} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi[t/x][u/y],\Gamma[u/y]\vdLK\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\varphi[t/x][v/y],\Gamma[v/y], u = v\vdLK\Delta[v/y]$}
        \RightLabel{$l\quantif$}
        \UnaryInfC{$\quantif x\,\varphi[v/y], \Gamma[v/y],
          u = v\vdLK\Delta[v/y]$}
        \DisplayProof
      \end{array}
      $}
  \end{center}
  \begin{center}\resizebox{\textwidth}{!}{
      $\begin{array}{ccc}
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\Sigma^l\vdLK\varphi[t/x],\Sigma^r,\Delta$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma, \Sigma^l\vdLK
          \quantif x\,\varphi,\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\Gamma,\Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta$}
        \DisplayProof
        & \reecr{r\quantif \downarrow} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\Sigma^l\vdLK\varphi[t/x],\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\Gamma,\Phi^l\vdLK\varphi[t/x],\Phi^r,\Delta$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma,\Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\varphi[t/x],\Sigma^r_1,\Delta_1$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_1,
          \Sigma^l_1\vdLK\quantif x\, \varphi, \Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK \Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{r\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\varphi[t/x],\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\varphi[t/x],
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\quantif x\,\varphi,
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        
        \\
        \\
        
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK \Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\varphi[t/x],\Sigma^r_2,\Delta_2$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_2,
          \Sigma^l_2\vdLK\quantif x\, \varphi, \Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,
          \Phi^l\vdLK\quantif x\,\varphi,\Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof
        &\reecr{r\quantif \downarrow}&
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma^l_1\vdLK\Sigma^r_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma^l_2\vdLK\varphi[t/x],\Sigma^r_2,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\varphi[t/x],
          \Phi^r,\Delta_1,\Delta_2$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma_1,\Gamma_2,\Phi^l\vdLK\quantif x\,\varphi,
          \Phi^r,\Delta_1,\Delta_2$}
        \DisplayProof

        \\
        \\

        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma[u/y]\vdLK\varphi[u/y][t/x],\Delta[u/y]$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma[u/y]\vdLK\quantif x\,\varphi[u/y],\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma[v/y],
          u = v\vdLK\quantif x\,\varphi[v/y], \Delta[v/y]$}
        \DisplayProof
        &\reecr{r=\quantif \downarrow} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma[u/y]\vdLK\varphi[u/y][t/x],\Delta[u/y]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma[v/y], u = v\vdLK\varphi[v/y][t/x],\Delta[v/y]$}
        \RightLabel{$r\quantif$}
        \UnaryInfC{$\Gamma[v/y],
          u = v\vdLK\quantif x\,\varphi[v/y], \Delta[v/y]$}
        \DisplayProof
      \end{array}$
    }
  \end{center}
\end{definition}

\begin{remark}
  Cette réécriture d'arbres de preuve est bien définie. Pour la plupart des
  règles, cette bonne définition est claire. Relevons cependant que dans le
  cas où, par exemple, on fait la réécriture $l\quantif\downarrow$ où
  $\quantif = \exists$, il convient de vérifier que la variable $x$ est
  bien libre dans les autres séquents des règles une fois écrites~: c'est le
  cas si la règle initiale était bien applicable.

  De même, pour les règles $=\quantif\downarrow$, il faut vérifier que l'on peut
  bien faire commuter les deux substitutions $[t/x]$ et $[u/y]$
  (respectivement $[v/y]$). Si le cas est tel $l\forall$, où le terme introduit
  n'importe pas, on peut toujours réécrire la formule en $\varphi[u/y]$
  (respectivement $[v/y]$) au moment d'introduire la quantification. Si le cas
  est tel $l\exists$, où le terme $t$ est en fait exactement $x$, on sait donc
  que $x$ est une variable libre uniquement de $v$ (puisque la possibilité
  d'appliquer $l\exists$ par exemple présuppose que $\Gamma[u/y]$ et
  $\Delta[u/y]$ ne possèdent pas $x$ comme variable libre), et on peut donc
  remplacer $x$ dans $v$ par n'importe quelle autre variable qui n'est pas
  encore apparue.
\end{remark}

Il est ainsi possible de réécrire des arbres de preuves par les règles
$l\quantif\downarrow$ et $r\quantif\downarrow$. Pour l'instant on a seulement
défini les règles de réécriture sur des arbres fixés, qui sont des instances
locales d'une réécriture qu'on souhaite effectuer de façon globale. Il faut
donc définir une notion de réécriture globale. On introduit pour ça la notion
de relation compatible.

\begin{definition}[Relation compatible]
  Soit $R\subseteq \ProofLK \times \ProofLK$ une relation sur des arbres de
  preuves. $R$ est dite compatibles si, pour chaque règle de construction de
  $\LK$, de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma_1\vdLK \Delta_1$}
    \AxiomC{$\cdots$}
    \AxiomC{$\Gamma_n\vdLK\Delta_n$}
    \RightLabel{$r$}
    \TrinaryInfC{$\Theta\vdLK\Xi$}
  \end{prooftree}
  pour tous $i$, $\pi_i \concl \Gamma_i\vdLK\Delta_i$ et
  $\pi' \concl\Gamma_j\vdLK\Delta_j$ pour un certain $j$, si $\pi_j R \pi'$
  alors on a
  \begin{center}
    \resizebox{0.4\textwidth}{!}{$
      \AxiomC{$\pi_1$}
      \noLine
      \UnaryInfC{$\Gamma_1\vdLK\Delta_1$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi_j$}
      \noLine
      \UnaryInfC{$\Gamma_j\vdLK\Delta_n$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi_n$}
      \noLine
      \UnaryInfC{$\Gamma_n\vdLK\Delta_n$}
      \RightLabel{$r$}
      \QuinaryInfC{$\Theta\vdLK\Xi$}
      \DisplayProof
      $}
    \quad
    \raisebox{-0.2cm}{$R$}
    \quad
    \resizebox{0.4\textwidth}{!}{$
      \AxiomC{$\pi_1$}
      \noLine
      \UnaryInfC{$\Gamma_1\vdLK\Delta_1$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi'$}
      \noLine
      \UnaryInfC{$\Gamma_j\vdLK\Delta_j$}
      \AxiomC{$\cdots$}
      \AxiomC{$\pi_n$}
      \noLine
      \UnaryInfC{$\Gamma_n\vdLK\Delta_n$}
      \RightLabel{$r$}
      \QuinaryInfC{$\Theta\vdLK\Xi$}
      \DisplayProof
      $}
  \end{center}
\end{definition}

Une relation compatible est donc une relation telle que, par exemple, si
$\pi R \pi'$ alors
$\AxiomC{$\pi$}\RightLabel{$lw$}\UnaryInfC{$\Gamma\vdLK\Delta$}\DisplayProof R
\AxiomC{$\pi'$}\RightLabel{$lw$}\UnaryInfC{$\Gamma\vdLK\Delta$}\DisplayProof$.
C'est cette notion de relation compatible qui va permettre de considérer des
réduction dans des sous-arbres des arbres de preuve.

\begin{definition}[Réduction des commutations quantitatives]
  On définit la relation $\reecr{\quantif\downarrow}$ comme la plus petite
  relation compatible contenant les instances de $\reecr{l\quantif\downarrow}$,
  de $\reecr{r\quantif\downarrow}$, de $\reecr{l=\quantif\downarrow}$ et
  $\reecr{r=\quantif\downarrow}$.
\end{definition}

Notre relation $\reecr{\quantif\downarrow}$ nous permet donc de faire descendre
des règles quantitatives dans un arbre de preuve. On souhaite maintenant réduire
autant que possible nos arbres pour cette réécriture. Ce processus est
algorithmique, et il nécessite donc deux preuves algorithmiques pour assurer
qu'il permet d'obtenir le résultat qu'on recherche~:
\begin{itemize}
\item la terminaison, qui indique que la réduction s'opère un nombre fini de
  fois, et qui se prouve en montrant qu'il n'existe pas de suite infinie de
  la forme
  $\pi_1 \reecr{\quantif\downarrow}\pi_2\reecr{\quantif\downarrow}\cdots$
\item la correction, qui indique que la réduction se termine par un arbre de
  preuve qui vérifie la propriété qu'on recherche, ici que toute règle
  connective est située au-dessus de toute règle quantitative.
\end{itemize}

Pour prouver la terminaison, plusieurs méthodes sont possibles. La méthode la
plus difficile consiste à prouver que la réduction, ici
$\reecr{\quantif\downarrow}$, est une relation bien fondée. Ce fait n'est pas
toujours vrai, mais le prouver signifie alors que tout choix de suite de
réductions s'arrêtera à un moment (il peut pour autant y avoir des choix plus
efficaces que d'autres). La seconde méthode est d'assigner à toute instance de
notre problème de réécriture (ici, à tout arbre de preuve) une \og mesure\fg
qui est un élément d'un ensemble bien ordonné, et de prouver que pour tout
élément $\pi$ il existe un élément $\pi'$ tel que
$\pi\reecr{\quantif\downarrow} \pi'$ et tel que la mesure de $\pi'$ est
strictement inférieure à celle de $\pi$, ou alors que $\pi$ n'a pas de
successeur pour la réduction considérée.

On définit donc une mesure sur les arbres.

\begin{definition}[Poids d'une règle connective, d'un arbre]
  Soit $r$ une règle connective apparaissant dans un arbre de preuve $\pi$.
  On définit $w(r)$, le poids de $r$, comme le nombre de règles
  $r\quantif / l\quantif$ qui sont
  dans les sous-arbres des prémisses de $r$. On définit $w(\pi)$, le poids de
  l'arbre $\pi$, comme la somme des poids des règles qui composent $\pi$.
\end{definition}

\begin{proposition}\label{prop.weight.midsequent}
  Si $\pi\reecr{\quantif\downarrow}\pi'$, alors $w(\pi') = w(\pi) - 1$.
\end{proposition}

\begin{proof}
  Il suffit de regarder les différentes règles dans
  $\reecr{\quantif\downarrow}$. Si on est dans un cas inductif, l'hypothèse
  d'induction nous donne le résultat directement. Si on est dans l'un des
  cas de base, on vérifie qu'à chaque cas une règle connective est déplacée
  sous une règle quantitative, ce qui diminue le poids de la règle connective
  de $1$ et laisse inchangés tous les autres poids.
\end{proof}

On peut donc montrer le théorème du séquent du milieu.

\begin{theorem}[Séquent du milieu]\label{thm.midsequent}
  Soit $\Gamma\vdLK\Delta$ un séquent composé de formules sous forme prénexe.
  S'il existe un arbre de preuve $\pi\in\ProofLK$ tel que
  $\pi\concl \Gamma\vdLK\Delta$, alors il existe un arbre de preuve
  $\pi'\in\ProofLK$ tel que $\pi'\concl\Gamma\vdLK\Delta$ et ne contenant
  des règles quantitatives qu'en bas de l'arbre, c'est-à-dire qu'il existe un
  entier $n$ tel que les $n$ règles les plus basses de $\pi'$ sont des règles
  quantitatives, et toutes les autres règles sont des règles connectives,
  d'affaiblissement ou égalitaires.
\end{theorem}

\begin{proof}
  D'après la \cref{prop.weight.midsequent}, on sait qu'il est possible de
  trouver depuis $\pi$ un arbre $\pi'$ tel que
  $\pi\reecr{\quantif\downarrow}^\star \pi'$ et $\pi'$ ne se réduit en
  aucun autre arbre.

  On veut prouver qu'il n'existe aucune règle quantitative au-dessus d'une
  règle connective ou d'affaiblissement. Supposons qu'une telle suite de deux
  règles arrive. En utilisant les notations avec
  $\Sigma^l,\Sigma^r,\Phi^l,\Phi^r$, on sait que si
  la formule $\varphi[t/x]$ utilisée pour la règle $\quantif$ est dans
  le contexte, alors une réduction $\reecr{\quantif\downarrow}$ peut
  s'appliquer, contredisant le fait que $\pi'$ ne peut pas se réduire.
  On en déduit donc, sans perte de généralité, que $\varphi[t/x]$ est dans
  $\Sigma^l$. Mais alors, cela signifie que $\quantif x\,\varphi$ est une
  sous-formule de la règle du dessus. Si la règle du dessous est une règle
  logique, on obtient alors une formule qui n'est pas sous forme prénexe, ce
  qui contredit le fait que $\Gamma\vdLK\Delta$ est sous forme prénexe et la
  propriété de la sous-formule (et la règle ne peut pas être un affaiblissement
  si $\quantif x\,\varphi \in \Sigma^l$).

  Enfin, si $\pi_1\reecr{\quantif\downarrow} \pi_2$, alors $\pi_1$ et
  $\pi_2$ ont le même séquent conclusion, donc $\pi'$ a le même séquent
  conclusion que $\pi$.

  On en déduit que $\pi'$ vérifie les hypothèses.
\end{proof}

\begin{figure}[t]
  \centering
  \begin{tikzpicture}
    \node (A) at (0,-5) {$\Gamma\vdLK\Delta$};
    \node (B) at (0,0) {Séquent du milieu};
    \draw (A) -- (B)
    node[midway,rotate=90,below]{Règles quantitatives};
    \node (C) at (0,3) {Règles connectives et};
    \node (D) at (0,2.5) {d'affaiblissement};
    \draw[dashed] (B) -- (-5,5) -- (5,5) -- (B);
  \end{tikzpicture}
  \caption{Arbre de preuve avec séquent du milieu}
  \label{fig.midsequent}
\end{figure}

On donne en \cref{fig.midsequent} la silhouette d'un arbre de preuve respectant
le séquent du milieu. La forme purement verticale des règles quantitatives est
dû au fait qu'elles sont toutes de type $\rOne$.

En particulier, cela signifie qu'une preuve d'une formule existentielle ne peut
pas utiliser de données connectives pour s'effectuer~: elle doit pouvoir se
dérouler en introduisant directement les témoins à l'aide des règles
$l\exists/r\exists$. Cela entraine directement le théorème d'Herbrand.

\begin{theorem}[Herbrand]\label{thm.Herbrand}
  Soit $\exists x, \varphi$ une formule. Cette formule est prouvable
  si et seulement s'il existe des termes $t_1,\ldots,t_n$ tels que
  le séquent $\vdLK\varphi[t_1/x],\ldots,\varphi[t_n/x]$ est
  prouvable.
\end{theorem}

\begin{proof}
  Si le séquent $\vdLK\varphi[t_1/x],\ldots,\varphi[t_n/x]$ est prouvable, alors
  il est clair que
  $\exists x,\varphi$ est prouvable. Réciproquement, supposons que
  $\vdLK\exists x,\varphi$. Ce séquent est sous forme prénexe~: on y applique
  le \cref{thm.midsequent} pour obtenir un arbre de preuve
  $\pi\concl\vdLK\exists x, \varphi$ commençant par des règles
  quantitatives. Le séquent du milieu est donc constitué uniquement de
  sous-formules de $\varphi$. S'il contient $\exists x, \varphi$, alors
  tous les arbres au-dessus de ce séquent contiendront
  $\exists x, \varphi$ (puisqu'aucune règle non connective ne peut
  introduire $\exists$) ou appliqueront un affaiblissement sur cette
  dernière formule. On en déduit donc, quitte à supprimer la dernière
  formule $\exists x, \varphi$, que le séquent du milieu est constitué
  uniquement de sous-formules de $\exists x, \varphi$ et n'est pas
  constitué de $\exists x, \varphi$.

  On sait, de plus, que toutes les règles appliquées entre la conclusion
  $\vdLK\exists x, \varphi$ et le séquent du milieu, sont des règles
  $r\exists$, aucune autre règle quantitative n'étant applicable. On en déduit
  finalement que le séquent du milieu est
  $\vdLK \varphi[t_1/x],\ldots,\varphi[t_n/x]$ pour certains termes
  $t_1,\ldots,t_n$.
\end{proof}

Ce théorème peut sembler légèrement contre-intuitif. Lorsqu'on considère le
séquent $\vdLK\exists x, \varphi$, on peut être tenté de dire que, dans l'arbre
de preuve dont ce séquent est la conclusion, la dernière règle est $r\exists$
et le séquent au-dessus est donc $\vdLK \varphi[t/x]$. Ainsi, on s'attendrait à
ce qu'il n'existe qu'un seul terme $t$.

Contrairement aux attentes, la règle $r\exists$ ne ressemble pas forcément à
\begin{prooftree}
  \AxiomC{$\vdLK\varphi[t/x]$}
  \RightLabel{$r\exists$}
  \UnaryInfC{$\vdLK\exists x, \varphi$}
\end{prooftree}
mais peut aussi être de la forme
\begin{prooftree}
  \AxiomC{$\vdLK\exists x\, \varphi, \varphi[t/x]$}
  \RightLabel{$r\exists$}
  \UnaryInfC{$\vdLK\exists x, \varphi$}
\end{prooftree}
étant donné que nous manipulons des ensembles finis de formules. C'est ainsi, en
répétant le dernier arbre, qu'on peut engendrer un ensemble de termes
$t_1,\ldots,t_n$ et le séquent $\vdLK \varphi[t_1/x],\ldots,\varphi[t_n/x]$.

Ce théorème peut donc être renforcé dans le cas où tout séquent contient au plus
une formule à droite de $\vdLK$, ce qui est précisément le cas du calcul
intuitionniste, que nous abordons en \cref{sec.LJ}.

\subsection{Formulations alternatives de LK}

On voit aussi apparaître un défaut de l'utilisation d'ensembles de formules~:
le fait de dupliquer une formule n'est pas anodin et devrait donc être explicité
plutôt que d'être une conséquence du type de données utilisé. Pour y remédier,
on peut utiliser au choix des listes de formules, comme on l'a fait dans le
\cref{chp.logpred}, ou des multi-ensembles.

\begin{table}[t]
  \centering
  %\hrule
  \resizebox{\textwidth}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\varphi\vdLK \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLK\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \Delta, \varphi$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \lnot\varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\lor\psi \vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \RightLabel{$r\lor_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\lor\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLK \Delta,\psi$}
      \RightLabel{$r\lor_2$}
      \UnaryInfC{$\Gamma\vdLK \Delta, \varphi \lor \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \RightLabel{$l\land_1$}
      \UnaryInfC{$\Gamma,\varphi\land\psi\vdLK \Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma, \psi \vdLK \Delta$}
      \RightLabel{$l\land_2$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \AxiomC{$\Theta\vdLK \Xi,\psi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi, \varphi\land\psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta,\varphi$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\to\psi\vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$r\to_1$}
      \UnaryInfC{$\Gamma\vdLK \Delta,\varphi\to\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma \vdLK \Delta,\psi$}
      \RightLabel{$r\to_2$}
      \UnaryInfC{$\Gamma\vdLK\Delta, \varphi \to \psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \Delta,\varphi$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\forall x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta,\varphi[t/x]$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \Delta,\exists x, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLK t = t$}
      \DisplayProof
  \end{tabular}}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LK$ avec multi-ensembles}
  \label{tbl.LK.multiset}

  \hrule
\end{table}

\begin{definition}[Multi-ensembles]
  Soit $X$ un ensemble.
  On appelle multi-ensemble d'éléments de $X$, ou juste multi-ensemble,
  une fonction $Y : X \to \bN$, et on note $\powermul(X)$ l'ensemble des
  multi-ensembles sur $X$. On définit sur les multi-ensembles les
  opérations
  \[
  \makeFun{\cup}{\powermul(X)\times\powermul(X)}{\powermul(X)}{(Y,Z)}
          {x \mapsto \max(Y(x),Z(x))}
  \]
  \[
  \makeFun{\cap}{\powermul(X)\times\powermul(X)}{\powermul(X)}{(Y,Z)}
          {x \mapsto \min(Y(x),Z(x))}
  \]
  \[
  \makeFun{+}{\powermul(X)\times\powermul(X)}{\powermul(X)}{(Y,Z)}
          {x \mapsto Y(x) + Z(x)}
  \]
  On dit qu'un multi-ensemble $Y$ est fini si son support
  $\Supp(Y) \defeq \{ x \in X \mid Y(x) \neq 0 \}$ est fini.
\end{definition}

\begin{remark}
  Les parties d'un ensemble peuvent être vues comme des multi-ensembles dont
  le codomaine est $\btwo$, grâce à leur fonction caractéristique. On a même
  un moyen de transformer un multi-ensemble en ensemble, en ramenant toutes les
  valeurs strictement positives à $1$. Cette opération commute alors avec les
  opérations d'union et d'intersection, et $+$ devient alors $\cup$ une fois
  interprété dans les ensembles.
\end{remark}

Dans le cas des multi-ensembles, l'ordre n'importe pas, mais le nombre
d'occurrences d'une formule importe. On doit donc ajouter une règle permettant
de transformer deux occurrences en une seule~: c'est la règle de contraction.

\begin{definition}[Calcul des séquents $\LK$ avec multi-ensembles]
  On définit le calcul des séquents $\LK$ avec multi-ensembles par l'ensemble
  $\ProofLK$ construit d'après les règles de la \cref{tbl.LK.multiset} où
  les séquents $\Gamma\vdLK\Delta$ sont constitués de multi-ensembles finis, et
  où $\Gamma,\Delta$ est le multi-ensemble $\Gamma + \Delta$.
\end{definition}

Le \cref{thm.Herbrand} dans ce cadre se prouve alors en considérant que les
dernières règles sont des successions de $r\exists$ et de $rc$, d'où la
multiplication des termes $t_1,\ldots,t_n$.

En utilisant des arbres sans coupure, et encore plus en utilisant le
\cref{thm.midsequent}, il est donc possible de faire de la recherche de
preuves~: si on considère un séquent $\Gamma\vdLK\Delta$, on sait qu'il est
prouvable si et seulement s'il l'est par un arbre sans coupure, et commençant
uniquement par des règles quantitatives (quitte à mettres les formules de
$\Gamma$ et $\Delta$ sous forme prénexe). Cette approche de la synthèse d'arbres
de preuves motive alors une présentation \og vers le haut\fg de $\LK$. Dans
cette présentation, les règles sont construites de sorte à favoriser le
parcours de l'arbre en partant de la conclusion, et en cherchant à construire
les sous-arbres. On conserve donc au maximum les hypothèses, au lieu de les
scinder comme dans la présentation précédente (on a donc un style additif).

\begin{table}[t]
  \centering
  %\hrule
  %\resizebox{!}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\Gamma,\varphi\vdLK \varphi,\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLK\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi,\psi,\Gamma'\vdLK\Delta$}
      \RightLabel{\textit{le}}
      \UnaryInfC{$\Gamma,\psi,\varphi,\Gamma'\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\Delta,\varphi,\psi,\Delta'$}
      \RightLabel{\textit{re}}
      \UnaryInfC{$\Gamma\vdLK\Delta,\psi,\varphi,\Delta'$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \lnot\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Gamma, \psi \vdLK \Delta$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \varphi\lor\psi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\psi,\Delta$}
      \RightLabel{$r\lor$}
      \UnaryInfC{$\Gamma\vdLK \varphi \lor \psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi,\psi \vdLK \Delta$}
      \RightLabel{$l\land$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \AxiomC{$\Gamma\vdLK \psi,\Delta$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma\vdLK \varphi\land\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Gamma \psi \vdLK \Delta$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \varphi\to\psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\psi,\Delta$}
      \RightLabel{$r\to$}
      \UnaryInfC{$\Gamma\vdLK \varphi\to\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \forall x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi[t/x],\Delta$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \exists x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\Gamma \vdLK t = t,\Delta$}
      \DisplayProof
  \end{tabular}%}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LK$ présenté vers le haut avec listes}
  \label{tbl.LK.upward}

  \hrule
\end{table}

On donne donc la version vers le haut de $\LK$, dans laquelle on considère des
listes plutôt que des multi-ensembles, pour offrir une version la plus formelle
possible du système syntaxique.

\begin{definition}[Calcul des séquents $\LK$ présenté vers le haut avec listes]
  Le calcul des séquents $\LK$ présenté vers le haut avec listes est l'ensemble
  $\ProofLK$ décrit par les règles de la \cref{tbl.LK.upward}, où les
  séquents $\Gamma\vdLK\Delta$ sont donnés par des listes de formules, et où
  $\Gamma,\Delta$ est la concaténation des listes $\Gamma$ et $\Delta$.
\end{definition}

\begin{remark}
  Le fait de considérer des listes nous pousse à ajouter les règles d'échange
  $le/re$. On peut prouver grâce à elles, et en sachant que toute permutation
  s'écrit comme produit de transpositions, que si $\sigma,\rho$ sont deux
  permutations respectivement de $\Gamma$ et de $\Delta$, alors
  \begin{prooftree}
    \AxiomC{$\Gamma\vdLK\Delta$}
    \RightLabel{\textit{exch}}
    \UnaryInfC{$\sigma(\Gamma)\vdLK\rho(\Delta)$}
  \end{prooftree}
  est dérivable.

  Au contraire, les deux règles $lw/rw$ ne sont ici pas considérées. Cela est
  dû au fait que ces règles sont directement dérivables~: comme les règles
  préservent toutes leur contexte et que $ax$ et $r=$ sont contextuelles (au
  sens où on n'a pas simplement $\varphi \vdLK \varphi$ mais un contexte
  autour de ce séquent), tout ajout de formules dans le contexte peut se
  conserver des feuilles à la conclusion.
\end{remark}

\begin{table}[t!]
  \centering
  %\hrule
  %\resizebox{!}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\varphi\vdLK \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLK \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLK \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLK\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLK\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi,\psi,\Gamma'\vdLK\Delta$}
      \RightLabel{\textit{le}}
      \UnaryInfC{$\Gamma,\psi,\varphi,\Gamma'\vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK\Delta,\varphi,\psi,\Delta'$}
      \RightLabel{\textit{re}}
      \UnaryInfC{$\Gamma\vdLK\Delta,\psi,\varphi,\Delta'$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLK \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLK \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLK \lnot\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK \Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\lor\psi \vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\psi,\Delta$}
      \RightLabel{$r\lor$}
      \UnaryInfC{$\Gamma\vdLK \varphi \lor \psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi,\psi \vdLK \Delta$}
      \RightLabel{$l\land$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLK \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \AxiomC{$\Theta\vdLK \psi,\Xi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLK \varphi\land\psi,\Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLK \varphi,\Delta$}
      \AxiomC{$\Theta, \psi \vdLK \Xi$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\to\psi\vdLK \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLK\psi,\Delta$}
      \RightLabel{$r\to$}
      \UnaryInfC{$\Gamma\vdLK \varphi\to\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLK\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLK \varphi,\Delta$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLK \forall x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLK\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLK\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLK \varphi[t/x],\Delta$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLK \exists x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLK \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLK \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLK t = t$}
      \DisplayProof
  \end{tabular}%}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LK$ présenté vers le bas avec listes}
  \label{tbl.LK.upward}

  \hrule
\end{table}

Une autre présentation est possible, celle-ci orientée vers le bas, dont
l'objectif est au contraire de favoriser l'écriture d'un arbre dont on
connait déjà la forme au préalable, en particulier les feuilles, pour pouvoir
facilement dériver l'ensemble des formules qui suivent.

L'équivalence entre toutes les présentations de $\LK$ données jusque là tient à
plusieurs éléments~:
\begin{itemize}
\item d'abord, on a des façons canoniques de relier les listes, les
  multi-ensembles finis et les ensembles finis. A l'utilisation de règles
  d'échange près, les arbres par listes et par multi-ensembles sont les mêmes,
  et les arbres par multi-ensembles et par ensembles sont les mêmes à
  l'utilisation de règles de contraction près.
\item on remarque cependant que les
  règles d'échange peuvent mener à des arbres particulièrement longs si les
  règles sont de la forme $\Gamma,\varphi\vdLK\Delta$ plutôt que
  $\Gamma,\varphi,\Gamma'\vdLK\Delta$ par exemple, puisqu'alors il faudrait
  des suites de règles d'échange pour placer la formule impliquée dans la
  règle en tête de la liste de gauche, puis des suites de règles d'échange
  pour replacer la formule à sa place initiale. Il vaut mieux donc considérer
  une version plus lâche des règles dans laquelle on applique les règles sur
  n'importe quelle formule occurrant dans l'une des listes, plutôt que toujours
  la plus proche du symbole $\vdLK$.
\item pour simuler les règles additives à partir des règles multiplicatives,
  il suffit d'enrichir les contextes des prémisses avec des affaiblissements
  jusqu'à avoir le même contexte des deux côtés~:
  \begin{center}
    \resizebox{0.9\textwidth}{!}{$
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_2,\Delta$}
    \AxiomC{$\Theta,\Sigma^l_2\vdLK \Sigma^r_2,\Xi$}
    \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLK \Phi^r,\Delta,\Xi$}
    \DisplayProof
    \quad\reecr{}\quad
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_1,\Delta$}
    \doubleLine
    \RightLabel{$lw/rw$}
    \UnaryInfC{$\Gamma,\Theta,\Sigma^l_1\vdLK\Sigma^r_1\Delta,\Xi$}
    \AxiomC{$\Theta,\Sigma^l_2\vdLK\Sigma^r_2,\Xi$}
    \doubleLine
    \RightLabel{$lw/rw$}
    \UnaryInfC{$\Gamma,\Theta,\Sigma^l_2\vdLK\Sigma^r_2,\Delta,\Xi$}
    \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLK\Phi^r,\Delta,\Xi$}
    \DisplayProof
    $}
  \end{center}
\item pour simuler les règles multiplicatives à partir des règles additives,
  il suffit d'utiliser des règles de contraction pour dédoubler le contexte et
  le répartir uniformément entre les deux prémisses~:
  \begin{center}
    \resizebox{0.9\textwidth}{!}{$
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_2,\Delta$}
    \AxiomC{$\Gamma,\Sigma^l_2\vdLK \Sigma^r_2,\Delta$}
    \BinaryInfC{$\Gamma,\Phi^l\vdLK \Phi^r,\Delta$}
    \DisplayProof
    \quad\reecr{}\quad
    \AxiomC{$\Gamma,\Sigma^l_1\vdLK \Sigma^r_1,\Delta$}
    \AxiomC{$\Gamma,\Sigma^l_2\vdLK \Sigma^r_2,\Delta$}
    \BinaryInfC{$\Gamma,\Gamma,\Phi^l\vdLK\Phi^r,\Delta,\Delta$}
    \doubleLine
    \RightLabel{$lc/rc$}
    \UnaryInfC{$\Gamma,\Phi^l\vdLK\Phi^r,\Delta$}
    \DisplayProof
    $}
  \end{center}
\end{itemize}

On souhaite maintenant prouver le théorème d'élimination des coupures.

\subsection{L'élimination des coupures}

On a déjà vu comment réécrire des arbres en faisant descendre des règles
quantifiantes. Pour l'élimination des coupures, l'objectif sera au contraire de
faire monter les règles $cut$.

Avant de donner la preuve de l'élimination des coupures, on va d'abord
développer le calcul des séquents sur lequel on va effectuer la preuve. On a
déjà vu plusieurs présentations possibles, et chaque présentation demande que
l'on prouve un théorème d'élimination des coupures qui lui est propre. En plus
de cela, si l'on s'intéresse à la version intuitionniste du calcul des
séquents, il faut encore prouver un théorème d'élimination des coupures pour
chaque nouveau calcul introduit.

Comme la preuve est technique, on préfère ménager nos efforts et construire un
calcul suffisamment général en amont, pour que toutes nos présentations soient
des fragments de notre calcul général. Ce calcul, $\LS$, sera constitué des
fragments suivants~:
\begin{itemize}
\item les constructeurs $\parr/\land$ sont la disjonction et la conjonction
  multiplicatives, leurs règles séparent donc les contextes quand on les
  lit du bas vers le haut~;
\item les constructeurs $\lor/\with$ sont la disjonction et la conjonction
  additives, leurs règles copient donc les contextes dans les prémisses,
  quand on les lit du bas vers le haut~;
\item la version multiplicative de l'implication sera notée $\multimap$~;
\item les constructeurs $\diamond/\square$ sont ce qu'on appelle des modalités,
  qu'on présente plus en détails dans la suite du chapitre, mais qui doivent
  se lire comme des constructeurs unaires de formules évoquant respectivement
  la possibilité d'une formule et sa nécessité. Le choix de la notation
  $\square$ dans la \cref{def.HB.cond} vient directement de cette notion de
  modalité, le prédicat $\Th(\encode{\godcod{\varphi}})$ pouvant se voir
  comme une nécessitation de la vérité de $\varphi$.
\end{itemize}
Le fait d'inclure les constructeurs à la fois additifs et multiplicatifs permet
de déduire de l'élimination des coupures pour $\LS$ la propriété pour les
présentations de $\LK$ données jusqu'alors. Le fait d'ajouter les modalités
nous permet d'introduire plusieurs sous fragments d'intérêt. Enfin, cela nous
permet de mettre l'accent sur le principe suivant
\begin{quote}
  La propriété d'élimination des coupures ne s'intéresse aucunement à la
  sémantique des règles, elle ne dépend que de la façon dont les règles se
  structurent.
\end{quote}
C'est pour cette raison que, par exemple, l'élimination des coupures pour
$\with$ et pour $\land$ sont bien différentes malgré le fait que les deux
connecteurs logiques sont logiquement équivalents.

\begin{table}[t!]
  \centering
  %\hrule
  \resizebox{\textwidth}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\varphi\vdLS \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLS \varphi,\Delta$}
      \AxiomC{$\Theta, \varphi \vdLS \Xi$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Theta\vdLS \Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLS\Delta$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\varphi,\Delta$}
      \RightLabel{\textit{rc}}
      \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi,\psi,\Gamma'\vdLS\Delta$}
      \RightLabel{\textit{le}}
      \UnaryInfC{$\Gamma,\psi,\varphi,\Gamma'\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\Delta,\varphi,\psi,\Delta'$}
      \RightLabel{\textit{re}}
      \UnaryInfC{$\Gamma\vdLS\Delta,\psi,\varphi,\Delta'$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLS \Delta$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLS \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLS \Delta$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLS \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLS \varphi,\Delta$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLS \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLS \Delta$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLS \lnot\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \AxiomC{$\Gamma,\psi\vdLS\Delta$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma,\varphi\lor\psi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \RightLabel{$r\lor_1$}
      \UnaryInfC{$\Gamma\vdLS \varphi\lor\psi,\Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLS\psi,\Delta$}
      \RightLabel{$r\lor_2$}
      \UnaryInfC{$\Gamma\vdLS\varphi\lor\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLS \Delta$}
      \AxiomC{$\Theta, \psi \vdLS \Xi$}
      \RightLabel{$l\parr$}
      \BinaryInfC{$\Gamma, \Theta, \varphi\parr\psi \vdLS \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS \varphi,\psi,\Delta$}
      \RightLabel{$r\parr$}
      \UnaryInfC{$\Gamma\vdLS \varphi \parr \psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi,\psi \vdLS \Delta$}
      \RightLabel{$l\land$}
      \UnaryInfC{$\Gamma,\varphi \land \psi\vdLS \Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS \varphi,\Delta$}
      \AxiomC{$\Theta\vdLS \psi,\Xi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma, \Theta\vdLS \varphi\land\psi,\Delta, \Xi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$l\with_1$}
      \UnaryInfC{$\Gamma,\varphi\with\psi\vdLS\Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma,\psi\vdLS\Delta$}
      \RightLabel{$l\with_2$}
      \UnaryInfC{$\Gamma,\varphi\with\psi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \AxiomC{$\Gamma\vdLS\psi,\Delta$}
      \RightLabel{$r\with$}
      \BinaryInfC{$\Gamma\vdLS\varphi\with\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \AxiomC{$\Gamma,\psi\vdLS\Delta$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma,\varphi\to\psi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$r\to_1$}
      \UnaryInfC{$\Gamma\vdLS\varphi\to\psi,\Delta$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLS\psi,\Delta$}
      \RightLabel{$r\to_2$}
      \UnaryInfC{$\Gamma\vdLS\varphi\to\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLS \varphi,\Delta$}
      \AxiomC{$\Theta, \psi \vdLS \Xi$}
      \RightLabel{$l\multimap$}
      \BinaryInfC{$\Gamma, \Theta,\varphi\multimap\psi\vdLS \Delta, \Xi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi \vdLS\psi,\Delta$}
      \RightLabel{$r\multimap$}
      \UnaryInfC{$\Gamma\vdLS \varphi\multimap\psi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLS\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS \varphi,\Delta$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLS \forall x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLS\Delta$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLS \varphi[t/x],\Delta$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLS \exists x\, \varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$l\square$}
      \UnaryInfC{$\Gamma,\square\varphi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \RightLabel{$r\square^\ddagger$}
      \UnaryInfC{$\Gamma\vdLS\square\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
      \RightLabel{$l\diamond^\ddagger$}
      \UnaryInfC{$\Gamma,\diamond\varphi\vdLS\Delta$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLS\varphi,\Delta$}
      \RightLabel{$r\diamond$}
      \UnaryInfC{$\Gamma\vdLS\diamond\varphi,\Delta$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLS \Delta[u / x]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLS \Delta[t / x]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLS t = t$}
      \DisplayProof
  \end{tabular}}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LS$}
  \label{tbl.LS}

  \hrule
\end{table}

\begin{definition}[Calcul des séquents $\LS$]
  On définit le calcul des séquents $\LS$ par les règles de la \cref{tbl.LS},
  en conditionnant les règles marquées d'un $\dagger$ au fait que $x$ est libre
  dans $\Gamma,\Delta$ et en conditionnant les règles marquées d'un
  $\ddagger$ au fait que toutes les formules de $\Gamma$ sont de la forme
  $\square\psi$ et toutes les formules de $\Delta$ sont de la forme
  $\diamond\psi$.
\end{definition}

On a ainsi défini une nouvelle syntaxe. La première chose à faire, pour pouvoir
étudier plus efficacement les règles, est de donner une typologie des règles
présentes. Comme auparavant, on considère $\Sigma^l$ et $\Sigma^r$ les ensembles
des sous-formules des prémisses, et $\Phi^l$ et $\Phi^r$ les ensembles de
formules de la conclusion, pour une règle donnée.

Puisque nous avons des règles additives et multiplicatives, trois types
de règles apparaissent plutôt que deux~:
\begin{itemize}
\item les règles de type $\rOne$ restent inchangées, elles sont de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma,\Sigma^l\vdLS\Sigma^r,\Delta$}
    \RightLabel{$\rOne$}
    \UnaryInfC{$\Gamma,\Phi^l\vdLS\Phi^r,\Delta$}
  \end{prooftree}
\item les règles multiplicatives à deux prémisses sont de type $\rTwo$, et elles
  sont de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma,\Sigma^l_1\vdLS\Sigma^r_1,\Delta$}
    \AxiomC{$\Theta,\Sigma^l_2\vdLS\Sigma^r_2,\Xi$}
    \RightLabel{$\rTwo$}
    \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLS\Phi^r,\Delta,\Xi$}
  \end{prooftree}
\item les règles additives à deux prémisses sont de type $\rTwoB$, et elles sont
  de la forme
  \begin{prooftree}
    \AxiomC{$\Gamma,\Sigma^l_1\vdLS\Sigma^r_1,\Delta$}
    \AxiomC{$\Gamma,\Sigma^l_2\vdLS\Sigma^r_2,\Delta$}
    \RightLabel{$\rTwoB$}
    \BinaryInfC{$\Gamma,\Phi^l\vdLS\Phi^r,\Delta$}
  \end{prooftree}
\end{itemize}
Techniquement, on pourrait considérer que $cut$ est une règle de type $\rTwo$,
mais on va traiter à part la règle $cut$, puisque c'est elle que l'on souhaite
éliminer.

Puisqu'on souhaite déplacer les $cut$ vers le haut, on considère des suites de
règles où une règle quelconque est au-dessus d'une règle $cut$. La situation
est alors très différente suivant la place de la conclusion d'une règle par
rapport à la formule sur laquelle s'effectuer le $cut$. On introduit donc
d'abord une nomenclature pour distinguer cette situation.

\begin{notation}
  Pour faciliter la lecture vis à vis des positions latérales (gauche / droite),
  on réécrit la règle $cut$ en échangeant ses prémisses~:
  \begin{prooftree}
    \AxiomC{$\Gamma,\varphi\vdLS\Delta$}
    \AxiomC{$\Theta\vdLS\varphi,\Xi$}
    \RightLabel{$cut$}
    \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
  \end{prooftree}
\end{notation}

\begin{definition}[Coupure logique, formule de coupure]
  Soit une instance de la règle $cut$. La formule apparaissant dans les deux
  séquents de la prémisse et disparaissant dans la conclusion est appelée la
  formule de coupure.

  Pour une instance $C$ de $cut$ dont la formule de coupure est $\varphi$, on
  dira que $C$ est~:
  \begin{itemize}
  \item $l$-logique si la règle en haut à gauche de $C$ est une règle logique
    qui crée la formule $\varphi$ (c'est donc une règle $l$-logique puisque
    $\varphi$ est à gauche de $\vdLS$)
  \item $r$-logique si la règle en haut à droite de $C$ est une règle logique
    qui crée la formule $\varphi$
  \end{itemize}
  $C$ sera dite logique si elle est à la fois $l$-logique et $r$-logique.
\end{definition}

On peut alors commencer par éliminer les règles logique.

\begin{definition}
  On définit la réécriture des coupures logiques par les règles suivantes~:
  \begin{center}
    \resizebox{\textwidth}{!}{\(
      \begin{array}{ccc}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \RightLabel{$l\lnot$}
        \UnaryInfC{$\Gamma,\lnot\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS \Xi$}
        \RightLabel{$r\lnot$}
        \UnaryInfC{$\Theta\vdLS\lnot\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\lnot} &
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS\Xi$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Theta,\Gamma\vdLS\Xi,\Delta$}
        \doubleLine
        \RightLabel{$le/re$}
        \UnaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_1\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_2\vdLS\Delta$}
        \RightLabel{$l\lor$}
        \BinaryInfC{$\Gamma,\varphi_1\lor\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_i,\Xi$}
        \RightLabel{$r\lor_i$}
        \UnaryInfC{$\Theta\vdLS\varphi_1\lor\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\lor_i} &
        \AxiomC{$\mathlarger{\pi_i}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_i\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_i,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
%      \end{array}
%    \)}
%  \end{center}
%  \begin{center}
%    \resizebox{\textwidth}{!}{\(
        %      \begin{array}{ccc}
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\varphi_1\vdLS\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \RightLabel{$l\parr$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\varphi_1\parr\varphi_2\vdLS
          \Delta_1,\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_1,\varphi_2,\Xi$}
        \RightLabel{$r\parr$}
        \UnaryInfC{$\Theta\vdLS\varphi_1\parr\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        & \reecr{log\parr} &
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\varphi_1\vdLS\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi_1,\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_2,\Theta\vdLS\varphi_1,\Delta_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_1,\varphi_2\vdLS\Delta$}
        \RightLabel{$l\land$}
        \UnaryInfC{$\Gamma,\varphi_1\land\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1\vdLS\varphi_1,\Xi_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2\vdLS\varphi_2,\Xi_2$}
        \RightLabel{$r\land$}
        \BinaryInfC{$\Theta_1,\Theta_2\vdLS\varphi_1\land\varphi_2,\Xi_1,\Xi_2$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2\vdLS\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        & \reecr{log\land} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_1,\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1\vdLS\varphi_1,\Xi_1$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\varphi_2\vdLS\Delta,\Xi_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2\vdLS\varphi_2,\Xi_2$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2\vdLS\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_i\vdLS\Delta$}
        \RightLabel{$l\with_i$}
        \UnaryInfC{$\Gamma,\varphi_1\with\varphi_2\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_1\vdLS\Xi$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_2\vdLS\Xi$}
        \RightLabel{$r\with$}
        \BinaryInfC{$\Theta,\varphi_1\with\varphi_2\vdLS\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\with_i} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi_i\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_i}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_i\vdLS\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\psi\vdLS\Delta$}
        \RightLabel{$l\to$}
        \BinaryInfC{$\Gamma,\varphi\to\psi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS\Xi$}
        \RightLabel{$r\to_1$}
        \UnaryInfC{$\Theta\vdLS\varphi\to\psi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\to_1} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi\vdLS\Xi$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\psi\vdLS\Delta$}
        \RightLabel{$l\to$}
        \BinaryInfC{$\Gamma,\varphi\to\psi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\psi,\Xi$}
        \RightLabel{$r\to_2$}
        \UnaryInfC{$\Theta\vdLS\varphi\to\psi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\to_2} &
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma,\psi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\psi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1\vdLS\varphi_1,\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \RightLabel{$l\multimap$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\varphi\multimap\psi
          \vdLS\Delta_1,\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_1\vdLS\varphi_2,\Xi$}
        \RightLabel{$r\multimap$}
        \UnaryInfC{$\Theta\vdLS\varphi_1\multimap\varphi_2,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        & \reecr{log\multimap} &
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\varphi_2\vdLS\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta,\varphi_1\vdLS\varphi_2,\Xi$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1\vdLS\varphi_1,\Delta_1$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Theta,\Gamma_1\vdLS\varphi_2,\Xi,\Delta_1$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_2,\Theta,\Gamma_1\vdLS\Delta_2,\Xi,\Delta_1$}
        \doubleLine
        \RightLabel{$le/re$}
        \UnaryInfC{$\Gamma_1,\Gamma_2,\Theta\vdLS\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi[t/x]\vdLS\Delta$}
        \RightLabel{$l\forall$}
        \UnaryInfC{$\Gamma,\forall x\,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS \varphi,\Xi$}
        \RightLabel{$r\forall^\dagger$}
        \UnaryInfC{$\Theta\vdLS\forall x\,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\forall} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi[t/x]\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'[t/x]}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi[t/x],\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \RightLabel{$l\exists^\dagger$}
        \UnaryInfC{$\Gamma,\exists x\,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi[t/x],\Xi$}
        \RightLabel{$r\exists$}
        \UnaryInfC{$\Theta\vdLS\exists x\,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\exists} &
        \AxiomC{$\mathlarger{\pi[t/x]}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi[t/x]\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\vdLS\varphi[t/x],\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \RightLabel{$l\square$}
        \UnaryInfC{$\Gamma,\square\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$r\square^\ddagger$}
        \UnaryInfC{$\Theta\vdLS\square\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\square} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \RightLabel{$l\diamond^\ddagger$}
        \UnaryInfC{$\Gamma,\diamond\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$r\diamond$}
        \UnaryInfC{$\Theta\vdLS\diamond\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{log\diamond} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\Delta$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma,t=t\vdLS\Delta$}
        \AxiomC{}
        \RightLabel{$r=$}
        \UnaryInfC{$\vdLS t = t$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma\vdLS\Delta$}
        \DisplayProof
        & \reecr{log=} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\Delta$}
        \DisplayProof
      \end{array}
    \)}
  \end{center}

  La règle de réécriture $\reecr{log}$ est l'union de toutes les règles
  ci-dessus.
\end{definition}

Les réécritures logiques sont en quelque sorte le c{\oe}ur de l'élimination des
coupures. On remarque en effet que ces réécritures font disparaitre des règles~:
chaque paire $l\alpha/r\alpha$ avec $\alpha$ un constructeur logique, se situant
au-dessus d'une coupure, peut être supprimée par la réécriture.

\begin{remark}
  Plusieurs points sont à souligner dans les règles de réécriture présentées~:
  \begin{itemize}
  \item pour les règles multiplicatives, la réécriture multiplie les coupures,
    en en formant deux consécutives à la place des règles logiques~;
  \item pour les règles additives, la réécriture supprime l'un des arbres de
    preuve pour ne conserver que celui qui est pertinent pour prouver la
    prémisse~;
  \item dans le cas des quantificateurs, la réécriture demande d'effectuer une
    substitution dans l'entièreté de l'un des deux arbres de preuves. Cette
    substitution est possible grâce à la condition $\dagger$, qui assure que
    les autres formules restent intactes~;
  \item la condition $\ddagger$ pour les modalités n'a pas d'influence au
    moment de la réécriture, puisque la règle disparait directement~;
  \item pour l'égalité, le fait d'avoir en règle droite $r=$ force la
    réécriture de $[t/x]$ en $[u/x]$ à s'effectuer dans le cas où $t = u$, et
    signifie donc qu'on introduit une égalité triviale à gauche, qui
    disparaît automatiquement par la réécriture~;
  \item les règles structurelles ne sont presque pas employées lorsqu'on
    effectue des réécritures logiques. En fait on n'utilise que les règles
    d'échange, qui peuvent s'éliminer si on ajuste notre calcul des séquents
    en présentant les règles dans un certain ordre par exemple, ou qu'on se
    permet d'utiliser des règles n'importe où dans un séquent (en remplaçant
    dans les règles des séquents $\Gamma,\varphi\vdLS\psi\Delta$ par des
    séquents $\Gamma_1,\varphi,\Gamma_2\vdLS\Delta_1,\psi,\Delta_2$). On va
    dorénavant considérer que les règles d'échanges ne sont pas pertinentes.
    Cela allège grandement la définition des réécritures, et nous fait donc
    travailler avec la version multi-ensembliste des séquents, qui permet
    facilement de récupérer une version sous forme de listes (on introduit
    simplement à l'arbre final, une fois l'élimination des coupures
    effectuée, des règles d'échanges assurant la cohérence de notre arbre).
  \end{itemize}
\end{remark}

Comme les réécritures logiques éliminent chaque fois un couple de règles
logiques, les coupures résultant de la réécriture contiennent strictement moins
de règles logiques au-dessus d'elles. En associant à une coupure le nombre de
règles qui ne sont pas des coupures, on obtient ainsi une mesure qui décroît
strictement lorsqu'on effectue une réécriture logique. La procédure
termine donc pour nous donner un arbre sans coupure logique~: malheureusement,
beaucoup de coupures ne sont pas logiques, et peuvent être seulement
$l$-logiques ou $r$-logiques, voire ni l'une ni l'autre.

On s'intéresse donc au cas de coupures non logiques. L'objectif, en considérant
ces cas, est de se ramener à des coupures logiques~: on souhaite donc montrer
qu'une coupure qui n'est pas $l$-logique peut se réécrire en une coupure
$l$-logique, et symétriquement pour les coupures $r$-logiques. Pour ce faire,
il suffit de montrer que toute règle non $l$-logique peut être remontée
au-dessus de la règle de gauche de la coupure, de sorte qu'on finit par arriver
à une règle $l$-logique.

\begin{definition}[Relèvement d'une coupure vers la gauche]
  On définit le relèvement de coupures vers la gauche par les règles suivantes~:
  \begin{center}
    \resizebox{\textwidth}{!}{\(
      \begin{array}{ccc}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma,\Sigma^l\vdLS\Sigma^r,\Delta$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\varphi,\Gamma,\Phi^l\vdLS\Phi^r,\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Phi^l,\Theta\vdLS\Phi^r,\Delta,\Xi$}
        \DisplayProof
        & \reecr{\nwarrow\rOne} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma,\Sigma^l\vdLS\Sigma^r,\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Sigma^l,\Theta\vdLS\Sigma^r,\Delta,\Xi$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\Gamma,\Phi^l,\Theta\vdLS\Phi^r,\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma_1,\Sigma_1^l\vdLS\Sigma_1^r,\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma_2^l\vdLS\Sigma_2^r,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\varphi,\Gamma_1,\Gamma_2,\Phi^l\vdLS
          \Phi^r,\Delta_1,\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l,\Theta\vdLS
          \Phi^r,\Delta_2,\Delta_2,\Xi$}
        \DisplayProof
        & \reecr{\nwarrow \rTwo_1} &
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma_1,\Sigma_1^l\vdLS\Sigma_1^r,\Delta_1$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Theta,\Sigma_1^l\vdLS\Sigma_1^r,\Delta_1,\Xi$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Gamma_2,\Sigma_2^l\vdLS\Sigma_2^r,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l,\Theta\vdLS
          \Phi^r,\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Gamma_1,\Sigma_1^l\vdLS\Sigma_1^r,\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma_2,\Sigma_2^l\vdLS\Sigma_2^r,\Delta_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\varphi,\Gamma_1,\Gamma_2,\Phi^l\vdLS
          \Phi^r,\Delta_1,\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l,\Theta\vdLS
          \Phi^r,\Delta_2,\Delta_2,\Xi$}
        \DisplayProof
        & \reecr{\nwarrow \rTwo_2} &
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma_1,\Sigma_1^l\vdLS\Sigma_1^r,\Delta_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma_2,\Sigma_2^l\vdLS\Sigma_2^r,\Delta_2$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma_2,\Theta,\Sigma_2^l\vdLS\Sigma^r_2,\Delta_2,\Xi$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma_1,\Gamma_2,\Phi^l,\Theta\vdLS
          \Phi^r,\Delta_1,\Delta_2,\Xi$}
        \DisplayProof
      \end{array}
      \)}
  \end{center}
  \begin{center}
    \resizebox{\textwidth}{!}{\(
      \begin{array}{ccc}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma,\Sigma^l_1\vdLS\Sigma^r_1,\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma,\Sigma^l_2\vdLS\Sigma^r_2,\Delta$}
        \RightLabel{$\rTwoB$}
        \BinaryInfC{$\varphi,\Gamma,\Phi^l\vdLS\Phi^r,\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Phi^l,\Theta\vdLS\Phi^r,\Delta,\Xi$}
        \DisplayProof
        & \reecr{\nwarrow\rTwoB} &
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma,\Sigma^l_1\vdLS\Sigma^r_1,\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Delta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Sigma^l_1\vdLS \Sigma^r_1,\Delta,\Xi$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma,\Sigma^l_2\vdLS\Sigma^r_2,\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Sigma^l_2\vdLS\Sigma^r_2,\Delta,\Xi$}
        \RightLabel{$\rTwoB$}
        \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLS\Phi^r,\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi,\varphi\vdLS\Delta$}
        \RightLabel{$lc$}
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{\nwarrow c} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\varphi,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\varphi\vdLS\Delta,\Xi$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Theta\vdLS\Delta,\Xi,\Xi$}
        \doubleLine
        \RightLabel{$lc/rc$}
        \UnaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\Delta$}
        \RightLabel{$lw$}
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{\nwarrow w} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\Delta$}
        \doubleLine
        \RightLabel{$lw/rw$}
        \UnaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{}
        \RightLabel{$ax$}
        \UnaryInfC{$\varphi\vdLS\varphi$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \DisplayProof
        & \reecr{\nwarrow ax} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma[u/x],\varphi[u/x]\vdLS\Delta[u/x]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma[t/x],\varphi[t/x],t=u\vdLS\Delta[t/x]$}
        \AxiomC{$\mathlarger{\pi'[t/x]}$}
        \noLine
        \UnaryInfC{$\Theta[t/x]\vdLS\varphi[t/x],\Xi[t/x]$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma[t/x],\Theta[t/x],t=u\vdLS\Delta[t/x],\Xi[t/x]$}
        \DisplayProof
        & \reecr{\nwarrow =} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma[u/x],\varphi[u/x]\vdLS\Delta[u/x]$}
        \AxiomC{$\mathlarger{\pi'[u/x]}$}
        \noLine
        \UnaryInfC{$\Theta[u/x]\vdLS\varphi[u/x],\Xi[u/x]$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma[u/x],\Theta[u/x]\vdLS\Delta[u/x],\Xi[u/x]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma[t/x],\Theta[t/x],t=u\vdLS\Delta[t/x],\Xi[t/x]$}
        \DisplayProof
      \end{array}
      \)}
  \end{center}
  La réécriture $\reecr{\nwarrow}$ est l'union de toutes les règles de
  réécriture précédentes.
\end{definition}

\begin{remark}
  Quelques précisions sont nécessaire cette fois encore~:
  \begin{itemize}
  \item lorsque l'on considère $\reecr{\nwarrow \rOne}$, on y inclut
    par exemple
    \begin{center}
      \resizebox{0.8\textwidth}{!}{
        \(
        \begin{array}{ccc}
          \AxiomC{$\mathlarger{\pi}$}
          \noLine
          \UnaryInfC{$\Gamma,\varphi\vdLS\psi[t/x],\Delta$}
          \RightLabel{$r\forall^\dagger$}
          \UnaryInfC{$\Gamma,\varphi\vdLS\forall x\,\psi,\Delta$}
          \AxiomC{$\mathlarger{\pi'}$}
          \noLine
          \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
          \RightLabel{$cut$}
          \BinaryInfC{$\Gamma,\Theta\vdLS\forall x\,\psi,\Delta,\Xi$}
          \DisplayProof
          & \reecr{\nwarrow r\forall} &
          \AxiomC{$\mathlarger{\pi}$}
          \noLine
          \UnaryInfC{$\Gamma,\varphi\vdLS\psi[t/x],\Delta$}
          \AxiomC{$\mathlarger{\pi'}$}
          \noLine
          \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
          \RightLabel{$cut$}
          \BinaryInfC{$\Gamma,\Theta\vdLS\psi[t/x],\Delta,\Xi$}
          \RightLabel{$r\forall^\dagger$}
          \UnaryInfC{$\Gamma,\Theta\vdLS\forall x\,\psi,\Delta,\Xi$}
          \DisplayProof
        \end{array}
        \)
      }
    \end{center}
    qui demande de vérifier la condition $\dagger$. On ne sait pas,
    \latinexpr{a priori}, si $x$ est libre dans $\Theta,\Xi$, ce qui empêche
    de pouvoir appliquer cette réécriture. Néanmoins, on peut toujours
    renommer la variable $x$ de $\psi[t/x]$ pour obtenir $\psi[y/x][t/y]$
    et $y$ libre dans $\Theta,\Xi$, assurant ainsi à réécriture des variables
    libres près, que la réécriture est effectivement bien définie.
  \item dans le cas d'une réécriture avec $r\square^\ddagger$, cependant, on
    ne peut pas assurer de la même façon que la réécriture peut malgré tout
    s'effectuer. Dans un cas tel que
    \begin{center}
      \resizebox{0.8\textwidth}{!}{
        \(
        \begin{array}{ccc}
          \AxiomC{$\mathlarger{\pi}$}
          \noLine
          \UnaryInfC{$\Gamma,\varphi\vdLS\psi,\Delta$}
          \RightLabel{$r\square^\ddagger$}
          \UnaryInfC{$\Gamma,\varphi\vdLS\square\psi,\Delta$}
          \AxiomC{$\mathlarger{\pi'}$}
          \noLine
          \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
          \RightLabel{$cut$}
          \BinaryInfC{$\Gamma,\Theta\vdLS\square\psi,\Delta,\Xi$}
          \DisplayProof
          & \reecr{\nwarrow r\square} &
          \AxiomC{$\mathlarger{\pi}$}
          \noLine
          \UnaryInfC{$\Gamma,\varphi\vdLS\psi,\Delta$}
          \AxiomC{$\mathlarger{\pi'}$}
          \noLine
          \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
          \RightLabel{$cut$}
          \BinaryInfC{$\Gamma,\Theta\vdLS\psi,\Delta,\Xi$}
          \RightLabel{$r\square^\ddagger$}
          \UnaryInfC{$\Gamma,\Theta\vdLS\square\psi,\Delta,\Xi$}
          \DisplayProof
        \end{array}
        \)
      }
    \end{center}
    on ne peut pas considérer que $\Theta$ est constitué de formules avec la
    modalité $\square$, et que $\Xi$ est constitué de formules avec la
    modalité $\diamond$.
    La façon de corriger ce problème est de le contourner~: on
    sait dans un tel cas que la formule de coupure, $\varphi$, est de la forme
    $\square \varphi'$, puisqu'on a pu appliquer la règle $r\square^\ddagger$.
    Dans un tel cas, on verra qu'on peut appliquer une réécriture dans l'autre
    direction, $\reecr{\nearrow}$ s'appliquant alors. Pour cette réécriture
    symétrique, le problème se posant serait que la règle appliquée soit
    $l\diamond^\ddagger$ pour arriver au séquent $\Theta\vdLS\varphi,\Xi$, mais
    l'application d'une telle règle signifie que $\varphi$ est de la forme
    $\diamond \varphi'$, ce qui contredit le cas initial. On pourra donc
    toujours remonter la coupure, ce qui est suffisant pour notre objectif.
  \item dans le cas d'une égalité, le fait de supposer que l'arbre de droite est
    de la forme $\pi'[t/x]$ ne fait pas perdre de généralité. On peut s'assurer
    que lors d'une substitution d'une variable par un terme dans l'entièreté de
    l'arbre, tout se passe comme on s'y attend~: l'arbre est toujours un
    arbre de preuve, et le séquent conclusion voit toutes ses formules être
    substituées. Le fait de faire appraître $\pi'$ sous cette forme est alors
    directement dû au fait que dans sa conclusion, on puisse écrire
    $\varphi[t/x]$~: quitte à prendre une variable $x$ libre dans $\Theta$ et
    $\Xi$, on peut supposer que $\Theta = \Theta[t/x]$ et de même pour
    $\Xi$.
  \end{itemize}
\end{remark}

Comme attendu, cette réécriture peut se faire de façon parfaitement symétrique
en faisant monter une coupure dans le sous-arbre de droite. Les subtilités
évoquées pour $\reecr{\nwarrow}$ se retrouvent de façon symétrique dans ces
règles.

\begin{definition}[Relèvement d'une coupure vers la droite]
  On définit le relèvement de coupures vers la droite par les règles suivantes~:
  \begin{center}
    \resizebox{\textwidth}{!}{\(
      \begin{array}{ccc}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\Sigma^l\vdLS\Sigma^r,\varphi,\Xi$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\Theta,\Phi^l\vdLS\Phi^r,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLS\Delta,\Phi^r,\Xi$}
        \DisplayProof
        & \reecr{\nearrow\rOne} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta,\Sigma_l\vdLS\Sigma_r,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Sigma^l\vdLS\Delta,\Sigma^r,\Xi$}
        \RightLabel{$\rOne$}
        \UnaryInfC{$\Gamma,\Theta,\Phi^l\vdLS\Delta,\Phi^r\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1,\Sigma_1^l\vdLS\Sigma_1^r,\varphi,\Xi_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2,\Sigma_2^l\vdLS\Sigma_2^r,\Xi_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Theta_1,\Theta_2,\Phi^l\vdLS\varphi,
          \Phi^r,\Xi_1,\Xi_2$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2,\Phi^l\vdLS
          \Phi^r,\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        & \reecr{\nearrow \rTwo_1} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\varphi,\Gamma\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1,\Sigma_1^l\vdLS\Sigma_1^r\varphi,\Xi_1$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\Sigma_1^l\vdLS\Sigma_1^r,\Delta,\Xi_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2,\Sigma_2^l\vdLS\Sigma_2^r,\Xi_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2,\Phi^l\vdLS
          \Phi^r,\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1,\Sigma_1^l\vdLS\Sigma_1^r,\Xi_1$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2,\Sigma_2^l\vdLS\varphi,\Sigma_2^r,\Xi_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Theta_1,\Theta_2,\Phi^l\vdLS\varphi,
          \Phi^r,\Xi_1,\Xi_2$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2,\Phi^l\vdLS
          \Phi^r,\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        & \reecr{\nearrow \rTwo_2} &
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta_1,\Sigma_1^l\vdLS\Sigma_1^r,\Xi_1$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta_2,\Sigma_2^l\vdLS\varphi,\Sigma_2^r,\Xi_2$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta_2,\Sigma_2^l\vdLS\Sigma_2^r,\Xi_2$}
        \RightLabel{$\rTwo$}
        \BinaryInfC{$\Gamma,\Theta_1,\Theta_2,\Phi^l\vdLS
          \Phi^r,\Delta,\Xi_1,\Xi_2$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta\Sigma^l_1\vdLS\Sigma^r_1,\varphi,\Xi$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta,\Sigma^l_2\vdLS\Sigma^r_2,\varphi,\Xi$}
        \RightLabel{$\rTwoB$}
        \BinaryInfC{$\Theta,\Phi^l\vdLS\Phi^r,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLS\Delta,\Phi^r,\Xi$}
        \DisplayProof
        & \reecr{\nearrow\rTwoB} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_1}$}
        \noLine
        \UnaryInfC{$\Theta,\Sigma^l_1\vdLS\Sigma^r_1,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Sigma^l_1\vdLS \Sigma^r_1,\Delta,\Xi$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi_2}$}
        \noLine
        \UnaryInfC{$\Theta,\Sigma^l_2\vdLS\Sigma^r_2,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta,\Sigma^l_2\vdLS\Sigma^r_2,\Delta,\Xi$}
        \RightLabel{$\rTwoB$}
        \BinaryInfC{$\Gamma,\Theta,\Phi^l\vdLS\Phi^r,\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\varphi,\Xi$}
        \RightLabel{$rc$}
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{\nearrow c} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\varphi,\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\varphi,\Delta,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Gamma,\Theta\vdLS\Delta,\Delta,\Xi$}
        \doubleLine
        \RightLabel{$lc/rc$}
        \UnaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\Xi$}
        \RightLabel{$rw$}
        \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        & \reecr{\nearrow w} &
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta\vdLS\Xi$}
        \doubleLine
        \RightLabel{$lw/rw$}
        \UnaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
        \AxiomC{}
        \RightLabel{$ax$}
        \UnaryInfC{$\varphi\vdLS\varphi$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \DisplayProof
        & \reecr{\nearrow ax} &
        \AxiomC{$\mathlarger{\pi}$}
        \noLine
        \UnaryInfC{$\Gamma\vdLS\varphi,\Delta$}
        \DisplayProof
        \\
        \\
        \AxiomC{$\mathlarger{\pi[t/x]}$}
        \noLine
        \UnaryInfC{$\Gamma[t/x],\varphi[t/x]\vdLS\Delta[t/x]$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta[u/x]\vdLS\varphi[u/x]\Xi[u/x]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Theta[t/x],t=u\vdLS\varphi[t/x],\Xi[t/x]$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma[t/x],\Theta[t/x],t=u\vdLS\Delta[t/x],\Xi[t/x]$}
        \DisplayProof
        & \reecr{\nearrow =} &
        \AxiomC{$\mathlarger{\pi[u/x]}$}
        \noLine
        \UnaryInfC{$\Gamma[u/x],\varphi[u/x]\vdLS\Delta[u/x]$}
        \AxiomC{$\mathlarger{\pi'}$}
        \noLine
        \UnaryInfC{$\Theta[u/x]\vdLS\varphi[u/x],\Xi[u/x]$}
        \RightLabel{$cut$}
        \BinaryInfC{$\Gamma[u/x],\Theta[u/x]\vdLS\Delta[u/x],\Xi[u/x]$}
        \RightLabel{$l=$}
        \UnaryInfC{$\Gamma[t/x],\Theta[t/x],t=u\vdLS\Delta[t/x],\Xi[t/x]$}
        \DisplayProof
      \end{array}
      \)}
  \end{center}
  La réécriture $\reecr{\nearrow}$ est l'union de toutes les règles de
  réécriture précédentes.
\end{definition}

On peut alors prouver un premier lemme.

\begin{lemma}\label{lem.reecr.log}
  Soient deux preuves sans coupures
  $\bottomAlignProof
  \AxiomC{$\mathlarger{\pi}$}\noLine\UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
  \DisplayProof$
  et
  $\bottomAlignProof
  \AxiomC{$\mathlarger{\pi}$}\noLine\UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
  \DisplayProof$.
  Alors pour la preuve $\pi_0$ définie comme
  \begin{prooftree}
    \AxiomC{$\mathlarger{\pi}$}
    \noLine
    \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
    \AxiomC{$\mathlarger{\pi'}$}
    \noLine
    \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
    \RightLabel{$cut$}
    \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
  \end{prooftree}
  il existe une preuve $\pi_1$ telle que
  $\pi_0 {\reecr{\nwarrow}}^\star{\reecr{\nearrow}}^\star \pi_1$
  et $\pi_1$ ne contient que des coupures logiques de formule de coupure
  $\varphi$.
\end{lemma}

\begin{proof}
  Commençons par remarquer que~:
  \begin{itemize}
  \item si une coupure n'est pas $l$-logique, alors elle peut se réécrire par
    $\reecr{\nwarrow}$, et de façon symétrique si elle n'est pas $r$-logique
    alors elle peut se réécrire par $\reecr{\nearrow}$~;
  \item il suffit donc de prouver que le nombre d'étapes de réécriture par
    $\reecr{\nwarrow}$ (respectivement $\reecr{\nearrow}$, tous les arguments
    étant parfaitement symétriques) est fini, c'est-à-dire trouver une mesure
    qui décroît strictement quand on applique une telle réécriture.
  \end{itemize}

  On prouve donc qu'il n'y a qu'un nombre fini de réécritures
  $\reecr{\nwarrow}$ possibles depuis une coupure donnée. Notons $\varphi$
  la formule de coupure, on appelle $l$-occurrence de $\varphi$ dans un
  séquent les occurrence de $\varphi$ à gauche de $\vdLS$. Pour une preuve
  $\pi$ et une occurrence $S$ d'un séquent de $\pi$, on dit que $S$ est
  $l$-accessible si on peut atteindre $S$ depuis une prémisse gauche d'une
  coupure par un chemin ascendant dans $\pi$ (qu'on peut considérer comme une
  suite de sous-arbres de $\pi$ dont chaque élément est un sous-arbre immédiat
  du précédent, dont on considère les conclusions) tel que~:
  \begin{itemize}
  \item à chaque règle $cut$, le chemin choisit la prémisse gauche~;
  \item dans tout séquent du chemin, on a une $l$-occurrence de $\varphi$.
  \end{itemize}
  On peut alors vérifier que le nombre de $l$-occurrences de $\varphi$ dans
  les séquents $l$-accessibles est une mesure qui décroît strictement pour
  chaque application d'une règle $\reecr{\nwarrow}$.

  On en déduit qu'il est possible de choisir une suite maximale de réécritures
  pour $\reecr{\nwarrow}$, dont l'arbre résultat ne peut pas se réécrire par
  $\reecr{\nwarrow}$ ce qui implique qu'il est $l$-logique.

  On fait alors de même en prenant une suite maximale de réécritures pour
  $\reecr{\nearrow}$, ce qui nous permet d'obtenir un arbre dont toutes les
  coupures sont $r$-logiques. On vérifie que le résultat d'une
  réécriture $\reecr{\nearrow}$ sur une coupure $l$-logique donne toujours une
  coupure $l$-logique, puisque le sous-arbre gauche d'une coupure reste
  inchangé par $\reecr{\nearrow}$.
\end{proof}

Précisons qu'il est important de faire remonter les coupures d'un seul côté à la
fois, comme le montre l'exercice suivant.

\begin{exercise}
  Montrer que si on considère la règle de réécriture
  $\reecr{\nwarrow}\cup\reecr{\nearrow}$, alors on peut construire une
  suite infinie de réécritures.
\end{exercise}

On peut maintenant prouver le théorème d'élimination des coupures, à partir de
l'élimination des coupures logiques et du lemme précédent.

\begin{definition}
  On définit la relation $\reecr{}$ comme l'union des relations
  $\reecr{\nwarrow},\reecr{\nearrow},\reecr{log}$.
\end{definition}

\begin{theorem}[Hauptsatz - \'Elimination des coupures \cite{Gentzen1935}]
  \label{thm.cut.elim}
  Pour tout arbre $\pi \in \ProofLS$ de conclusion $\Gamma\vdLS\Delta$, il
  existe un arbre $\pi' \in \ProofLS$ tel que $\pi {\reecr{}}^\star \pi'$ et
  $\pi'$ ne contient aucune occurrence de la règle de coupure.
\end{theorem}

\begin{proof}
  Ce résultat se prouve, naturellement, par induction. Cependant, la valeur
  sur laquelle on effectue notre induction est importante.

  On va définir le degré d'une formule $\varphi$ et d'un arbre par~:
  \[\delta(\varphi) \defeq |\varphi| \qquad
  \delta(\pi) \defeq \max\{\delta(\varphi)\mid\varphi\text{ est une formule de
    coupure de }\pi\}\]
  On raisonne par induction sur $\delta(\pi)$.

  Soit $n \in \bN$. On suppose que pour tout arbre de preuve $\pi$ tel que
  $\delta(\pi) < n$, il existe un arbre $\pi'$ tel que $\pi \reecr{} \pi'$
  et $\pi'$ n'a pas de coupure.

  Soit $\varphi$ une formule telle que $\varphi = n$. Soient
  $\bottomAlignProof
  \AxiomC{$\mathlarger{\pi}$}\noLine\UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
  \DisplayProof$
  et
  $\bottomAlignProof
  \AxiomC{$\mathlarger{\pi}$}\noLine\UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
  \DisplayProof$
  deux arbres de preuve sans coupure. Montrons que l'arbre $\pi_0$ défini comme
  \begin{prooftree}
    \AxiomC{$\mathlarger{\pi}$}
    \noLine
    \UnaryInfC{$\Gamma,\varphi\vdLS\Delta$}
    \AxiomC{$\mathlarger{\pi'}$}
    \noLine
    \UnaryInfC{$\Theta\vdLS\varphi,\Xi$}
    \RightLabel{$cut$}
    \BinaryInfC{$\Gamma,\Theta\vdLS\Delta,\Xi$}
  \end{prooftree}
  peut se réécrire par $\reecr{}$ en un arbre sans coupure. D'après le
  \cref{lem.reecr.log}, on peut trouver $\pi_1$ tel que
  $\pi_0{\reecr{}}^\star \pi_1$ et toutes les coupures de $\pi_1$ sont logiques
  et de formule de coupure $\varphi$. On peut donc appliquer pour chaque
  coupure une réécriture $\reecr{log}$, puis appliquer notre hypothèse
  d'induction~: on trouve un arbre $\pi_2$ tel que
  $\pi_0 {\reecr{}}^\star \pi_2$ et $\pi_2$ ne possède aucune coupure.

  Pour un arbre $\pi$ quelconque, on peut désormais procéder à la construction
  précédente, mais en raisonnant par récurrence sur le nombre de coupure.
  S'il existe au moins une coupure, alors on peut choisir une coupure qui ne
  contient aucune coupure au-dessus d'elle, et on peut alors réécrire le
  sous-arbre donné par cette coupure en utilisant le résultat précédent. On
  en déduit donc que $\pi$ tout entier peut se réécrire par $\reecr{}$ en un
  arbre sans coupure.
\end{proof}

\begin{corollary}
  La règle $cut$ est admissible dans le système $\LS \setminus\{cut\}$.
\end{corollary}

\subsection{Conséquences du Hauptsatz}

Le théorème d'élimination des coupures que nous avons prouvé est
particulièrement modulaire. En effet, les réécritures étant définies localement,
il suffit de peu d'éléments pour éliminer les coupures~:
\begin{itemize}
\item si une règle est introduite dans le calcul des séquents, elle doit
  pouvoir commuter avec la coupure, de sorte qu'on puisse faire un relèvement.
  Notons que cette condition n'a besoin d'être respectée que d'une façon
  faible, puisque dans le cas de $r\square^\ddagger$, par exemple, il n'y a pas
  de commutation directe.
\item si une règles logique est introduite dans le calcul des séquents, elle
  doit exister en une version gauche et une version droite de telle sorte que
  la coupure faisant intervenir ces deux version peut se simplifier.
\end{itemize}
Avec ces deux conditions, on peut généralement écrire un théorème d'élimination
des coupures. En plus du peu de conditions pour écrire un système pour lequel on
peut s'attendre à prouver une version du \foreignexpr{Hauptsatz}, la preuve
en elle-même fonctionne encore sur tous les fragments du système pour lequel on
a prouvé notre théorème, pour peu que les fragments contiennent la règle
d'échange et les paires $l/r$ d'une règle logique voulue.

On a donc prouvé l'élimination des coupures pour $2^{14}$ fragments du système
$\LS$ ! \'Evidemment, l'écrasante majorité des fragments en question sont peu
pertinents, mais on peut relever plusieurs calculs dont l'élimination des
coupures est une conséquence directe, et qui sont intéressants.

\paragraph{La logique classique}
En choisissant un constructeur (et ses règles associées) entre chaque paire
$\lor/\parr$,$\land/\with$,$\to/\multimap$, et en supprimant les modalités
$\square,\diamond$, on obtient une des multiples présentations de $\LK$, dont
certaines déjà données plus tôt dans le chapitre. On a donc prouvé l'élimination
des coupures telle que donnée dans l'\cref{ax.cut.elim}.

\paragraph{La logique modale S4}
En autorisant les modalités $\square,\diamond$, on obtient l'élimination des
coupures pour la logique modale S4. La logique modale est une variante assez
large de la logique, dans laquelle on ajoute les deux modalités et certains
axiomes sur leur comportement. Dans le cas des règles qu'on a données, on peut
déduire les axiomes du système nommé S4, c'est-à-dire~:
\begin{align*}
  N &\defeq (\vdLS \varphi) \implies (\vdLS\square\varphi) \\
  K &\defeq \vdLS \square(\varphi \to \psi) \to \square \varphi \to
  \square\psi\\
  T &\defeq \vdLS \square\varphi \to \varphi\\
  4 &\defeq \vdLS \square\varphi\to\square\square\varphi
\end{align*}
On remarque que la règle $N$, la règle $K$ et la règle $4$ correspondent
respectivement aux $3$ conditions de Hilbert-Bernays données dans la
\cref{def.HB.cond}. Cela n'est pas choquant, dans la mesure où le prédicat
signifiant \og $\varphi$ est prouvable\fg évoque effectivement la nécessité de
$\varphi$, comme le traduit la logique modale par la modalité $\square$.

\paragraph{La logique linéaire}
On peut aussi considérer des logiques sous-structurelles. En analysant les
règles de réécritures, on s'aperçoit que les règles de relèvement ne modifient
pas toutes l'arbre global~: dans les relèvement des règles multiplicatives, il
y a précisément une occurrence de $\pi,\pi_1,\pi_2$ (cela se vérifie aussi pour
l'égalité). Cependant, le relèvement pour une règle additive multiplie l'un des
arbres, le relèvement des affaiblissements supprime un arbre et le relèvement
des contractions multiplie les arbres. Enfin au sein des règles logiques, les
règles additives suppriment un arbre, contrairement aux règles multiplicatives
qui gardent le même nombre d'occurrence des arbres.

Cette idée de multiplier ou non les arbres de preuves mène à la linéarité~: le
phénomène durant lequel chaque information est utilisée une et une seule fois
pour effectuer une construction. Ce phénomène motive la mise en avant du
fragment multiplicatif, et la construction d'un fragment de $\LS$ dans lequel
les contractions et les affaiblissements ne sont plus considérés comme des
opérations anodines. On appelle une telle logique \og sous-structurelle\fg
puisqu'elle repose sur un système où on affaiblit les règles structurelles.

La logique linéaire est alors le fragment obtenu en conservant tous les
connecteurs (les connecteurs $\lor$ et $\parr$ ne seront plus équivalents), et
en restreignant les règles $lc/rc$ et $lw/rw$ aux formules qui sont à la gauche
du séquent et de la forme $\square\varphi$, ainsi qu'aux formules qui sont à la
droite du séquent et de la forme $\diamond\varphi$.

On donne aussi une nouvelle syntaxe pour écrire les constructeurs~:
\begin{center}
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    $\LS$ & $\lnot(-)$&$\to$&$\multimap$&$\lor$&$\parr$&$\land$&$\with$&
    $\forall$&$\exists$&$\square$&$\diamond$ \\
    \hline
    $\LL$ & $(-)^\bot$& & $\multimap$&$\oplus$&$\parr$&$\otimes$&$\with$&
    $\forall$&$\exists$&$!$&$?$ \\
    \hline
  \end{tabular}
\end{center}
Notre théorème d'élimination des coupures s'applique encore parfaitement dans ce
cadre, où les formules affaiblies ou contractées sont toutes marquées comme
$!\varphi/?\varphi$ selon le côté du symbole $\vdLL$ où elles se trouvent.

On peut trouver des introductions à la logique linéaire dans
\cite{alma991002216619806616,girard_1989,GIRARD19871}.

\paragraph{La logique intuitionniste}
La logique intuitionniste, déjà présentée succinctement dans la
\cref{subsec.heyting.alg}, peut se représentée par le calcul des séquents. En
reprenant la preuve que $\LK$ vérifie la règle de raisonnement par l'absurde, on
voit qu'il est nécessaire d'accepter au moins deux formules dans le séquent de
droite. Si on n'autorise pas ce type de contexte à droite, donnant la symétrie
qu'on connait au calcul des séquents, on obtient alors un système qui ne
vérifie pas le raisonnement par l'absurde (ou, de façon équivalente, le tiers
exclu).

On appelle séquent intuitionniste un tel séquent, où au plus une formule
apparaît à droite.
Dans la preuve de l'élimination des coupures, toutes les réécritures
laissent inchangées le contexte de droite, de telle sorte que tout séquent
intuitionniste reste intuitionniste après réécriture.

Intéressons-nous maintenant à la logique intuitionniste plus en profondeur.

\section{Logique intuitionniste}\label{sec.LJ}

Puisque nous abordons la logique intuitionniste par le calcul des séquents,
commençons par définir le calcul des séquents intuitionniste.

\subsection{Calcul des séquents LJ}

\begin{definition}[Calcul des séquents $\LJ$ \cite{Gentzen1935}]
  On définit l'ensemble $\ProofLJ$ des arbres de preuve pour le calcul des
  séquents $\LJ$ par les règles de la \cref{tbl.LJ}. La notation $[\varphi]$
  signifie que la liste contient la formule $\varphi$ ou est vide. Comme
  pour les autres calculs des séquents, les règles marquées d'un $\dagger$
  demandent que la variable $x$ soit libre dans les autres formules du séquent.
\end{definition}

\begin{table}[t!]
  \centering
  %\hrule
  %\resizebox{\textwidth}{!}{
    \begin{tabular}{cc}
      \multicolumn{2}{l}{Axiome et coupure :}
      \\
      \AxiomC{}
      \RightLabel{\textit{ax}}
      \UnaryInfC{$\varphi\vdLJ \varphi$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLJ \varphi$}
      \AxiomC{$\Delta, \varphi \vdLJ [\psi]$}
      \RightLabel{\textit{cut}}
      \BinaryInfC{$\Gamma, \Delta\vdLJ [\psi]$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles structurelles :}
      \\
      \AxiomC{$\Gamma,\varphi,\varphi\vdLJ[\psi]$}
      \RightLabel{\textit{lc}}
      \UnaryInfC{$\Gamma,\varphi\vdLJ[\psi]$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi,\psi,\Gamma'\vdLJ[\psi]$}
      \RightLabel{\textit{le}}
      \UnaryInfC{$\Gamma,\psi,\varphi,\Gamma'\vdLJ[\psi]$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma \vdLJ [\psi]$}
      \RightLabel{\textit{lw}}
      \UnaryInfC{$\Gamma, \varphi \vdLJ [\psi]$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLJ$}
      \RightLabel{\textit{rw}}
      \UnaryInfC{$\Gamma\vdLJ \varphi$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{l}{Règles logiques :}
      \\
      \AxiomC{$\Gamma\vdLJ \varphi$}
      \RightLabel{$l\lnot$}
      \UnaryInfC{$\Gamma, \lnot\varphi \vdLJ$}
      \DisplayProof
      &
      \AxiomC{$\Gamma, \varphi\vdLJ$}
      \RightLabel{$r\lnot$}
      \UnaryInfC{$\Gamma\vdLJ \lnot\varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLJ[\chi]$}
      \AxiomC{$\Gamma,\psi\vdLJ[\chi]$}
      \RightLabel{$l\lor$}
      \BinaryInfC{$\Gamma,\varphi\lor\psi\vdLJ[\chi]$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLJ\varphi$}
      \RightLabel{$r\lor_1$}
      \UnaryInfC{$\Gamma\vdLJ \varphi\lor\psi$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma\vdLJ\psi$}
      \RightLabel{$r\lor_2$}
      \UnaryInfC{$\Gamma\vdLJ\varphi\lor\psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma,\varphi\vdLJ[\chi]$}
      \RightLabel{$l\land_1$}
      \UnaryInfC{$\Gamma,\varphi\land\psi\vdLJ[\chi]$}
      \DisplayProof
      \quad
      \AxiomC{$\Gamma,\psi\vdLJ[\chi]$}
      \RightLabel{$l\land_2$}
      \UnaryInfC{$\Gamma,\varphi\land\psi\vdLJ[\chi]$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLJ \varphi$}
      \AxiomC{$\Gamma\vdLJ \psi$}
      \RightLabel{$r\land$}
      \BinaryInfC{$\Gamma\vdLJ \varphi\land\psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma\vdLJ\varphi$}
      \AxiomC{$\Gamma,\psi\vdLJ[\chi]$}
      \RightLabel{$l\to$}
      \BinaryInfC{$\Gamma,\varphi\to\psi\vdLJ[\chi]$}
      \DisplayProof
      &
      \AxiomC{$\Gamma,\varphi\vdLJ\psi$}
      \RightLabel{$r\to$}
      \UnaryInfC{$\Gamma\vdLJ\varphi\to\psi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi[t/x] \vdLJ[\psi]$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma, \forall x, \varphi \vdLJ[\psi]$}
      \DisplayProof
      &
      \AxiomC{$\Gamma\vdLJ \varphi$}
      \RightLabel{$r\forall^\dagger$}
      \UnaryInfC{$\Gamma \vdLJ \forall x\, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma, \varphi \vdLJ[\psi]$}
      \RightLabel{$l\exists^\dagger$}
      \UnaryInfC{$\Gamma, \exists x, \varphi \vdLJ[\psi]$}
      \DisplayProof
      &
      \AxiomC{$\Gamma \vdLJ \varphi[t/x]$}
      \RightLabel{$r\exists$}
      \UnaryInfC{$\Gamma \vdLJ \exists x\, \varphi$}
      \DisplayProof
      \\
      \\
      \AxiomC{$\Gamma[u / x] \vdLJ [\varphi[u / x]]$}
      \RightLabel{$l=$}
      \UnaryInfC{$\Gamma[t / x], t = u \vdLJ [\varphi[t / x]]$}
      \DisplayProof
      &
      \AxiomC{}
      \RightLabel{$r=$}
      \UnaryInfC{$\vdLJ t = t$}
      \DisplayProof
    \end{tabular}
    %}

  \vspace{0.2cm}
  \hrule

  \vspace{0.2cm}
  \caption{Règles de $\LJ$}
  \label{tbl.LJ}

  \hrule
\end{table}

La présentation donnée ici de $\LJ$ est une présentation vers le haut,
optimisée pour la recherche de preuve. Combinée au \cref{thm.cut.elim}, elle
permet de prouver efficacement qu'un séquent n'est pas prouvable en logique
intuitionniste.

\begin{example}
  Montrons que l'une des lois de De Morgan n'est pas prouvable en logique
  intuitionniste~:
  \[\nvdLJ \lnot (\varphi \land \psi) \to \lnot \varphi \lor \lnot \psi\]
  Pour cela, on suppose qu'on a un arbre sans coupure dont la conclusion est
  $\vdLJ\lnot(\varphi\land\psi)\to\lnot\varphi\lor\lnot\psi$. On raisonne alors
  sur les règles qui se situent au-dessus de ce séquent. Il ne peut pas y
  avoir de règle structurelle~: $lc$, $le$ et $lw$ sont inapplicables par
  absence de formules à gauche, et $rw$ signifierait que $\vdLJ$ est
  prouvable, ce qu'on a déjà montré comme impossible. Il reste donc une
  règle logique à appliquer, qui est $r\to$.
  On a ainsi à prouver $\lnot(\varphi\land\psi)\vdLJ\lnot\varphi\lor\lnot\psi$.
  Là encore, appliquer une règle structurelle ne changerait rien~:
  l'échange ou la contraction ne permettent pas de faire avancer la preuve
  (on peut supposer qu'on en fait un certain nombre, et on regarder alors le
  séquent $[\lnot(\varphi\land\psi)]^n\vdLJ\lnot\varphi\lor\lnot\psi$). On
  doit donc appliquer une règle logique. La règle $l\lnot$ ne peut pas
  s'appliquer s'il existe déjà une règle à droite, donc les seules règles
  possibles sont $r\lor_1$ et $r\lor_2$.

  On en déduit donc que, si
  $\lnot(\varphi\land\psi)\vdLJ\lnot\varphi\lor\lnot\psi$ est prouvable, alors
  $\lnot(\varphi\land\psi)\vdLJ\lnot\varphi$ est prouvable, ou
  $\lnot(\varphi\land\psi)\vdLJ\lnot\psi$ est prouvable. Cependant, ces
  deux séquents ne sont pas prouvables, puisqu'ils sont faux même en
  logique classique. On en déduit
  \[\nvdLJ \lnot (\varphi \land \psi) \to \lnot \varphi \lor \lnot \psi\]
\end{example}

Dans cette preuve, l'argument central est le fait que si
$\vdLJ\varphi\lor\psi$ est prouvable, alors il faut avoir appliqué l'une des
deux règles $r\lor_1$ ou $r\lor_2$, qui forcent la prouvabilité de
$\vdLJ\varphi$ ou de $\vdLJ\psi$. On peut l'exprimer par la propriété de la
disjonction.

\begin{property}[Disjonction]
  Le calcul $\LJ$ a la propriété de la disjonction, ce qui signifie que si
  $\vdLJ\varphi \lor \psi$, alors $\vdLJ\varphi$ ou $\vdLJ\psi$.
\end{property}

\begin{proof}
  Comme dit précédemment, les seules règles pouvant être appliquée dans un arbre
  sans coupure et dont la conclusion est $\vdLJ\varphi\lor\psi$ sont
  $r\lor_1$ et $r\lor_2$, donnant respectivement que $\vdLJ\varphi$ et que
  $\vdLJ\psi$ sont prouvables.
\end{proof}

Comme le quantificateur $\exists$ peut s'interpréter comme une version plus
générale de la disjonction (portant sur les objets et non sur deux formules),
c'est sans surprise que $\vdLJ$ vérifie une propriété analogue pour la
quantification existentielle.

\begin{property}[Témoin]
  Le calcul $\LJ$ a la propriété du témoin, ce qui signifie que si
  $\vdLJ\exists x,\varphi$, alors il existe un terme $t$ tel que
  $\vdLS\varphi[t/x]$.
\end{property}

\begin{proof}
  Si $\vdLJ\exists x, \varphi$ est prouvable, alors il existe un arbre de
  preuve de $\LJ$ sans coupure dont la conclusion est ce séquent. La dernière
  règle ne peut alors être que $r\exists$, d'où le résultat.
\end{proof}

La propriété du témoin est un renforcement notable du \cref{thm.Herbrand},
puisqu'on remplace un ensemble fini de termes en un seul terme. Remarquons que
la preuve de la propriété du témoin est bien plus directe (sous réserve d'avoir
prouvé l'élimination des coupures), puisqu'elle ne nécessite pas de réécrire les
arbres de preuve pour avoir le théorème du séquent du milieu. Cela est dû au
fait qu'il n'y a qu'une seule règle à analyser~: le témoin est introduit dès
la règle précédent la conclusion, alors que dans le cas classique il est
possible de faire des contractions pour multiplier $\exists x,\varphi$ puis,
depuis ces multiples exemplaires, de raisonner sur certains exemplaires avant
d'en multiplier d'autres. Le théorème du séquent du milieu, et la réécriture qui
y mène, permettent de regrouper toutes les règles quantitatives d'abord,
permettant de raisonner comme si les seules règles applicables sont les
règles quantifitatives.

Ces propriétés sont particulièrement fortes, puisqu'elles donnent à la
quantification existentielle une valeur de témoin explicite. Cependant, ces
deux propriétés ne se généralisent pas en présence d'un contexte gauche, et
donc lorsqu'on raisonne dans une théorie.

\begin{exercise}
  Montrer qu'il existe un séquent qui est prouvable dans $\LJ$, dont la
  conclusion est de la forme $\Gamma\vdLJ\varphi\lor \psi$, et tel que
  ni $\Gamma\vdLJ\varphi$ ni $\Gamma\vdLJ\psi$ ne sont prouvables.
  Faire de même pour $\exists x, \varphi$.
\end{exercise}

En l'état, notre système de preuve $\LJ$ a donc de bonnes propriétés uniquement
pour prouver des résultats généraux, qui sont des tautologies intuitionnistes
absolues. On peut alors chercher à construire des systèmes de preuves plus
spécialisés, dans lesquels on définit des règles supplémentaires pour éviter
de recourir à des axiomes, et ainsi garder les propriétés de disjonction et du
témoin. C'est en partie ce que construisent les théories des types.

Nous nous tournons maintenant vers un problème important~: quelle est la
sémantique d'une formule dans la logique intuitionniste ? Une première approche
est celle des algèbres de Lindenbaum-Tarski, en prenant l'ensemble décrit dans
l'\cref{exo.LinTar.LJ}. On peut ainsi considérer que, de la même façon qu'une
algèbre de Boole correspond à une structure logique valide pour la logique
classique, une algèbre de Heyting correspond à une structure logique valide
pour la logique intuitionniste.

La limitation de cette approche est l'absence d'une vraie notion de modèle,
telle que développée en théorie des modèles. \'Etant donnée une signature
$\Sigma$, une $\Sigma$-structure n'interprètera jamais que la logique classique,
étant donné que tout structure vérifie une proposition ou sa négation.

On cherche donc un moyen de construire des structures dont la sémantique
naturelle corresponde à la logique intuitionniste, c'est-à-dire qu'étant donné
un tel modèle $\mathcal M$, on souhaite que l'ensemble des formules $\varphi$
telles que $\mathcal M\models \varphi$ soit une algèbre de Heyting, et non
forcément une algèbre de Boole.

\subsection{Sémantique et modèles de Kripke}

L'obstacle majeur à contourner est le fait qu'une structure induise toujours une
théorie complète. Cependant, une théorie logique est, \latinexpr{a priori},
une théorie incomplète. Dans un tel cas, le lien entre les deux est qu'une
théorie $\mathcal T$ induit un ensemble de théories complètes,
$\ext(\mathcal T)$, qui correspond à l'ensemble des théories induites par les
modèles de $\mathcal T$. Ainsi, le candidat naturel pour réduire une théorie
complète est de considérer des ensembles de structures.

On considère donc un ensemble $\mathcal S$ de structures, dont on souhaite
construire une interprétation. Une façon naïve de procéder est de considérer
l'ensemble des formules qui sont valides dans l'ensemble des structures de
$\mathcal S$. On obtient alors à nouveau la théorie $\mathcal T$, mais cette
théorie est encore classique. En effet, l'énoncé $\varphi\lor\lnot\varphi$ est
vérifie dans toutes les structures, et nous sommes donc toujours dans le monde
de la logique classique.

On souhaite donc raffiner notre modèle~: plutôt que de considérer une famille de
structures, on va considérer une méta-structure reliant les structures. On va
définir des structures liées ou non à d'autres, de sorte que la satisfaction
pour une structure donnée puisse se considérer à l'aune des autres structures.
En un sens, on transforme la partie locale de notre satisfaction, de sorte que
\og satisfaire $\varphi$ dans $\mathcal M$ \fg ait un sens différent, qui prend
en compte la satisfaction de $\varphi$ dans d'autres structures. On définit
ainsi un cadre de Kripke.

\begin{definition}[Cadre de Kripke]
  Un cadre de Kripke est une paire $(W,R)$ où $R$ est une relation binaire sur
  $W$. On appelle monde un élément $w \in W$. On dira que $w'$ est un futur
  de $w$ si $wRw'$.
\end{definition}

L'intérêt d'un cadre de Kripke est de fixer la relation de dépendance des
structures qu'on va considérer. Un structure de Kripke va alors consister en la
donnée, pour chaque monde, d'une $\Sigma$-structure comme on en a l'habitude.
La relation $R$ sera, elle, représentée par un morphisme de structures.

\begin{definition}[Structure de Kripke]
  Soit $\Sigma$ une signature du premier ordre.
  Une $\Sigma$-structure de Kripke est la donnée d'un cadre de Kripke $(W,R)$
  ainsi que, pour chaque monde $w \in W$, d'une $\Sigma$-structure
  $\mathcal M_w$ et, pour tous $wRw'$, d'un morphisme de $\Sigma$-structures
  $f_{w,w'} : \mathcal M_w \to \mathcal M_{w'}$ tel que si
  $wRw', w'Rw''$ et $wRw''$ alors
  $f_{w',w''}\circ f_{w,w'} = f_{w,w''}$ et si $wRw$ alors
  $f_{w,w} = \id_{\mathcal M_w}$.
\end{definition}

\begin{notation}
  On notera dorénavant les structures de kripke par $\mathcal K$, où la
  structure du monde $w$ sera notée $\mathcal K_w$ et le morphisme de $w$ à
  $w'$ sera noté $\mathcal K_{w,w'}$.
\end{notation}

\begin{remark}
  Le lecteur ayant un bagage en théorie des catégories peut faire un parallèle
  avec la notion de foncteur. Dans le cas où $(W,R)$ est un pré-ordre, une
  $\Sigma$-structure de Kripke sur $(W,R)$ est exactement un foncteur de ce
  pré-ordre vu comme une catégorie, dans la catégorie des $\Sigma$-structures.
\end{remark}

De cette façon, on peut définir localement, en un monde $w$, la structure
$\mathcal M_w$ correspondante. On peut aussi, depuis ce monde, considérer tous
les mondes futurs de ce monde, et les examiner.

Pour interpréter ces opérations sur les mondes, on peut utiliser la logique
modale. En donnant un aspect temporel aux modalités, la possibilité s'interprète
comme l'existence d'un monde futur où une propriété est vérifiée, et la
nécessité s'interprète comme le fait que la propriété est vérifiée pour tout
monde futur.

\begin{definition}[Logique modale]
  On définit l'ensemble $\FormMod(\Sigma)$ des formules de logique modale sur
  une signature $\Sigma$ par
  \[\varphi,\psi \Coloneq a\mid \top\mid\bot\mid\lnot\varphi\mid\varphi\lor\psi
  \mid\varphi\land\psi\mid\varphi\to\psi\mid\forall x,\varphi\mid
  \exists x, \varphi\mid \square\varphi\mid\diamond\varphi\]
  où $a \in \Atom(\Sigma)$ et $x \in \Var$.
\end{definition}

\begin{definition}[Satisfaction dans une structure de Kripke]
  Soit $\Sigma$ une signature du premier ordre.
  Soit $\mathcal K$ une $\Sigma$-structure de Kripke sur un cadre $(W,R)$,
  $\varphi \in \FormMod(\Sigma)$ et $\rho$ un environnement du premier ordre
  contenant les variables libres de $\varphi$. Pour tout $w \in W$, on
  définit la relation de satisfaction, encore appelée la relation de forcing,
  notée $w,\rho\Vdash \varphi$, par induction sur $\varphi$~:
  \begin{itemize}
  \item si $\varphi = R(t_1,\ldots,t_n)$ où $R$ est un symbole de relation
    d'arité $n$, alors
    \[w,\rho\Vdash\varphi \defeq
    (\rho(t_1),\ldots,\rho(t_n)) \in R^{\mathcal K_w}\]
  \item si $\varphi = \top$, alors $w,\rho\Vdash \varphi$ est toujours vérifiée
  \item si $\varphi = \bot$, alors $w,\rho\Vdash \varphi$ n'est jamais vérifiée
  \item si $\varphi = \lnot \psi$, alors
    $w,\rho\Vdash\varphi \defeq w,\rho\nVdash\psi$
  \item si $\varphi = \psi \lor \chi$, alors
    $w,\rho\Vdash\varphi \defeq (w,\rho\Vdash \psi)\lor(w,\rho\Vdash\chi)$
  \item si $\varphi = \psi \land \chi$, alors
    $w,\rho\Vdash\varphi \defeq (w,\rho\Vdash \psi)\land(w,\rho\Vdash\chi)$
  \item si $\varphi = \psi \to \chi$, alors
    $w,\rho\Vdash\varphi \defeq (w,\rho\Vdash \psi)\implies(w,\rho\Vdash\chi)$
  \item si $\varphi = \forall x, \psi$, alors
    $w,\rho\Vdash\varphi \defeq \forall k \in |\mathcal K_w|,
    w,\rho[x \mapsto k]\Vdash \psi$
  \item si $\varphi = \exists x, \psi$, alors
    $w,\rho\Vdash\varphi \defeq \exists k \in |\mathcal K_w|,
    w,\rho[x \mapsto k]\Vdash \psi$
  \item si $\varphi = \square \psi$, alors
    $w,\rho\Vdash\varphi \defeq \forall w' \in W, wRw' \implies
    w',\mathcal K_{w,w'}(\rho)\Vdash\psi$
  \item si $\varphi = \diamond \psi$, alors
    $w,\rho\Vdash\varphi \defeq \exists w' \in W, wRw' \land
    (w',\mathcal K_{w,w'}\rho\Vdash\psi)$
  \end{itemize}
  Dans le cas où $\varphi$ est une formule close, on note
  $w\Vdash\varphi$ directement.

  On définit le fait que $\mathcal K$ satisfait $\varphi$ par
  \[\mathcal K\models \varphi \defeq \forall w \in W, w\Vdash \varphi\]
\end{definition}

Cette notion de satisfaction de formule est plus fine, puisqu'elle permet de
conditionner l'évaluation d'une formule à son évaluation dans les mondes
futurs.

Remarquons que l'aspect modal des formules ne dépend que de la forme du cadre
dans lequel on définit une structure. De plus, on souhaite que certains schémas
d'axiomes soient vérifiés, pour spécifier des versions plus fortes de la
logique modale. On a déjà vu les axiomes définissant le système $S4$, et on va
donc en donner un pendant sémantique.

\begin{proposition}[Règle $N$ et axiome $K$]
  Pour toute formule $\varphi$, si dans une $\Sigma$-structure de Kripke
  $\mathcal K$, $\mathcal K \models \varphi$, alors
  $\mathcal K \models \square\varphi$.
  De plus,
  $\mathcal K \models \square(\varphi \to \psi) \to
  \square \varphi \to \square\psi$.
\end{proposition}

\begin{proof}
  Si $\mathcal K \models \varphi$, alors on sait que pour tout
  $w \in W_{\mathcal K}$, $w\Vdash\varphi$. Mais alors, pour tous
  $w,w'\in W_{\mathcal K}$ tels que $wRw'$, on sait que $w'\Vdash\varphi$,
  donc $w\Vdash\square\varphi$. D'où $\mathcal K \models\square\varphi$.

  Pour montrer que l'axiome $K$ est vérifié, on considère
  $w \in W_{\mathcal K}$ tel que $w\Vdash\square(\varphi\to\psi)$ et
  $w\Vdash\square \varphi$. Alors, par définition, pour tout $w'$ tel que
  $wRw'$, $w'\Vdash\varphi \to \psi$ et $w'\Vdash\varphi$, donc
  $w'\Vdash\psi$. Ainsi, $w\Vdash\square\psi$, d'où le résultat.
\end{proof}

On voit donc que la règle $N$ et l'axiome $K$ sont, quoi qu'il arrive,
vérifiés dans la sémantique des modèles de Kripke. Avec notre calcul des
séquents $S4$, on vérifie aussi l'axiome $T$ et l'axiome $4$. Ces deux
conditions ne sont, elles, pas respectées par n'importe quelle structure de
Kripke. Cependant, deux conditions simples sur les cadres sont équivalents à ces
axiomes.

\begin{proposition}
  Soit $(W,R)$ un cadre de Kripke. Une structure de Kripke sur $(W,R)$ vérifie
  l'axiome $T$ si $R$ est une relation réflexive, et vérifie
  l'axiome $4$ si $R$ est une relation transitive.
\end{proposition}

\begin{proof}
  Pour un monde $w \in W$, si $wRw$ et $w\Vdash\square\varphi$, alors
  $w\Vdash\varphi$ par définition de la sémantique de $\square$. Ainsi, si
  $R$ est transitive, pour tout $w \in W$ et formule $\varphi$,
  $w\Vdash\square\varphi\to\varphi$.

  Supposons $R$ transitive, et soit $w \in W$. Si $w \Vdash \square\varphi$, on
  en déduit donc que pour tout $w'$ tel que $wRw', w'\Vdash\varphi$. Mais
  pour tout $w'$ tel que $wRw'$,
  comme $R$ est transitive, on en déduit que pour tout $w'$ tel que $w'Rw''$,
  $wRw''$. Cela signifie que $w'\Vdash\square\varphi$, d'où
  $w\Vdash\square\square\varphi$, donc
  $w\Vdash\square\varphi\to\square\square\varphi$.
\end{proof}

\begin{corollary}
  Soit $(W,\leq)$ un ensemble pré-ordonné. Toute structure de Kripke sur
  $(W,\leq)$ est correcte vis à vis du fragment $S4$.
\end{corollary}

\begin{proof}
  On se propose d'en donner une preuve plus directe, en considérant directement
  les règles du calcul des séquents. On ne travaille qu'avec les règles pour
  $\square$, les deux autres étant symétriques. Pour la preuve par induction,
  on veut montrer que si $\Gamma\vdLS\Delta$ et que $\mathcal K$ est une
  structure de Kripke sur un pré-ordre qui vérifie
  $\bigwedge\Gamma$, alors il satisfait $\bigvee \Delta$. On notera plus
  simplement $\mathcal K \models\Gamma$ pour $\mathcal K\models\bigwedge\Gamma$.

  \begin{itemize}
  \item cas $l\square$~: on suppose que
    $\mathcal K \models \Gamma,\square\varphi$ et notre hypothèse d'induction
    est que pour tout $\mathcal K'$ tel que $\mathcal K' \models\Gamma,\varphi$,
    $\bigvee\Delta$ est satisfaite dans $\mathcal K'$.
    Alors, pour tout $w \in \mathcal K$, on sait que
    $w\Vdash\Gamma,\square\varphi$, mais alors
    $w\Vdash\Gamma,\varphi$ car $w\leq w$, donc
    $\mathcal K \models \Gamma,\varphi$, d'où le résultat par hypothèse
    d'induction.
  \item cas $r\square^\ddagger$~: on suppose que
    $\mathcal K \models \Gamma$ et que toutes les formules de
    $\Gamma$ sont de la forme $\square \psi$. Par hypothèse d'induction,
    comme $\mathcal K \models \Gamma$, on sait que
    $\mathcal K\models \varphi\lor\bigvee\Delta$. $\Delta$ est supposée de la
    forme $\diamond \psi$ pour toute formule $\psi$ dans $\Delta$.

    Soit $w \in W$, on sait donc que $w\Vdash \varphi$ ou que
    $w\Vdash \bigvee\Delta$. Si $w\Vdash\bigvee\Delta$, alors on en
    déduit que $w\Vdash\square\varphi\lor\bigvee\Delta$, comme attendu.
    Sinon, montrons que $w\Vdash\square\varphi\lor\bigvee\Delta$.
    Pour tout $w'$ tel que $w\leq w'$, on sait que $w'\Vdash\Gamma$ car les
    formules de $\Gamma$ sont de la forme $\square\psi$, donc que
    $w'\Vdash\varphi\lor\bigvee\Delta$. On procède alors par disjonction de cas.

    S'il existe $w'$ tel que $w'\Vdash\diamond\psi$, où $\diamond\psi$ est une
    formule de $\Delta$, alors on en déduit qu'il existe $w''$ tel que
    $w'\leq w''$ et $w''\Vdash \psi$, mais alors $wRw''$ par transitivité de
    $\leq$, et donc $w\Vdash\diamond \psi$. Ainsi,
    $w\Vdash\varphi\lor\bigvee\Delta$.

    Si pour tout $w'$, $w'\Vdash\varphi$, alors on sait que
    $w\Vdash\square\varphi$.

    On a ainsi montré que pour tout $w\in W$,
    $w\Vdash\square\varphi\lor\bigvee\Delta$.
  \end{itemize}
  On en déduit par induction (les autres cas étant identiques aux cas d'une
  structure pour la logique classique) que $\vdLS$ est correct pour toute
  structure de Kripke sur un pré-ordre.
\end{proof}

La réciproque est, elle aussi, vraie~: la classe des structures de Kripke sur
des pré-ordres donne une sémantique complète vis à vis du fragment $S4$,
c'est-à-dire que toute formule vraie dans toute structure de Kripke sur
un pré-ordre, est prouvable dans $S4$.

\begin{theorem}[Complétude des pré-ordres pour $S4$]
  Soit $\Gamma\vdash\Delta$ un séquent pour la logique modale $S4$. Si pour
  toute structure $\mathcal K$ sur un pré-ordre,
  $\mathcal K\models \bigwedge\Gamma \to \bigvee\Delta$, alors
  $\Gamma\vdLS\Delta$.
\end{theorem}

\begin{proof}
  On remarque que, puisque $\Gamma\vdLS\Delta$ est prouvable si et seulement si
  $\vdLS\bigwedge\Gamma\to\bigvee\Delta$ est prouvable, il suffit de montrer que
  pour toute formule $\varphi$, si $\varphi$ est vraie dans tout modèle de
  Kripke sur un pré-ordre alors $\vdLS\varphi$. On souhaite donc montrer ce
  résultat.
  
  La première étape de la preuve est de construire un modèle syntaxique lié à
  la logique modale. Pour cela, on fixe d'abord, à partir de la signature
  $\Sigma$ de départ, une signature $\Sigma^+$ enrichie avec des témoins de
  Henkin, et une théorie $\mathcal T_0$ contenant tous les énoncés de la forme
  $\exists x,\varphi \to \varphi[c_\varphi/x]$, de sorte que toute théorie
  contenant $\mathcal T_0$ a la propriété de Henkin.

  On dira qu'une théorie $\mathcal T \subseteq\Prop(\Sigma^+)$ est saturée si
  $\mathcal T\supseteq\mathcal T_0$, pour tout symboles de relation
  $R$ d'arité $n$ et tous termes $t_1,\ldots,t_n$, si
  $\mathcal T \vdLS R(t_1,\ldots,t_n)$ alors
  $\mathcal T\vdLS\square R(t_1,\ldots,t_n)$, et si
  $\mathcal T$ est complète. On va noter
  $\satur$ l'ensemble des théories saturées sur $\Sigma^+$. Remarquons que
  $\mathcal T \vdLS\varphi \iff \varphi \in T$, étant donné que
  $\mathcal T$ est complète (et contient donc soit une formule, soit sa
  négation).

  On définit la relation de monde futur par
  \[\mathcal T \leq \mathcal T' \defeq
  \forall \varphi \in \Formula(\Sigma^+), \mathcal T \vdLS\square\varphi
  \implies \mathcal T'\vdLS\varphi\]
  et on a ainsi un cadre de Kripke $(\satur,\leq)$. La réflexivité est due au
  fait que $\square\varphi\implies \varphi$, et la transitivité est due au
  fait que $\square\varphi\implies\square\square\varphi$.

  On définit maintenant les structures. \'Etant donné un monde $\mathcal T$,
  on définit le modèle syntaxique de $\mathcal T$ comme l'ensemble des
  termes clos sur $\Sigma^+$, quotienté par la relation d'équivalence
  \[t\sim u \defeq \mathcal T \vdLS t = u\]
  \'Etant donné un autre monde $\mathcal T' \geq \mathcal T$, le morphisme
  $f_{\mathcal T,\mathcal T'}$ est défini comme associant
  la classe d'un terme $t$ à la classe de ce même terme. On vérifie que cette
  fonction est bien définie~:

  Si $t = u$ dans $\mathcal T$, on veut vérifier que $t = u$ dans $\mathcal T'$.
  On peut prouver que $\vdLS x = y \to \square (x = y)$ comme suit~:
  \begin{quote}
    puisque $\varphi\vdLS\varphi$, alors
    $\square (x = y) \vdLS \square (x = y)$, donc
    $x = y,\square(x = x) \vdLS\square(x=y)$, d'où
    $\square(x=x)\vdLS x = y \to \square(x=y)$, et puisque
    $\vdLS x = x$, par nécessitation puis coupure,
    $\vdLS x = y \to \square(x=y)$.
  \end{quote}
  on en déduit donc, comme $\mathcal T \leq \mathcal T'$ et
  $\square(t = u)$ est vrai dans $\mathcal T$, que $t = u$ dans $\mathcal T'$.

  Si $R(t_1,\ldots,t_n)$ est vrai dans $\mathcal T$, alors par saturation
  $\square R(t_1,\ldots,t_n)$ est vrai aussi dans $\mathcal T$, donc
  $R(t_1,\ldots,t_n)$ est vrai dans $\mathcal T'$. On a donc bien un morphisme
  de $\mathcal T$ vers $\mathcal T'$.

  Il nous suffit maintenant de montrer que pour toute théorie
  $\mathcal T \in \satur$ et toute formule $\varphi$,
  $\varphi \in \mathcal T \iff \mathcal T\Vdash \varphi$. En négligeant les
  environnements d'interprétation, on procède par induction sur $\varphi$~:
  \begin{itemize}
  \item si $\varphi$ est de la forme $\top/\bot$, le résultat est direct~;
  \item si $\varphi$ est de la forme $R(t_1,\ldots,t_n)$, alors le résultat est
    donné par la définition de l'interprétation de $R$ dans le monde de
    $\mathcal T$~;
  \item si $\varphi$ est de la forme $\lnot\psi$, alors
    \[\varphi \in \mathcal T \iff \psi\notin\mathcal T \iff
    \lnot\psi\in\mathcal T \iff \mathcal T \Vdash \lnot\psi\]
    en utilisant le fait que la théorie $\mathcal T$ est complète~;
  \item si $\varphi$ est de la forme $\psi \lor \chi$, alors
    \[\varphi \in \mathcal T \iff \psi \lor \chi \in \mathcal T \iff
    (\psi \in \mathcal T) \lor (\chi \in \mathcal T) \iff
    \mathcal T\Vdash \psi\lor\chi\]
    en utilisant le fait que la théorie $\mathcal T$ est complète (donc un
    filtre premier)~;
  \item les cas de $\land$ et $\to$ se déduisent de $\lor,\lnot$ et des lois
    de De Morgan~;
  \item de même, $\diamond$ et $\forall$ se déduisent respectivement de
    $\square$ et de $\exists$ par les lois de De Morgan et la négation~;
  \item si $\varphi$ est de la forme $\exists x, \psi$, alors on peut
    trouver un témoin de Henkin $t$ tel que $\exists x, \psi \in \mathcal T$
    est équivalent à $\psi[t/x]\in\mathcal T$, et l'hypothèse d'induction
    permet de conclure une fois appliquée à $\psi[t/x]$~;
  \item si $\varphi$ est de la forme $\square\psi$, alors
    $\varphi \in \mathcal T$ si et seulement si pour tout
    $\mathcal T' \geq \mathcal T, \psi \in \mathcal T'$, mais par hypothèse
    d'induction cela revient à $\mathcal T'\Vdash\psi$, ce qui est
    équivalent à $\mathcal T\Vdash\square \psi$.
  \end{itemize}
  Ainsi, par induction, on en déduit que $\varphi \in \mathcal T$ si et
  seulement si $\mathcal T \Vdash \varphi$.

  Pour conclure, si $\vdLS\varphi$ n'est pas prouvable, alors il existe une
  théorie saturée qui ne contient pas $\varphi$. Par contraposée, on en déduit
  que $\vdLS\varphi$ est prouvable.
\end{proof}

\begin{exercise}
  En utilisant le \cref{thm.ordi.Zorn}, montrer que si $\varphi$ n'est pas
  prouvable dans $\LS$, alors il existe une théorie saturée qui ne contient
  pas $\varphi$. \textit{Indication~: si $\varphi$ n'est pas prouvable, alors
    $\{\lnot\varphi\}$ constitue une théorie cohérente.}
\end{exercise}

En conclusion, on a une notion sémantique (celle de modèle de Kripke) et une
notion syntaxique (celle de logique modale) qui permettent de construire des
modèles dans lesquels on a plus de contrôle sur la satisfaction de formules.

On vérifie cependant toujours le tiers exclu, puisque dans tout modèle (au sens
classique) $\varphi\lor\lnot\varphi$ est vérifié.

L'intérêt de la logique modale est alors de changer l'interprétation des
formules intuitionnistes, en rajoutant des modalités.

\begin{definition}[Traduction de la logique intuitionniste dans la logique
    modale $S4$]
  Soit $\varphi$ une formule (non modale) sur une signature $\Sigma$, on
  définit sa traduction $\varphi_{\square}$ inductivement par~:
  \begin{itemize}
  \item si $\varphi = R(t_1,\ldots,t_n)$, alors
    $\varphi_\square \defeq \square R(t_1,\ldots,t_n)$
  \item si $\varphi = \top$, alors $\varphi_\square \defeq \top$
  \item si $\varphi = \bot$, alors $\varphi_\square \defeq \bot$
  \item si $\varphi = \lnot \psi$, alors
    $\varphi_{\square} \defeq \square\lnot\psi_\square$
  \item si $\varphi = \psi \lor \chi$, alors
    $\varphi_\square \defeq \psi_\square\lor \chi_\square$
  \item si $\varphi = \psi \land \chi$, alors
    $\varphi_\square \defeq \psi_\square\land\chi_\square$
  \item si $\varphi = \psi \to \chi$, alors
    $\varphi_\square \defeq \square(\psi_\square \to \chi_\square)$
  \item si $\varphi = \forall x, \psi$, alors
    $\varphi_\square = \square \forall x,\psi_\square$
  \item si $\varphi = \exists x, \psi$, alors
    $\varphi_\square = \exists x, \psi_\square$.
  \end{itemize}
\end{definition}

La traduction d'une formule en logique modale ajoute donc une modalité
$\square$ aux atomes, aux implications, aux négations et aux quantifications
universelles. Si on considère la négation $\lnot\varphi$ comme $\varphi\to\bot$,
il est naturel qu'il faille ajouter une modalité $\square$.

Ce qui rend les derniers constructeurs particuliers, et qui motive le fait de
leur ajouter une modalité $\square$, est leur caractère négatif. Quand on
considère $\forall x, \varphi$, la formule peut être vue comme une fonction qui
attend d'abord en argument une valeur à substituer à $x$. De même, la formule
$\varphi \to \psi$ attend d'abord une preuve de $\varphi$, avant d'en déduire
$\psi$. Pour les atomes, la nécessité d'ajouter une modalité $\square$ vient du
fait que la vérité de $R(t_1,\ldots,t_n)$ doit être établie de façon durable,
peu importe le futur considéré.

On peut maintenant définir la satisfaction d'une formule dans un modèle de
Kripke pour la logique intuitionniste.

\begin{definition}[Sémantique intuitionniste]
  Soit $\mathcal K$ un modèle de Kripke sur un ensemble pré-ordonné
  $(W,\leq)$. Pour un environnement d'interprétation $\rho$ et une formule
  $\varphi$ telle que $\VL(\varphi)\subseteq\dom(\rho)$, on définit
  $w,\rho\Vdash\varphi$ par induction sur $\varphi$~:
  \begin{itemize}
  \item si $\varphi = R(t_1,\ldots,t_n)$, alors
    $w,\rho\Vdash\varphi \defeq \forall w' \geq w,
    \mathcal K_{w,w'}(\rho(t_1)),\ldots,\mathcal K_{w,w'}(\rho(t_n)) \in
    R^{\mathcal K_{w'}}$
  \item si $\varphi = \top$, alors $w,\rho\Vdash\varphi$
  \item si $\varphi = \bot$, alors $w,\rho\nVdash\varphi$
  \item si $\varphi = \lnot \psi$, alors
    $w,\rho\Vdash\varphi \defeq \forall w' \geq w,
    w',\rho\nVdash\psi$
  \item si $\varphi = \psi \lor \chi$, alors
    $w,\rho\Vdash\varphi \defeq (w,\rho\Vdash\psi) \lor (w,\rho\Vdash\chi)$
  \item si $\varphi = \psi \land\chi$, alors
    $w,\rho\Vdash\varphi \defeq (w,\rho\Vdash\psi) \land(w,\rho\Vdash\chi)$
  \item si $\varphi = \psi \to \chi$, alors
    $w,\rho\Vdash\varphi \defeq \forall w'\geq w,
    (w',\rho\Vdash\psi)\implies (w',\rho\Vdash\chi)$
  \item si $\varphi = \forall x, \psi$, alors
    $w,\rho\Vdash\varphi \defeq \forall w'\geq w,
    \forall k \in \mathcal K_{w'},
    w',\rho[x\mapsto k]\Vdash \psi$
  \item si $\varphi = \exists x, \psi$, alors
    $w,\rho\Vdash\varphi\defeq \exists k \in \mathcal K_{w},
    w,\rho[x\mapsto k]\Vdash \psi$
  \end{itemize}
  Pour une formule close, on note directement $w\Vdash\varphi$.

  On définit la satisfaction d'une formule $\varphi$ par un modèle $\mathcal K$
  par
  \[\mathcal K \models \varphi \defeq \forall w \in W, w\Vdash \varphi\]
\end{definition}

\begin{remark}
  La sémantique de Kripke intuitionniste n'est définie que pour des modèles de
  Kripke sur des pré-ordres, on ne précisera donc pas ce fait quand on parlera
  de modèle de Kripke pour la logique intuitionniste, à l'avenir.
\end{remark}

Avec cette sémantique, on peut de nouveau considérer la formule
$\varphi\lor\lnot\varphi$. Satisfaire une telle formule à un monde $w$
signifie que soit $w\Vdash\varphi$, soit aucun futur de $w$ ne satisfait
$\varphi$. \'Evidemment, il existe des situations ou aucune des deux options
n'est vérifiée.

\begin{exercise}
  Exhiber un contre-modèle de Kripke dans lequel $\varphi\lor\lnot\varphi$
  n'est pas vérifié. \textit{Indication~: on pourra prendre une signature
    contenant uniquement un symbole de relation $0$-aire, c'est-à-dire une
    variable propositionnelle.}
\end{exercise}

On souhaite maintenant montrer que cette sémantique de Kripke est complète
pour la logique intuitionniste, c'est-à-dire que $\Gamma\vdLJ\varphi$ est
prouvable si et seulement si pour tout modèle de Kripke $\mathcal K$ tel que
$\mathcal K\models\bigwedge\Gamma$, on a $\mathcal K\models\varphi$.

\begin{exercise}
  Montrer la correction de $\LJ$ pour cette sémantique, c'est-à-dire le sens
  direct de l'équivalence mentionnée.
\end{exercise}

Plutôt que de démontrer à nouveau un théorème de complétude, on va utiliser la
traduction de la logique intuitionniste dans la logique modale $S4$.

\begin{theorem}[Plongement de Gödel-McKinsey-Tarski
    \cite{Godel1932-GDEZIA,McKinsey1948-MCKSTA}]
    Soit $\Sigma$ une signature du premier ordre.
    Pour tous $\Gamma\in\List(\Formula(\Sigma)), \varphi\in\Formula(\Sigma)$,
    on a l'équivalence
    \[\Gamma\vdLJ\varphi \iff \Gamma_\square\vdLS\varphi_\square\]
\end{theorem}

\begin{proof}
  A FAIRE
\end{proof}

\begin{corollary}
  La sémantique de Kripke intuitionniste est complète vis à vis de $\LJ$.
\end{corollary}
