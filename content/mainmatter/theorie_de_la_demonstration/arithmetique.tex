\chapter{Cohérence de l'arithmétique}
\label{chp.coh.arith}

\minitoc

\lettrine{P}{armi} les questions posées par le programme de Hilbert, outre le
problème de la décision, résolu par Church et Turing par la négative, on compte
aussi le deuxième problème de Hilbert~:
\begin{quote}
  Prouver que la théorie de l'arithmétique est cohérente.
\end{quote}
à propos duquel le second théorème d'incomplétude impose une limite.

Le second théorème d'incomplétude nous permet de dire qu'il n'existe pas de
démonstration arithmétique de cette cohérence, mais une démonstration peut se
faire dans un système plus fort.

Une preuve de cohérence existe en considérant simplement le théorème de
complétude, dans son sens de correction~: en exhibant un modèle de
l'arithmétique, on sait que l'arithmétique est cohérente. Un tel modèle est
le modèle standard. Grâce à cette démonstration, on apprend que, pour peu que
$\ZFC$ est cohérente, l'arithmétique est cohérente.

La première démonstration historique de la cohérence de l'arithmétique par
Gentzen dans \cite{Gentzen1936}, nous donne en comparaison beaucoup plus
d'informations. Elle est par exemple le fondement de l'analyse ordinale des
théories logiques.

L'objectif de ce chapitre est de parcourir deux preuves centrales de la
cohérence de l'arithmétique. La première est celle de Gentzen, déjà mentionnée
plus tôt, qui sera présentée dans une forme mise à jour et adaptée à notre
formalisem logique moderne. La seconde est la démonstration de la cohérence de
l'arithmétique de Heyting, ou arithmétique intuitionniste, développée par
Kleene dans \cite{Kleene1945}. Cette démonstration fonde la théorie de la
réalisabilité, sujet tout aussi important de la théorie de la démonstration.

\section{La cohérence de l'arithmétique de Peano}

Notre première démonstration de cohérence est celle de Gentzen. L'idée est assez
directe~: on a vu que l'élimination des coupures permettait de prouver la
cohérence du calcul des séquents, on construit donc un calcul des séquents
encodant l'arithmétique de Peano, dont on prouve l'élimination des coupures.

L'objectif est donc en premier lieu de trouver des règles qui puissent
enrichir un calcul des séquents pour que les axiomes de $\ArithPeano$ soient
prouvables (sans contexte gauche).

\subsection{Construire un calcul des séquents arithmétique}

On fixe donc comme signature celle de l'arithmétique. Rappelons les axiomes
de la théorie $\ArithPeano$~:
\begin{align*}
  &\forall n, 0 \neq S\;n\\
  &\forall n\;m, Sn =Sm\implies n = m\\
  &\forall n, (n = 0) \lor (\exists m,n = Sm)\\
  &\forall n, n+0 = n\\
  &\forall n\;m, n+(Sm) = S(n+m)\\
  &\forall n, n\times 0 = n\\
  &\forall n\;m, n\times(Sm) = (n\times m)+n\\
  &\forall \varphi(\vec x,y)\in\Formula, \forall \vec n,
  \varphi(\vec n,0)\implies
  (\forall m, \varphi(\vec n,m) \implies \varphi(\vec n,S m))\implies
  \forall m, \varphi(\vec n,m)
\end{align*}
où la quantifcation $\forall \varphi$ signifie qu'on considère un schéma
d'axiomes.

On remarque d'abord que le \ordinalnumeralmale{$3$} axiome est une conséquent
de la récurrence, en instanciant le schéma avec
$\varphi(n) \defeq (n = 0) \lor (\exists m, n = Sm)$.

Les axiomes définissant l'addition et la multiplication sont simplement des
égalités quantifiées universellement. Pour les intégrer à notre système, on
peut décider d'ajouter des règles telles que
\begin{prooftree}
  \AxiomC{}
  \RightLabel{$+0$}
  \UnaryInfC{$t + 0 = t$}
\end{prooftree}
Une telle façon de procéder suffit à prouver le résultat de cohérence, mais on
souhaite introduire une façon plus efficace de raisonner sur les théories, qui
permet des raisonnements plus simples et naturels~: l'introduction de règles
de réécriture au sein d'un système de démonstration.

Pour cela, supposons qu'on dispose d'une relation de réécriture $\rhd$ sur les
termes et les formules (vérifiant naturellement que si $t \rhd u$, alors
$\varphi[t/x] \rhd \varphi[u/x]$) qui est compatible. Un point essentiel à
assurer, puisqu'on traite de systèmes syntaxiques, est que la réécriture d'une
formule (ou d'un terme) en une autre est calculable. On fixe donc la réécriture
$\rhd$ comme étant fortement normalisante et confluente (on verra que, pour
notre usage, ces conditions sont vérifiées).

On définit alors l'ensemble des arbres de preuve où les séquents à la conclusion
d'une règle peuvent différer de la conclusion attendue par des réécritures du
séquent.

\begin{definition}[Déduction modulo théorie]
  Soit un ensemble de règles pour le calcul des séquents et $\rhd$ une
  relation de réécriture compatible sur les termes et les formules. On étend
  $\rhd$ en une relation d'équivalence $\equiv$, et on l'étend sur les
  séquents en considérant l'équivalence des formules appartenant aux séquents
  (vu comme des listes de formules). Les arbres de déduction modulo $\rhd$ sont
  les arbres construits par les règles modifiées suivantes~: pour chaque règle
  $r$ de prémisses $\Gamma_1\vdLK\Delta_1,\cdots, \Gamma_n\vdLK\Delta_n$ et de
  conclusion $\Gamma\vdLK\Delta$, si
  $(\Gamma_i\vdLK\Delta_i)\equiv (\Theta_i\vdLK\Xi_i)$ et
  $(\Gamma\vdLK\Delta)\equiv(\Theta\vdLK\Xi)$, alors on ajoute la règle
  \begin{prooftree}
    \AxiomC{$\Theta_1\vdLK\Xi_1$}
    \AxiomC{$\cdots$}
    \AxiomC{$\Theta_n\vdLK\Xi_n$}
    \RightLabel{r}
    \TrinaryInfC{$\Theta\vdLK\Xi$}
  \end{prooftree}
\end{definition}

Le théorème suivant permet d'assurer la validité de cette pratique, en
montrant que les séquent prouvables n'en sont pas modifiés.

\begin{theorem}
  Soit $\rhd$ une réécriture compatible sur les termes et les formules. Un
  séquent $\Gamma\vdLK\Delta$ est prouvable modulo $\rhd$ si et seulement
  s'il existe un sous-ensemble fini $F$ de
  \[\mathcal T_{\to} \defeq \{(t = u)\mid t,u\in\Term, t \equiv u\}
  \cup \{\varphi \leftrightarrow \psi \mid \varphi,\psi\in\Formula,
  \varphi\equiv \psi\}\]
  tel que $\Gamma,F\vdLK\Delta$.
\end{theorem}

\begin{proof}
  A chaque application de règle dans la construction de l'arbre modulo $\rhd$,
  on utilise un nombre fini de réductions entre des formules et entre des
  termes. Pour chaque substitution d'une terme $t$ par un terme $u$, il
  suffit d'utiliser la règle $l=$. Pour chaque substitution d'une formule
  $\varphi$ par une formule $\psi$, on utilise le fait que, si
  $\vdLK \varphi\leftrightarrow \psi$, alors
  $\Gamma[\varphi/\psi]\vdLK\Delta[\varphi/\psi]$ est prouvable si et seulement
  si $\Gamma\vdLK\Delta$ l'est, ce qui est direct en passant par la sémantique.
\end{proof}

La déduction modulo théorie permet donc d'internaliser les égalités les plus
naturelles du système, qu'on appelle parfois des égalités définitionnelles.

A l'exception de la récurrence, tous les autres axiomes peuvent s'utiliser par
une règle de réécriture.

\begin{definition}[Réécriture arithmétique]
  On définit la règle de réécriture suivante sur les expressions arithmétiques~:
  \begin{align*}
    t + 0 &\rhd t\\
    t + S\;u &\rhd S\;(t + u)\\
    t \times 0 &\rhd 0 \\
    t \times (S\;u) &\rhd (t\times u) + t
  \end{align*}
\end{definition}

\begin{exercise}
  Montrer que cette réécriture est confluente et fortement normalisante.
\end{exercise}

Il est clair que travailler modulo cette réécriture arithmétique permet
de prouver exactement les séquents prouvables avec les axiomes définissant
l'addition et la multiplication.

Pour les deux premiers axiomes, on ajoute des réécritures de formules.
On remarque d'abord que $0\neq S\;n$ est défini comme $(0 = S\;n)\to \bot$,
et $\bot\to \varphi$ est toujours vraie, donc on ajoute la réécriture
$(0 = S\;t)\rhd \bot$. De même, on sait que $n = m \implies S\;n = S\;m$,
donc on ajoute la réécriture $(S\;t = S\;u)\rhd t = u$.

Finalement, il nous reste à introduire une règle pour le schéma de récurrence.
La règle à introduire est naturelle~: les deux prémisses d'une récurrence sont
les prémisses de la règle.

\begin{definition}[Calcul des séquents arithmétique]
  On définit le calcul des séquents arithmétique $\LKPA$ comme le calcul $\LK$
  sur la signature de l'arithmétique, considéré modulo la réduction $\rhd$
  définie précédemment sur les termes et les formules, et avec l'ajout de la
  règle
  \begin{prooftree}
    \AxiomC{$\Gamma\vdPA\varphi[0/x],\Delta$}
    \AxiomC{$\Gamma,\varphi\vdPA\varphi[S\;x/x],\Delta$}
    \RightLabel{Rec${}^\dagger$}
    \BinaryInfC{$\Gamma\vdPA\forall x\, \varphi,\Delta$}
  \end{prooftree}
  où $\dagger$ indique que la variable $x$ est libre dans
  $\Gamma,\Delta$.
\end{definition}

\begin{proposition}
  Pour toute formule $\varphi$, $\ArithPeano\vdLK\varphi$ si et seulement si
  $\vdPA\varphi$.
\end{proposition}

\begin{proof}
  On sait que les formules prouvables modulo réécriture le sont sans réécriture
  en ajoutant des hypothèses, et ces hypothèses sont choisies exactement parmi
  les conséquences des premiers axiomes de $\ArithPeano$ (à l'exception du
  \ordinalnumeralmale{$3$}). Pour la récurrence, il est clair que chaque
  instance du schéma de récurrence est prouvable avec la règle Rec${}^\dagger$,
  et que toute utilisation de la règle Rec${}^\dagger$ peut s'écrire avec une
  instance du schéma de récurrence.
\end{proof}

\subsection{\'Elimination des coupures}

Il nous reste à prouver l'élimination des coupures. \'Etudions un premier
exemple en prenant un arbre prouvant que le successeur commute avec la somme à
gauche~:
\[\pi_0 \defeq \resizebox{0.8\textwidth}{!}{
  \AxiomC{}
  \RightLabel{$r=$}
  \UnaryInfC{$\vdPA \forall n, S\;n + 0 = S\;(n+0)$}
  \AxiomC{}
  \RightLabel{$r=$}
  \UnaryInfC{$\vdPA (S\;n)+(S\;m) = S(S\;n+m)$}
  \RightLabel{$l=$}
  \UnaryInfC{$S\;n+m = S\;(n+m) \vdPA (S\;n)+(S\;m) = SS(n+m)$}
  \RightLabel{$l\forall$}
  \UnaryInfC{$\forall n,S\;n+m = S\;(n+m) \vdPA (S\;n)+(S\;m) = S\;(n+S\;m)$}
  \RightLabel{$r\forall^\dagger$}
  \UnaryInfC{$\forall n,S\;n+m = S\;(n+m)\vdPA
    \forall n, (S\;n)+(S\;m)=S\;(n+S\;m)$}
  \RightLabel{Rec}
  \BinaryInfC{$\vdPA \forall n\;m, S\;n+m = S\;(n+m)$}
  \DisplayProof
}\]
et un arbre prouvant que $0$ est neutre à gauche pour l'addition~:
\[\pi_1\defeq%\resizebox{\textwidth}{!}{
  \AxiomC{}
  \RightLabel{$r=$}
  \UnaryInfC{$\vdPA 0 + 0 = 0$}
  \AxiomC{}
  \RightLabel{$r=$}
  \UnaryInfC{$\vdPA S\;n = S\;n$}
  \RightLabel{$l=$}
  \UnaryInfC{$0 + n = n \vdPA 0 + S\;n = S\;n$}
  \RightLabel{Rec}
  \BinaryInfC{$\vdPA\forall n, 0 + n = n$}
  \DisplayProof
  %}
    \]
Avec ces deux arbres, on peut prouver par récurrence que l'addition est
commutative~:
\[\resizebox{\textwidth}{!}{
  \AxiomC{$\pi_1$}
  \noLine
  \UnaryInfC{$\vdPA\forall n, n + 0 = 0 + n$}
  \AxiomC{$\pi_0$}
  \noLine
  \UnaryInfC{$\vdPA\forall n\;m, Sn + m = S(n+m)$}
  \AxiomC{}
  \RightLabel{Ax}
  \UnaryInfC{$Sn + m = S(n+m)\vdPA n + Sm = Sm + n$}
  \RightLabel{$l\forall$}\doubleLine
  \UnaryInfC{$\forall n\;m, Sn + m = S(n+m)\vdPA n + Sm = Sm + n$}
  \RightLabel{$r\forall^\dagger$}
  \UnaryInfC{$\forall n\;m, Sn + m = S(n+m)\vdPA \forall n, n + Sm = Sm + n$}
  \RightLabel{Cut}
  \BinaryInfC{$\vdPA\forall n, n + m = m + n \vdPA \forall n, n + Sm = Sm + n$}
  \RightLabel{Rec}
  \BinaryInfC{$\vdPA\forall n\;m, n + m = m + n$}
  \DisplayProof
}\]
Supposons que l'on souhaite éliminer la coupure introduite dans cet arbre.
La première étape est de faire remonter la coupure au-dessus de la règle
$r\forall^\dagger$, de sorte qu'on obtient une coupure logique sur
$\forall$. La coupure logique en question est alors
\[\resizebox{\textwidth}{!}{
  \AxiomC{$\cdots$}
  \RightLabel{Rec}
  \UnaryInfC{$\vdPA \forall n\;m,Sn + m = S(n+m)$}
  \AxiomC{$\cdots$}
  \RightLabel{$l\forall$}
  \UnaryInfC{$\forall n\;m,Sn + m = S(n+m)\vdPA n+Sm = Sm + n$}
  \RightLabel{Cut}
  \BinaryInfC{$\cdots$}
  \DisplayProof
}\]
L'objectif de l'élimination des coupures est donc d'éliminer cette nouvelle
coupure logique.

Avant de nous intéresser à l'élimination de cette coupure logique, on repasse
en revue les points clés de l'élimination des coupures~:
\begin{itemize}
\item on doit réécrire les coupures non logiques pour atteindre des coupures
  logiques, en effectuant des réécritures $\reecr{\nwarrow}$ puis des
  réécriture $\reecr{\nearrow}$. On peut sans problème adapter les réécritures
  de relèvement avec la nouvelle règle de récurrence~;
\item puisqu'on a introduit des réécritures pour les termes et formules, il est
  nécessaire de vérifier que la réécriture d'une formule de coupure ne
  gêne pas la réécriture. Dans le cas de $Sn = Sm \rhd n = m$, la formule passe
  d'une égalité à une égalité, et il suffit de remplacer la substitution des
  termes $Sn$ par la substitution uniquement du $n$ à l'intérieur. Par exemple,
  pour $\varphi \defeq \forall n, Sm = n$, on peut considérer qu'on fait la
  substitution $(\forall n, x = n)[Sm/x]$ ou, après réécriture par $\rhd$,
  qu'on fait la substitution $(\forall n, Sx = n)[n/x]$. On peut alors, pour
  une coupure logique sur $=$, réduire la formule de coupure des deux côtés
  pour ne pas avoir de $S$~;
\item dans le cas de $0=St\rhd \bot$, une coupure logique sur $0 = St$ est
  impossible puisqu'il faudrait alors avoir
  \begin{itemize}
  \item la règle $r=$ utilisée pour avoir une égalité dans la formule de coupure
    de droite
  \item une égalité $0 \equiv St$ pour que, depuis la formule $u=u$ de la règle
    $r=$, on puisse réécrire la formule de gauche en $0$ et celle de droite en
    $St$
  \end{itemize}
  mais on peut vérifier que $0\not\equiv St$, en parcourant simplement les cas
  définissant $\rhd$ (aucun ne contient d'un côté de la réduction un $S$
  englobant tout le terme et de l'autre côté un $0$ seul).
\end{itemize}

Ces difficultés étant résolues, le c\oe ur de la difficulté de l'élimination des
coupures est la coupure de la récurrence~:
\begin{prooftree}
  \AxiomC{$\Gamma,\varphi[t/x]\vdPA\Delta$}
  \RightLabel{$l\forall$}
  \UnaryInfC{$\Gamma,\forall x\,\varphi\vdPA\Delta$}
  \AxiomC{$\Gamma\vdPA\varphi[0/x],\Delta$}
  \AxiomC{$\Gamma,\varphi\vdPA\varphi[Sx/x],\Delta$}
  \RightLabel{Rec}
  \BinaryInfC{$\Gamma\vdPA\forall x\,\varphi,\Delta$}
  \RightLabel{Cut}
  \BinaryInfC{$\Gamma\vdPA\Delta$}
\end{prooftree}

Pour éliminer cette coupure, on commence par considérer le cas où $t$ est un
terme clos. Dans ce cas, on peut prouver facilement par induction que
$t \equiv \encode n$ pour un certain entier $n \in \bN$. L'élimination de cette
coupure repose donc sur l'élimination des entiers standards.

\'Etant donnés $\pi_0 \concl \Gamma\vdPA\varphi[0/x],\Delta$,
$\pi_S \concl \Gamma,\varphi\vdPA\varphi[Sx/x],\Delta$, le fait que
$\Gamma\vdPA \forall x\,\varphi,\Delta$ se déduit moralement du fait que,
pour tout $n\in\bN$, on peut prouver $\varphi[\encode n/x]$ en utilisant
$\pi_0$ dans le cas où $n = 0$ et $\pi_S$ pour passer du cas $n$ au cas
$n+1$. La réduction de la coupure est donc, naturellement, la suivante~:
\begin{center}
  \resizebox{\textwidth}{!}{
    \begin{tabular}{ccc}
      \bottomAlignProof
      \AxiomC{$\mathlarger\pi$}
      \noLine\UnaryInfC{$\Gamma,\varphi[0/x]\vdPA\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma,\forall x\,\varphi\vdPA\Delta$}
      \AxiomC{$\mathlarger{\pi_0}$}
      \noLine\UnaryInfC{$\Gamma\vdPA\varphi[0/x],\Delta$}
      \AxiomC{$\mathlarger{\pi_S}$}
      \noLine\UnaryInfC{$\Gamma,\varphi\vdPA\varphi[Sx/x],\Delta$}
      \RightLabel{Rec}
      \BinaryInfC{$\Gamma\vdPA\forall x\,\varphi,\Delta$}
      \RightLabel{Cut}
      \BinaryInfC{$\Gamma\vdPA\Delta$}
      \DisplayProof
      & $\reecr{Rec_0}$ &
      \bottomAlignProof
      \AxiomC{$\mathlarger\pi$}
      \noLine\UnaryInfC{$\Gamma,\varphi[0/x]\vdPA\Delta$}
      \AxiomC{$\mathlarger{\pi_0}$}
      \noLine\UnaryInfC{$\Gamma\vdPA\varphi[0/x],\Delta$}
      \RightLabel{Cut}
      \BinaryInfC{$\Gamma\vdPA\Delta$}
      \DisplayProof
      \\
      \\
      \bottomAlignProof
      \AxiomC{$\mathlarger\pi$}
      \noLine\UnaryInfC{$\Gamma,\varphi[S\;t/x]\vdPA\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma,\forall x\,\varphi\vdPA\Delta$}
      \AxiomC{$\mathlarger{\pi_0}$}
      \noLine\UnaryInfC{$\Gamma\vdPA\varphi[0/x],\Delta$}
      \AxiomC{$\mathlarger{\pi_S}$}
      \noLine\UnaryInfC{$\Gamma,\varphi\vdPA\varphi[Sx/x],\Delta$}
      \RightLabel{Rec}
      \BinaryInfC{$\Gamma\vdPA\forall x\,\varphi,\Delta$}
      \RightLabel{Cut}
      \BinaryInfC{$\Gamma\vdPA\Delta$}
      \DisplayProof
      & $\reecr{Rec_S}$ &
      \bottomAlignProof
      \AxiomC{$\mathlarger\pi$}
      \noLine\UnaryInfC{$\Gamma,\varphi[S\;t/x]\vdPA\Delta$}
      \AxiomC{$\mathlarger{\pi_S[t/x]}$}
      \noLine\UnaryInfC{$\Gamma,\varphi[t/x]\vdPA\varphi[S\;t/x],\Delta$}
      \RightLabel{Cut}
      \BinaryInfC{$\Gamma\varphi[t/x]\vdPA\Delta$}
      \RightLabel{$l\forall$}
      \UnaryInfC{$\Gamma\forall x\,\varphi\vdPA\Delta$}
      \AxiomC{$\mathlarger{\pi_0}$}
      \noLine\UnaryInfC{$\Gamma\vdPA\varphi[0/x],\Delta$}
      \AxiomC{$\mathlarger{\pi_S}$}
      \noLine\UnaryInfC{$\Gamma,\varphi\vdPA\varphi[Sx/x],\Delta$}
      \RightLabel{Rec}
      \BinaryInfC{$\Gamma\vdPA\forall x\,\varphi,\Delta$}
      \RightLabel{Cut}
      \BinaryInfC{$\Gamma\vdPA\Delta$}
      \DisplayProof
    \end{tabular}
  }
\end{center}

La réécriture fait donc grossir l'arbre de gauche de la coupure, mais fait
diminuer la valeur de $t$ jusqu'à $0$.

Cependant, dans le cas où $t$ contient une variable libre, on peut avoir un
blocage de cette réduction. Dans notre exemple précédent, c'est ce qui arrive~:
la formule de coupure contient $m$ qui ne peut pas se réduire de cette façon.
En considérant l'élimination des coupures comme un processus calculatoire, ce
blocage signifie qu'on ne peut pas appliquer une fonction définie par récurrence
une fois atteinte une valeur indéterminée par le fait qu'elle est une variable.
Cette limitation n'est, malgré tout, pas un problème pour la cohérence. En
effet, la cohérence est la preuve qu'il n'existe aucun arbre de dérivation du
séquent vide $\vdPA$. Cet arbre de dérivation ne contient que des termes clos
(puisqu'il ne contient pas de terme). Notre théorème d'élimination des coupures
peut donc se limiter aux séquents dont tous les termes sont clos.

\begin{remark}
  Le fait que tous les termes sont clos est plus fort que le fait que les
  formules de la conclusion sont closes, car on demande ici qu'aucune variable
  libre n'apparaissent dans l'arbre de preuve.
\end{remark}

\begin{lemma}\label{lem.coh.PA}
  Pour tout arbre de preuve $\pi \in \ProofPA$ sous forme normale pour
  $\reecr{}$ et dont tous les termes sont clos est sans coupure.
\end{lemma}

\begin{proof}
  On sait que toute coupure peut être réécriture en une coupure logique. Une
  telle coupure logique s'élimine forcément si elle ne fait pas intervenir
  la règle Rec (puisque $\LK$ a l'élimination des coupures). Si la coupure
  logique utilise la règle Rec, alors le terme $t$ utilisé dans cette coupure
  peut se réécrire en $0$ ou en $Su$ pour un certain terme $u$~: dans tous les
  cas, une réduction existe sur cette coupure.
\end{proof}

La dernière étape est de vérifier la terminaison de notre réécriture. On définit
donc une mesure de décroissance, permettant de l'assurer.

\begin{definition}[Poids d'une coupure logique récursive]
  Soit $\pi\in\ProofPA$ sans coupure autre que des coupures logiques utilisant
  la règle Rec. Soit une coupure $C$ ayant la forme suivante~:
  \begin{prooftree}
    \AxiomC{$\mathlarger\pi$}
    \noLine\UnaryInfC{$\Gamma,\varphi[t/x]\vdPA\Delta$}
    \RightLabel{$l\forall$}
    \UnaryInfC{$\Gamma,\forall x\,\varphi\vdPA\Delta$}
    \AxiomC{$\mathlarger{\pi_0}$}
    \noLine\UnaryInfC{$\Gamma\vdPA\varphi[0/x],\Delta$}
    \AxiomC{$\mathlarger{\pi_S}$}
    \noLine\UnaryInfC{$\Gamma,\varphi\vdPA\varphi[Sx/x],\Delta$}
    \RightLabel{Rec}
    \BinaryInfC{$\Gamma\vdPA\forall x\,\varphi,\Delta$}
    \RightLabel{Cut}
    \BinaryInfC{$\Gamma\vdPA\Delta$}
  \end{prooftree}
  On définit $w(C) \in \Ord$ et $w(\pi)$ par induction mutuelle~:
  \[\omega^{w(\pi_S)}\times |t| + w(C) \defeq \max(w(\pi),w(\pi_0)) \qquad
  w(\pi) \defeq 1 + \max_{C \in \pi} w(C)\]
  où la taille $|t|$ est prise comme le minimum des $|u|$ pour $t \equiv u$.
\end{definition}

La raison pour laquelle le poids d'une coupure dans $\pi_S$ est ajouté
exponentiellement découle du fait que, lorsqu'on réécrit une coupure récursive,
on ajoute une fois $\pi_S$ pour chaque réécriture de $t$ le faisant décroître.

\begin{lemma}
  Pour tout arbre $\pi\in\ProofPA$ ne possédant que des coupures logiques
  récursives, en posant $\pi'$ le résultat de $\pi$ en réduisant sa coupure
  logique récursive de poids maximal, on a $w(\pi') < w(\pi)$.
\end{lemma}

\begin{proof}
  Considérons que la coupure $C$ de poids maximal est donnée par le sous-arbre
  suivant~:
  \begin{prooftree}
    \AxiomC{$\mathlarger\pi$}
    \noLine\UnaryInfC{$\Gamma,\varphi[t/x]\vdPA\Delta$}
    \RightLabel{$l\forall$}
    \UnaryInfC{$\Gamma,\forall x\,\varphi\vdPA\Delta$}
    \AxiomC{$\mathlarger{\pi_0}$}
    \noLine\UnaryInfC{$\Gamma\vdPA\varphi[0/x],\Delta$}
    \AxiomC{$\mathlarger{\pi_S}$}
    \noLine\UnaryInfC{$\Gamma,\varphi\vdPA\varphi[Sx/x],\Delta$}
    \RightLabel{Rec}
    \BinaryInfC{$\Gamma\vdPA\forall x\,\varphi,\Delta$}
    \RightLabel{Cut}
    \BinaryInfC{$\Gamma\vdPA\Delta$}
  \end{prooftree}
  Montrons que le poids décroît strictement en réduisant la coupure.

  Dans le cas où $t = 0$, les deux poids sont respectivement
  $\omega^{w(\pi_S)}\times 1 + \max(w(\pi),w(\pi_0))$ et $\max(w(\pi),w(\pi_0))$,
  d'où la stricte décroissance.

  Dans le cas où $t \equiv Su$ avec $u$ un terme, les poids sont respectivement
  \[\omega^{w(\pi_S)}\times |u| + \omega^{w(\pi_S)} + \max(w(\pi),w(\pi_0))
  \quad\text{et}\quad
  \omega^{w(\pi_S)}\times |u| + \max(w(\pi),w(\pi_S),w(\pi_0))\]
  Dans le cas où $w(\pi_S)$ n'est pas la plus grande valeur des trois dont on
  prend le maximum, on se trouve après simplification à $\omega^{w(\pi_S)} > 0$,
  ce qui est vrai.
  Dans le cas où $w(\pi_S)$ est la plus grande valeur des trois, on veut
  vérifier que $\omega^{w(\pi_S)}  > w(\pi_S)$, ce qui est vrai aussi pour
  $w(\pi_S) < \varepsilon_0$ (et, par construction, $w(\pi_S) < \varepsilon_0$
  est toujours vérifié).

  Dans tous les cas, on voit que le poids décroît strictement.
\end{proof}

\begin{remark}
  Le poids ne décroît pas systématiquement, avec notre définition. Pour autant,
  en prenant comme mesure le nombre de coupures maximales avec la valeur du
  poids maximal, on sait que (puisque la coupure de poids maximal choisit est
  réduite en une coupure de poids strictement inférieur) le coupe de nombres
  décroît strictement.
\end{remark}

On en déduit le résultat d'élimination des coupures (faible).

\begin{theorem}[\'Elimination des coupures faible de l'arithmétique]
  Pour tout séquent $\Gamma\vdPA \Delta$, s'il existe $\pi \in \ProofPA$ tel
  que $\pi\concl \Gamma\vdPA\Delta$, alors il existe un arbre
  $\pi' \in \ProofPA$ sous forme normale pour $\reecr{}$ tel que
  $\pi'\concl\Gamma\vdPA\Delta$.
\end{theorem}

\begin{proof}
  Il nous suffit d'appliquer l'algorithme d'élimination des coupures dans notre
  système.
\end{proof}

\begin{theorem}[Cohérence de l'arithmétique \cite{Gentzen1936}]
  Le séquent suivant n'est pas dérivable dans $\LK$~:
  \[\ArithPeano\vdLK\]
\end{theorem}

\begin{proof}
  La prouvabilité de ce séquent est équivalente à la prouvabilité du séquent
  vide du calcul des séquents de l'arithmétique~: $\vdPA$.

  Avec l'élimination des coupures, une telle preuve de $\vdPA$ doit se faire
  sans coupure. En effet, il doit exister un arbre sous forme normale pour
  $\reecr{}$ dont la conclusion est $\vdPA$. Mais alors, on peut vérifier que
  tous les termes de l'arbre sont clos. Si ça n'est pas le cas, alors pour le
  séquent le plus bas où un terme non clos apparaît, on a la propriété de la
  sous-formule (car sur cette partie de l'arbre, tous les termes sont clos et
  l'arbre est sous forme normale, donc sans coupure d'après le
  \cref{lem.coh.PA}).

  On a donc un arbre sans coupure et qui prouve
  $\vdPA$, mais alors aucune règle n'a pour conclusion $\vdPA$, ce qui est
  absurde. On en déduit $\Coher(\ArithPeano)$.
\end{proof}

\subsection{Conséquences du théorème}

La cohérence de l'arithmétique est un résultat important d'un point de vue
historique, mais on peut se demander quel est l'intérêt de donner une preuve
aussi technique à un théorème évident par la théorie des modèles. Son intérêt
réside dans la possibilité d'évaluer à quel point la cohérence de
$\ArithPeano$ est difficile à prouver.

Avec les définitions précédentes, tout ce qui est défini est parfaitement
calculable (c'est en particulier pour cette raison qu'on a demandé que $\equiv$
soit calculable). Cela signifie que n'importe quelle théorie $\Sigma$-complète,
voire encodant à traduction près une théorie $\Sigma$-complète, permet de
redonner l'essentiel de la démonstration.

La définition du calcul des séquents ne pose pas de problème, la définition des
étapes de réécriture non plus. Un seul fait peut limiter cette démonstration~:
le fait que l'algorithme termine. Remarquons d'abord que, une fois définie une
syntaxe calculable pour parler de l'ensemble $\varepsilon_0$, plus petit
ordinal stable par l'opération $x \mapsto \omega^x$, on peut tout à fait
définir le poids des coupures, et parfois même prouver leur décroissance.

Le point limitant dans la terminaison de l'algorithme est la bonne fondation de
l'ensemble $\varepsilon_0$, ou d'un de ses encodages dans l'arithmétique.

\begin{definition}[Encodage d'un bon ordre]
  Soit $\mathcal T$ une théorie. On dit que $\mathcal T$ encode un ensemble bien
  ordonné strict $(X,<)$ s'il existe un prédicat $F_X(x)$, un prédicat $x <_X y$
  et si on a
  \begin{align*}
    \mathcal T\vdash& \forall x^{F_X}, \lnot(x <_X x)\\
    \mathcal T\vdash& \forall x^{F_X}\;y^{F_X}\;z^{F_X},
    x <_X y \land y <_X z \implies x <_X z\\
    \mathcal T\vdash& (\forall x^{F_X}, (\forall y^{F_X}, y <_X x \implies
    \varphi(y))\implies \varphi(x))\implies \forall x^{F_X},\varphi(x)
  \end{align*}
  où la dernière ligne est un schéma de théorèmes, pour toute formule
  $\varphi(x)$ (potentiellement à paramètres).
\end{definition}

On en déduit donc une première conséquence de la cohérence de l'arithmétique.

\begin{corollary}
  Soit $\mathcal T$ une théorie arithmétique $\Sigma$-complète. Si
  $\mathcal T$ encode $\varepsilon_0$ alors
  \[\mathcal T \vdash \Coher(\ArithPeano)\]
\end{corollary}

Prenons maintenant un point de vue plus général. Pour une théorie $\mathcal T$,
on peut chercher quelles sont les ensembles bien ordonnés encodables dans
$\mathcal T$. A l'encodage près, on obtient ainsi un ensemble d'ordinaux qui
représentent en quelque sorte \og jusqu'où $\mathcal T$ arrive à prouver la
bonne fondation de l'ordre\fg. D'après ce qui a été vu pour $\ArithPeano$, cet
ensemble a un sens important logique à travers la normalisation de systèmes
formels~: les ordinaux encodables sont les systèmes formels dont on peut
prouver la terminaison d'un processus de normalisation. On donne donc un nom à
la borne supérieure de cet ensemble~: l'ordinal de preuve de $\mathcal T$.

\begin{definition}[Ordinal de preuve]
  Soit $\mathcal T$ une théorie $\Sigma$-complète. On appelle ordinal de preuve
  de $\mathcal T$ l'ordinal
  \[\PTO(\mathcal T) \defeq \sup
  \{\type(X,<)\mid (X,<)\text{ est encodable dans } \mathcal T\}\]
\end{definition}

On peut donc reformuler le corollaire précédent par
\begin{quote}
  Toute théorie $\Sigma$-complète dont l'ordinal de preuve est supérieur
  strictement à $\varepsilon_0$ prouve la cohérente de $\ArithPeano$.
\end{quote}
et, d'après le second théorème d'incomplétude
\begin{quote}
  L'ordinal de preuve de $\ArithPeano$ est inférieur à $\varepsilon_0$.
\end{quote}

En réalité, l'ordinal de preuve de $\ArithPeano$ est exactement égal à
$\varepsilon_0$.

\begin{theorem}
  On a l'égalité
  \[\PTO(\ArithPeano) = \varepsilon_0\]
\end{theorem}

\begin{proof}
  Il nous faut prouver l'autre inégalité, qui consiste à montrer que tout
  ordinal $\alpha < \varepsilon_0$ est encodable dans $\ArithPeano$. Pour cela,
  on prouve que $0$ est encodable dans $\ArithPeano$ et que si
  $\alpha,\beta$ sont encodables dans $\ArithPeano$, alors
  $\alpha+ \beta$ et $\omega^\alpha$ sont encodables. Le premier point est
  évident, on se tourne donc vers le second point.

  Soient $\alpha,\beta$ encodés par respectivement $F_\alpha,<_\alpha$ et
  $F_\beta,<_\beta$. On définit alors
  \[F_{\alpha+\beta}(x) \defeq \exists n\;m, x = \langle n,m\rangle \land
  F_\alpha(n) \land F_\beta(m)\]
  \[x<_{\alpha+\beta}y \defeq \forall n\;m\;n'\;m', (x = \langle n,m\rangle \land
  y = \langle n',m'\rangle)\implies (n <_{\alpha} n')\lor (n = n'\land
  m <_{\beta} m')\]
  On peut vérifier sans souci que $<_{\alpha+\beta}$ est bien une relation d'ordre
  stricte en utilisant le fait que $<_\alpha$ et $<_\beta$ en sont.
  Pour prouver que $<_{\alpha+\beta}$ est bien fondée, on considère un élément
  $x$ tel que
  \[(\forall y^{F_{\alpha_\beta}}, y <_{\alpha+\beta} x \implies \varphi(y))\implies
  \varphi(x)\]
  on sait que $\varphi(x)$ est vérifié si et seulement si, en décomposant
  $x = \langle n,m\rangle$, le prédicats suivant est vérifié~:
  \[\chi(n,m) \defeq \varphi(\langle n,m\rangle)\]
  et on peut prouver que ce prédicat est vrai pour tous $n,m$ tels que
  $F_\alpha(n)$ et $F_\beta(m)$ en utilisant la bonne fondation de $<_\alpha$ et
  $<_\beta$.

  Pour encoder l'ordinal $\omega^\alpha$, on utilise l'encodage des listes~:
  \[F_{\omega^\alpha}(\ell) \defeq \forall i < |\ell|, F_{\alpha}(\ell_i)\]
  en considérant que $\ell$ est l'encodage des lites par la bijection
  $\alpha_\star : \List(\bN) \cong \bN$, où $|\ell|$ est l'encodage sur les
  entiers de la fonction donnant la longueur d'une liste, et que
  $\ell_i$ est le \ordinalnumeralmale{$i$} élément de $\ell$. Pour la
  relation d'ordre, on pose
  \[\ell <_{\omega^\alpha} \ell' \defeq
  \begin{cases}
    |\ell| < |\ell'| \land \forall i < |\ell|, \ell_i = \ell'_i\\
    \text{ou}\\
    \exists i, \forall j < i, (\ell_i = \ell'_i)\land (\ell_j < \ell'_j)
  \end{cases}\]
  La vérification du fait que $<_{\omega^\alpha}$ est une relation d'ordre est
  longue mais ne pose pas de problème.

  Pour le fait que $<_{\omega^\alpha}$, on raisonne par induction sur la longueur
  des listes, et on utilise la bonne fondation de $\alpha$ dans le cas
  inductif.

  On en déduit ainsi que l'ensemble définie inductivement par
  \[\alpha,\beta \Coloneq 0 \mid \alpha + \beta \mid \omega^\alpha\]
  est contenu dans les ordinaux représentables dans $\ArithPeano$. Par
  décomposition de Cantor, on sait que tout élément strictement inférieur à
  $\varepsilon_0$ est dans cet ensemble. On en déduit que
  $\varepsilon_0 \leq \PTO(\ArithPeano)$.

  Donc, par double inégalité, on en déduit que
  $\PTO(\ArithPeano) = \varepsilon_0$.
\end{proof}

Cette preuve ouvre finalement la voie à la discipline appelée l'analyse
ordinale, qui étudie les ordinaux de preuve de différentes théories. Dans cette
étude, la théorie $\ArithPeano$ est une théorie particulièrement simple, les
ordinaux de preuve pouvant être beaucoup plus grands dans certaines théories des
types.


\section{Cohérence de l'arithmétique intuitionniste}

D'après le \cref{thm.GG.trad}, un séquent $\Gamma\vdash \varphi$ est prouvable
de façon classique si et seulement si sa traduction $\Gamma^N\vdash \varphi^N$
est prouvable de façon intuitionniste.

On remarque aussi que, comme $\varphi\implies \varphi^N$, on a pour toute
théorie $\mathcal T$ que si $\mathcal T \vdNK \bot$, alors
$\mathcal T \vdNJ \bot$, puisque $\mathcal T \vdNJ\mathcal T^N \vdNJ \bot$ et
la deuxième relation de prouvabilité équivaut à $\mathcal T \vdNK \bot$.
On verra en fait que dans le cas de l'arithmétique, un résultat encore meilleur
peut être prouvé.
 
Ainsi, pour prouver que l'arithmétique de Peano est cohérente, il suffit de
prouver que sa version intuitionniste est cohérente. L'objectif de cette section
est d'établir la cohérence de l'arithmétique de Heyting, variante intuitionniste
de l'arithmétique de Peano, en utilisant la méthode développée par Kleene dans
\cite{Kleene1945}.

\subsection{Arithmétique de Heyting}

La théorie logique de l'arithmétique de Heyting est simple à décrire~: les
axiomes sont les mêmes que l'arithmétique de Peano, on se place simplement dans
$\LJ$ au lieu de $\LK$.

\begin{definition}[Arithmétique de Heyting]
  La théorie de l'arithmétique de Heyting est la théorie du premier ordre sur
  la signature $\mathcal L_{\mathrm{arith}}$ donnée par les mêmes axiomes que
  $\ArithPeano$, mais dans le système formel $\LJ$ (ou de façon équivalente dans
  le système $\NJ$). On note $\HA$ cette théorie.
\end{definition}

A FAIRE

\subsection{BHK et réalisabilité}

On a déjà donné l'interprétation BHK de la logique intuitionniste. Dans cette
interprétation, la correspondance de Curry-Howard peut se lire comme une
implémentation syntaxique de cette sémantique~: la relation de typage permet de
donner un critère décidable pour qu'un programme soit effectivement la preuve
d'un énoncé.

La réalisabilité, introduite par \cite{Kleene1945}, permet de donner une
implémentation plus sémantique de l'interprétation BHK. En particulier, le sens
de la formule
\[\varphi \implies \psi\]
devient celui d'une fonction calculable, assignant des témoins de la vérité de
$\psi$ à des témoins de la vérité de $\varphi$.

La notion de réalisabilité repose sur la relation $x\real \varphi$, qui peut
se lire de différentes façons~:
\begin{itemize}
\item $x$ est une preuve de $\varphi$
\item $\varphi$ s'interprète en une spécification de programme que $x$ réalise
\item $x$ force la vérité de $\varphi$
\end{itemize}
Dans un tel cas, on dira que $x$ réalise $\varphi$, ou que $x$ est un réaliseur
de $\varphi$.

En reprenant l'interprétation BHK avec ces notations, on propose donc de
définir $\real$ de façon inductive comme suit~:
\begin{itemize}
\item $x \real \top$ pour n'importe quel $x$~;
\item $x \real \bot$ jamais~;
\item $x \real n = m$ si $n = m$~;
\item $x \real \varphi \to \psi$ si $x$ s'interprète comme une fonction
  calculable $f$ telle que pour tout $y \real \varphi$, $f(y)\real \psi$~;
\item $x \real \varphi \land \psi$ si $x$ s'interprète comme une paire $(y,z)$
  où $y \real \varphi$ et $z \real \psi$~;
\item $x \real \varphi \lor \psi$ si $x$ s'interprète comme une paire $(i,y)$
  où $i = 0$ et $y \real \varphi$, ou $i = 1$ et $y \real \psi$~;
\item $x \real \forall a, \varphi$ si $x$ s'interprète comme une fonction
  calculable $f$ qui à tout $m$ du domaine de discours,
  $f(m) \real \varphi[m/a]$~;
\item $x \real \forall a, \varphi$ si $x$ s'interprète comme une paire
  $(m,y)$ telle que  $y \real \varphi[m/a]$.
\end{itemize}
L'ensemble des réaliseurs doit donc être un ensemble dans lequel on peut
facilement interpréter des paires et des fonctions, et qui permet aussi
d'encoder les entiers puisque le domaine du discours de l'arithmétique est
$\bN$. Deux choix viennent naturellement en tête, compte tenu des précédents
chapitres~:
\begin{itemize}
\item une énumération $\Enum$ des fonctions calculables,
\item le $\lambda$-calcul.
\end{itemize}

On commence par montrer le modèle de réalisabilité historique, dû à Kleene, qui
se base sur une énumération des fonctions calculables, et on construit ensuite
une variante se basant sur le $\lambda$-calcul.

\subsection{Première algèbre de Kleene}

On adapte la relation de réalisabilité au cas des entiers. Pour donner une
notion formellement satisfaisante de $\real$, on a aussi besoin d'ajouter des
contextes aux formules qu'on interprète, de sorte que les variables libres d'une
formule sont interprétées par des entiers du modèle standard.

\begin{definition}[Réalisabilité de Kleene]
  Soit $\sigma : \Var \partialto \bN$ un environnement pour l'arithmétique. On
  définit, pour $n \in \bN$ et $\varphi \in \Formula$ telle que
  $\VL(\varphi)\subseteq \dom(\sigma)$, la relation $n\real_\sigma \varphi$
  par induction sur $\varphi$~:
  \begin{itemize}
  \item si $\varphi = \top$, alors $n\real_\sigma \varphi$
  \item si $\varphi = \bot$, alors $n\nVdash_\sigma \varphi$
  \item si $\varphi = (t = u)$ et $\sigma(t) = \sigma(u)$, alors
    $n\real_\sigma \varphi$
  \item si $\varphi = (t = u)$ et $\sigma(t) \neq \sigma(u)$, alors
    $n\nVdash_\sigma \varphi$
  \item si $\varphi = \psi \to \chi$, alors
    \[n\real_\sigma\varphi\defeq \forall m \in \bN, m\real_\sigma\psi \implies
    \Enum_n(m) \real_\sigma\chi\]
  \item si $\varphi = \psi \land \chi$, alors
    \[n\real_\sigma\varphi\defeq n = \langle p,q\rangle
    \land p \real_\sigma\psi\land q\real_\sigma\chi\]
  \item si $\varphi = \psi \lor \chi$, alors
    \[n\real_\sigma\varphi \defeq n = \langle i,p\rangle \land
    \begin{cases}
      i = 0 \land p \real_\sigma \psi \\
      \text{ou}\\
      i = 1 \land p \real_\sigma \chi
    \end{cases}\]
  \item si $\varphi = \forall x, \psi$, alors
    \[n\real_\sigma\varphi\defeq\forall m \in \bN,
    \Enum_n(m) \real_{\sigma[x \mapsto m]}\varphi\]
  \item si $\varphi = \exists x, \psi$, alors
    \[n\real_\sigma\varphi \defeq n = \langle p,m\rangle \land
    m\real_{\sigma[x\mapsto p]} \varphi\]
  \end{itemize}
  Si $\sigma = \varnothing$, on note directement $n\real \varphi$.
\end{definition}

Dans l'interprétation que nous offre la réalisabilité, il est clair que
$\bot$ est faux, puisqu'aucun entier ne réalise $\bot$. Il faut cependant
s'assurer qu'être réalisé est une propriété d'ordre logique, c'est-à-dire que
les règles logiques sont valides pour cette interprétation.

On se place ici dans le formalisme de $\NJ$ pour considérer les règles logiques
(par complétude, cela revient au même que de considérer $\LJ$). D'après notre
interprétation de l'implication, la notion d'hypothèse dans un raisonnement
logique est ici représentée par une fonction calculable. Cela signifie,
puisque $\Gamma\vdNJ \varphi$ représente la vérité de $\varphi$ sous les
hypothèses de $\Gamma$, que réaliser $\Gamma\vdNJ\varphi$ demande à associer à
des réaliseurs des formules de $\Gamma$, un réaliseur de $\varphi$. On retrouve
la une structure étroitement liée à la preuve de forte normalisation pour le
$\lambda$-calcul~: l'objectif est de prouver un lemme d'adéquation.

\begin{definition}[Programme tiré d'une preuve]
  On définit inductivement, pour chaque arbre de preuve $\pi\in\ProofNJ$ de
  conclusion $\varphi_1,\ldots,\varphi_n\vdNJ\psi$ et dont toutes les
  variables libres sont parmi $\{x_1,\ldots,x_k\}$, un code $e(\pi)$
  définissant une fonction calculable totale
  $\Enum_{e(\pi)} : \bN^{n+k} \to \psi$~:
  \begin{itemize}
  \item si $\pi = \bottomAlignProof
    \AxiomC{}\RightLabel{Ax}
    \UnaryInfC{$\varphi_1,\ldots,\varphi_n\vdNJ\varphi_i$}
    \DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)} \defeq \pi_i^{n+k}$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{}\RightLabel{$\top_\mathrm i$}
    \UnaryInfC{$\Gamma\vdNJ \top$}\DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)} = 0$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}
    \noLine\UnaryInfC{$\Gamma\vdNJ \bot$}\RightLabel{$\bot_\mathrm e$}
    \UnaryInfC{$\Gamma\vdNJ \varphi$}\DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)} \defeq \Enum^n_{e(\pi')}$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}
    \noLine\UnaryInfC{$\Gamma,\varphi\vdNJ\psi$}\RightLabel{$\to_\mathrm i$}
    \UnaryInfC{$\Gamma\vdNJ\varphi\to\psi$}\DisplayProof$, alors
    $e(\pi) \defeq s_{n+k}^1(e(\pi))$ où la variable abstraite est en
    \ordinalnumeralfeminin{$n$} position.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}
    \noLine\UnaryInfC{$\Gamma\vdNJ \varphi\to\psi$}
    \AxiomC{$\mathlarger{\pi''}$}
    \noLine\UnaryInfC{$\Gamma\vdNJ \varphi$}
    \RightLabel{$\to_\mathrm e$}\BinaryInfC{$\Gamma\vdNJ\psi$}\DisplayProof$,
    alors
    $\Enum^{n+k}_{e(\pi)}(\vec n) \defeq
    \Enum^{n+k}_{e(\pi')}(\vec n)(\Enum^{n+k}_{e(\pi'')}(\vec n))$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi_1}$}
    \noLine\UnaryInfC{$\Gamma\vdNJ \varphi_1$}
    \AxiomC{$\mathlarger{\pi_2}$}
    \noLine\UnaryInfC{$\Gamma\vdNJ \varphi_2$}
    \RightLabel{$\land_\mathrm i$}
    \BinaryInfC{$\Gamma\vdNJ \varphi_1\land\varphi_2$}
    \DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)}(\vec n) \defeq \langle-,-\rangle \circ
    (\Enum^{n+k}_{e(\pi_1)},\Enum^{n+k}_{e(\pi_2)})$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine
    \UnaryInfC{$\Gamma\vdNJ \varphi_1\land\varphi_2$}
    \RightLabel{$\land_\mathrm e^i$}
    \UnaryInfC{$\Gamma\vdNJ \varphi_i$}
    \DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)} \defeq \pi_i\circ \Enum^{n+k}_{e(\pi')}$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine
    \UnaryInfC{$\Gamma\vdNJ\varphi_i$}
    \RightLabel{$\lor_\mathrm i^i$}
    \UnaryInfC{$\Gamma\vdNJ\varphi_1\lor\varphi_2$}
    \DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)} \defeq
    (x \mapsto \langle i,x\rangle) \circ \Enum^{n+k}_{e(\pi')}$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine
    \UnaryInfC{$\Gamma\vdNJ \varphi_1\lor\varphi_2$}
    \AxiomC{$\mathlarger{\pi_1}$}\noLine
    \UnaryInfC{$\Gamma,\varphi_1\vdNJ \chi$}
    \AxiomC{$\mathlarger{\pi_2}$}\noLine
    \UnaryInfC{$\Gamma,\varphi_2\vdNJ\chi$}
    \TrinaryInfC{$\Gamma\vdNJ\chi$}
    \DisplayProof$, alors
    \begin{multline*}
      \Enum^{n+k}_{e(\pi)}(\vec n) \defeq
      \ifrm \pi_1(\Enum^{n+k}_{e(\pi')}(\vec n)) 
      \thenrm \Enum^{n+1+k}_{e(\pi_1)}(\vec n, \pi_2(\Enum^{n+k}_{e(\pi')}(\vec n)))\\
      \elserm \Enum^{n+1+k}_{e(\pi_2)}(\vec n, \pi_2(\Enum^{n+k}_{e(\pi')}(\vec n)))
    \end{multline*}
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine
    \UnaryInfC{$\Gamma\vdNJ \varphi$}
    \RightLabel{$\forall_\mathrm i^\dagger$}
    \UnaryInfC{$\Gamma\vdNJ\forall x, \varphi$}
    \DisplayProof$, alors $e(\pi) \defeq s_{n+k}^1(e(\pi'))$ où la variable
    abstrait est en \ordinalnumeralfeminin{$n+k$} position.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine
    \UnaryInfC{$\Gamma\vdNJ \forall x, \varphi$}
    \RightLabel{$\forall_\mathrm e$}
    \UnaryInfC{$\Gamma\vdNJ\varphi[t/x]$}
    \DisplayProof$, alors en considérant $f_t : \bN^k \to \bN$ la fonction
    naturellement associée au terme $t$,
    $\Enum^{n+k}_{e(\pi)}(\vec n,\vec k) \defeq
    \Enum^{n+k}_{e(\pi')}(\vec n,\vec k)(f_t(\vec k))$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine
    \UnaryInfC{$\Gamma\vdNJ\varphi[t/x]$}
    \RightLabel{$\exists_\mathrm i$}
    \UnaryInfC{$\Gamma\vdNJ\exists x, \varphi$}
    \DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)}(\vec n,\vec k) \defeq \langle f_t(\vec k),
    \Enum^{n+k}_{e(\pi')}(\vec n,\vec k)\rangle$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine
    \UnaryInfC{$\Gamma\vdNJ\exists x, \varphi$}
    \AxiomC{$\mathlarger{\pi''}$}\noLine
    \UnaryInfC{$\Gamma, \varphi\vdNJ \psi$}
    \RightLabel{$\exists_\mathrm e^\dagger$}
    \BinaryInfC{$\Gamma\vdNJ\psi$}
    \DisplayProof$, alors
    \begin{center}
      $\Enum^{n+k}_{e(\pi)}(\vec n, \vec k) \defeq
      \Enum^{n+1+k}_{e(\pi'')}(\vec n,
      \pi_1(\Enum^{n+k}_{e(\pi')}(\vec n, \vec k)),\vec k)$
    \end{center}
  \item si $\pi = \bottomAlignProof
    \AxiomC{}\RightLabel{$=_\mathrm i$}
    \UnaryInfC{$\vdNJ t = t$}\DisplayProof$, alors
    $\Enum^{n+k}_{e(\pi)}(\vec n, \vec k)\defeq 0$.
  \item si $\pi = \bottomAlignProof
    \AxiomC{$\mathlarger{\pi'}$}\noLine\UnaryInfC{$\Gamma\vdNJ t = u$}
    \AxiomC{$\mathlarger{\pi''}$}\noLine\UnaryInfC{$\Gamma\vdNJ\varphi[t/x]$}
    \RightLabel{$=_\mathrm e$} \BinaryInfC{$\Gamma\vdNJ\varphi[u/x]$}
    \DisplayProof$, alors
    $e(\pi) \defeq e(\pi'')$.
  \end{itemize}
\end{definition}

\begin{lemma}[Adéquation]
  Pour tout arbre de preuve $\pi \in \ProofNJ$ de conclusion
  $\varphi_1,\ldots,\varphi_n \vdNJ \psi$ et dont les variables libres sont
  $x_1,\ldots,x_k$, pour tout environnement $\sigma$ défini sur
  $x_1,\ldots,x_k$, et pour tous entiers $e_1,\ldots,e_n$ tels que
  \[\forall i \in \{1,\ldots,n\}, e_i\real_{\sigma} \varphi_i\]
  on a
  \[e(\pi)(e_1,\ldots,e_n,\sigma(x_1),\ldots,\sigma(x_k))\real_\sigma \psi\]
\end{lemma}

\begin{exercise}
  Prouver le lemme d'adéquation.
\end{exercise}

\begin{corollary}
  L'ensemble
  \[\mathcal T_{\real} \defeq \{\varphi \in \Prop\mid \exists n \in \bN,
  n\real \varphi\}\]
  est une théorie logique cohérente.
\end{corollary}

\begin{proof}
  Par le lemme d'adéquation, on sait que $\real$ est clos par conséquence
  syntaxique. De plus, on a défini $\bot$ comme n'ayant aucun réaliseur, donc
  $\bot\notin\mathcal T_{\real}$, on en déduit donc que
  $\mathcal T_{\real}\nvdash_{\NJ} \bot$.
\end{proof}

On a donc prouvé que les formules réalisées par les fonctions calculables
forment une théorie cohérente. Pour en déduire la cohérence de l'arithmétique de
Heyting, il nous suffit alors de montrer que les axiomes de $\HA$ sont réalisés.

\begin{lemma}
  On a l'inclusion $\HA\subseteq\mathcal T_{\real}$.
\end{lemma}

\begin{proof}
  Seule la récurrence demande à être précisée~: les autres axiomes sont
  réalisés automatiquement parce qu'ils le sont sémantiquement dans $\bN$, et
  que l'égalité ne tient compte que de cet aspect sémantique.

  Pour la récurrence, on remarque que la construction de récursion primitive
  permet d'obtenir le résultat~: supposons données deux fonctions
  $f(\vec n)$ et $g(\vec n,m,p)$ telles que
  \[f(\vec n)\real_{\vec n} \varphi[0/x]\quad\text{et}\quad
  g(\vec n) \real_{\vec n} \forall x, \varphi \to \varphi[Sx/x]\]
  Alors la fonction $\rec(f,g)$ vérifie~:
  \begin{itemize}
  \item $\rec(f,g)(\vec n,0) = f(\vec n)$ donc réalise $\varphi[0/x]$
  \item $\rec(f,g)(\vec n,Sm) = g(\vec n,m,\rec(f,g)(\vec n,m))$ donc par
    récurrence sur $m$, on obtient que
    $\rec(f,g)(\vec n,m) \real_{\vec n} \varphi[m/x]$ puis, par
    application de $g$, que la fonction réalise $\varphi[Sm/x]$
  \end{itemize}
  donc $\rec$ réalise uniformément le schéma d'axiomes de récurrence.
\end{proof}

\begin{theorem}[Cohérence de l'arithmétique de Heyting \cite{Kleene1945}]
  La théorie $\HA$ est cohérente.
\end{theorem}

\begin{proof}
  On a prouvé que $\HA \subseteq \mathcal T_{\real}$ et que
  $\mathcal T_{\real}\nvdash_{\NJ} \bot$, donc $\HA$ ne peut pas prouver
  $\bot$, donc $\HA$ est cohérente.
\end{proof}

\subsection{Cas du $\lambda$-calcul}

On propose une seconde construction, très similaire à la première, mais
utilisant le $\lambda$-calcul.

On utilise dans cette sous-section $\STSet$ comme ensemble des termes. Ces
termes ne sont pas \latinexpr{a priori} typés. On verra cependant que le lemme
d'adéquation permet de faire un lien entre la réalisabilité et le typage. On
commence par définir la relation de réalisabilité qu'on va utiliser. On commence
par construire une version de logique minimale de la réalisabilité, pour cerner
les difficultés à venir.

\begin{definition}[Réalisabilité pour la logique minimale]
  On considère la relation $\real\subseteq \lamSet\times \Formula$ définie par
  induction sur $\varphi \in \Formula$~:
  \begin{itemize}
  \item $t \real \top$ toujours~;
  \item $t \real \bot$ jamais~;
  \item $t\real \varphi \to \psi \defeq \forall u \real \varphi, t\;u \real
    \psi$
  \end{itemize}
\end{definition}

D'après la correspondance de Curry-Howard, on sait que les formules peuvent
s'interpréter comme des types. Ainsi, $\vdash t : \varphi$ et
$t\real \varphi$ semblent fortement liés. En fait, la définition de
$t\real \varphi \to \psi$ semble identique à la définition de
$\semT{\varphi\to\psi}$. Cela nous mène naturellement à l'énoncé suivant~:
\begin{quote}
  Pour toute dérivation de typage
  $x_1:\varphi_1,\ldots,x_n:\varphi_n\vdash t : \varphi$ si pour tous
  $i \in\{1,\ldots,n\}$ on dispose d'un terme $t_i \real \varphi_i$ alors
  $t[t_i/x_i] \real \varphi$.
\end{quote}
Comme dans le cas du lemme d'adéquation pour la forte normalisation, il est
nécessaire d'avoir une propriété de saturation pour vérifier que la règle
de typage de l'abstraction $\lambda$ est adéquate. Cependant, on n'a ici aucun
problème à utiliser l'antiréduction dans toute sa généralité, sans la
restreindre à une forme de réduction de tête faible. Comme la définition de la
réalisation de $\lor$ par exemple demande de quantifier sur les interprétation
de toutes les formules, on a encore besoin d'introduire un ensemble de candidats
préalables.

\begin{definition}[Ensemble saturé]
  On appelle ensemble saturé un ensemble de termes $A \subseteq \STSet$ tel
  que si $t \STred u$ et $u \in A$ alors $t \in A$. On note $\satur$
  l'ensemble des parties saturées de $\STSet$.
\end{definition}

\begin{exercise}
  Prouver que $\satur$ est un treillis complet pour l'inclusion, dont le
  majorant est $\STSet$ et le minorant est $\varnothing$, la borne supérieure
  est donnée par l'union et la borne inférieure donnée par l'intersection.
\end{exercise}

\begin{definition}[Réalisabilité d'une formule]
  Soit $\rho : \Var \to \bN$ un environnement d'interprétation.
  On définit la relation $\real_\rho\subseteq \STSet\times\Formula$ par
  induction sur $\varphi\in\Formula$~:
  \begin{itemize}
  \item si $\varphi = \top$ alors $t \real_\rho \varphi$
  \item si $\varphi = \bot$ alors $t\nVdash_\rho\varphi$
  \item si $\varphi = (t = u)$ où $\rho(t) = \rho(u)$ alors
    $t \real_\rho \varphi$
  \item si $\varphi = (t = u)$ où $\rho(t) \neq \rho(u)$ alors
    $t\nVdash_\rho \varphi$
  \item si $\varphi = \psi \to \chi$ alors
    \[t\real_\rho \varphi \defeq \forall u \real_\rho \psi, t\;u \real_\rho \chi\]
  \item si $\varphi = \psi \land \chi$ alors
    \[t\real_\rho \varphi \defeq
    (\pi_1\;t\real_\rho \psi) \land (\pi_2\;t\real_\rho \chi)\]
  \item si $\varphi = \psi \land \chi$ alors
    \begin{multline*}
      t \real_\rho \varphi \defeq
      \forall A \in \satur,\forall u,v \in\STLCSet,\\
      (\forall w \real_\rho \psi, u[w/x] \in A) \implies
      (\forall w \real_\rho \chi, u[w/x] \in A)\implies \\
      \deltaSTLC t x u x v \in A
    \end{multline*}
  \item si $\varphi = \forall x, \psi$ alors
    \[t \real_\rho \varphi \defeq \forall n \in \bN,
    t\real_{\rho[x\mapsto n]} \psi\]
  \item si $\varphi = \exists x, \psi$ alors
    \[t \real_\rho\varphi\defeq \exists n \in \bN,
    t\real_{\rho[x\mapsto n]} \psi\]
  \end{itemize}
  
  On définit aussi
  $\semT{\varphi}_\rho \defeq \{t \in \STSet\mid t \real_\rho \varphi\}$.
  Dans le cas où $\rho = \varnothing$, on écrit simplement $t \real \varphi$ et
  $\semT{\varphi}$.
\end{definition}

\begin{exercise}
  Montrer que pour toute formule $\varphi$, $\semT\varphi\in\satur$. Montrer
  que pour tout $n \in \bN$, on a
  \[t\real_{\rho[x\mapsto n]} \varphi \iff t \real_\rho \varphi[\encode n/x]\]
\end{exercise}

On peut ainsi prouver le lemme d'adéquation.

\begin{lemma}[Adéquation]
  Pour tout typage $x_1:\varphi_1,\ldots,x_n:\varphi_n\vdash t : \varphi$, tout
  environnement $\rho$ et termes $t_1,\ldots,t_n$ tels que
  $t_i \real_\rho \varphi_i$, on a
  \[t[t_i/x_i] \real_\rho\varphi\]
\end{lemma}

\begin{exercise}
  Prouver le lemme d'adéquation.
\end{exercise}

\begin{corollary}
  La théorie
  \[\mathcal T_{\real} \defeq
  \{\varphi\in\Formula\mid\semT\varphi\neq\varnothing\}\]
  est une théorie cohérente.
\end{corollary}

On pourrait être tenté d'en déduire que $\HA$ est une théorie cohérente, comme
on l'a fait avec les machines de Turing. Cependant, cela est faux en l'état.
On n'a en effet pas de moyen de prouver que la récurrence est réalisée. Cela est
dû au fait que la définition de $t\real \forall x, \varphi$ signifie ici que
$t$ est le même terme pour réaliser uniformément toutes les instances de
$\varphi[\encode n/x]$ avec $n \in \bN$. Dans le principe de récurrence, comme
on a pu le voir dans l'élimination des coupures, il est nécessaire d'effectuer
un calcul qui dépend de l'entrée en elle-même.

On peut être tenté de changer la définition de $\real$, de sorte que
$t\real \forall x, \varphi$ signifie que pour tout $n$,
$t\;\encode n \real\varphi[\encode n/x]$. Une telle modification fonctionne,
mais on préfère introduire une méthode plus efficace, permettant d'enrichir le
langage plutôt que de simplement modifier la relation de réalisabilité.

\begin{definition}[Formules arithmétiques relativisées]
  On définit le langage des formules arithmétiques relativisées en ajoutant le
  constructeur de formule
  \[\varphi \Coloneq \cdots \mid \bN(\btermt)\]
  où $t$ est un terme arithmétique (et tous les cas précédents définissant les
  formules arithmétiques sont conservés).
\end{definition}

L'intérêt du prédicat $\bN(\btermt)$ est en fait d'être réalisé (dans
l'environnement $\rho$) par le terme $\encode{\rho(\btermt)}$.

\begin{definition}[Réalisation d'une formule arithmétique relativisée]
  On définit $t\real_\rho \varphi$ comme précédemment, en ajoutant le cas
  \[t\real_\rho \bN(\btermt) \defeq t \STred^\star \encode{\rho(\btermt)}\]
\end{definition}

On a ainsi un prédicat $\bN(x)$ à un paramètre, qui permet de décrire la classe
des entiers. En un sens, cette classe est celle des entiers standards~: les
$x$ vérifiant $\bN(x)$ sont ceux muni d'un entier concret réalisé par un
programme. On peut maintenant définir considérer, plutôt que $\HA$, la version
relativisée
\[\HA^\bN \defeq \{\varphi^\bN\mid \varphi \in \Formula\}\]
où $\varphi^\bN$ est la formule relativisée telle qu'introduite dans la
\cref{def.relativisation}.

\begin{lemma}[Adéquation]
  En ajoutant les règles de typages suivantes~:
  \begin{center}
    \begin{tabular}{cc}
      \bottomAlignProof
      \AxiomC{}
      \RightLabel{$0$}
      \UnaryInfC{$\Gamma\vdash 0 : \bN(0)$}
      \DisplayProof
      &
      \bottomAlignProof
      \AxiomC{$\Gamma\vdash t : \bN(\btermt)$}
      \RightLabel{$S$}
      \UnaryInfC{$\Gamma\vdash S\;t : \bN(S\;\btermt)$}
      \DisplayProof
      \\
      \\
      \multicolumn{2}{c}{
        \AxiomC{$\Gamma\vdash t : \varphi(0)$}
        \AxiomC{$\Gamma\vdash u :
          \forall \bvarx,\bN(\bvarx)\to\varphi(\bvarx)\to\varphi(S\;\bvarx)$}
        \AxiomC{$\Gamma\vdash v : \bN(\btermt)$}
        \RightLabel{$\mathrm{Rec}$}
        \TrinaryInfC{$\Gamma\vdash \rec\;t\;u\;v : \varphi(\btermt)$}
        \DisplayProof
      }
    \end{tabular}
  \end{center}

  Alors pour tout environnement d'interprétation $\rho$, pour tous
  $\Gamma\vdash t : \varphi$, $\sigma : \lamVar \to \STSet$ tels que
  $(x : \psi) \in \Gamma \implies \sigma(x) \real_\rho \psi$,
  on a $\sigma(t) \real_\rho \varphi$.
\end{lemma}

Dans ce cas, cependant, il devient clair que le schéma d'axiomes de récurrence
est vérifié par le constructeur Rec. On en déduit le théorème suivant.

\begin{theorem}[Cohérence de l'arithmétique]
  La théorie $\HA^\bN$ est cohérente.
\end{theorem}

\begin{proof}
  Tous les axiomes de $\HA^\bN$ sont réalisés, donc
  $\HA^\bN\subseteq \mathcal T_\real$, donc la cohérence de $\mathcal T_\real$
  implique celle de $\HA^\bN$, d'où le résultat.
\end{proof}

\begin{exercise}
  En déduire que $\HA$ est cohérente.
\end{exercise}
