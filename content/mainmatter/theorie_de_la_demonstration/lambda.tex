\chapter{Lambda calcul}
\label{chp.lambda}

\minitoc

\lettrine{D}{ans} le \cref{chp.recur}, nous avons abordé deux systèmes de
calcul~: les fonctions récursives et les machines de Turing. Le formalisme des
fonctions récursives a été introduit par Kleene dans \cite{Kleene1936} sur la
base des fonctions récursives primitives mises en avant par Skolem
\cite{skolem1923begrundung}. Cependant, Kleene utilisait aussi de son propre
aveu des intuitions issues d'un autre formalisme, celui de son maître de thèse~:
Church.

Le formalisme du $\lambda$-calcul a en effet été introduit par Church dans
\cite{Church1932}, en tant que formalisme équationnel et logique~: les termes
construits par les abstractions et les applications permettent de construire des
objets dans une certaine théorie logique (contrairement à la vision plus
moderne dans laquelle on considère un simple ensemble de $\lambda$-termes avec
des règles de réécriture). Relevons que Kleene et Rosser (ses élèves) ont
participé au développement du $\lambda$-calcul, en en prouvant d'abord
l'incohérence dans \cite{KleeneRosser1935}, mais aussi en participant à la
preuve que les fonctions codées par le $\lambda$-calcul sont exactement les
fonctions calculables au sens des fonctions calculables de Herbrand-Gödel.

Ce formalisme est donc plus ancien que ceux que nous avons déjà présentés.
Pourtant, le $\lambda$-calcul est encore au c\oe ur des recherches modernes en
informatique théorique et en logique, pour son aspect combinatoire et,
comme nous le verrons dans le \cref{chp.lambda_type}, pour la richesse des
systèmes de types.

Dans ce chapitre, nous nous concentrons sur l'aspect non typé du formalisme.
Les ressources ne manquent pas sur le sujet, et vont plus loin que ce chapitre
introductif~: nous conseillons \cite{Barendregt1984,krivine1993lambda,selinger},
qui abordent aussi la version typée du calcul.

Nous abordons d'abord la définition des $\lambda$-termes, de la
$\beta$-réduction et la gestion de l'$\alpha$-équivalence. Nous donnons ensuite
le théorème d'équivalence entre le $\lambda$-calcul et les fonctions récursives.
Enfin, nous étudions les propriétés des réductions, en montrant par exemple le
théorème de standardisation ou la propriété de Church-Rosser.

\section{Premiers pas en $\lambda$-calcul}

Pour introduire le $\lambda$-calcul, commençons par présenter un cas simple
d'expression arithmétique~:
\[e\defeq x + 2y\]
l'expression $e$ comporte des variables libres, ce qui signifie qu'elle peut se
considérer comme une fonction qui, à une valeur fixée de $x$ et de $y$,
retourne la valeur de l'expression. On pourrait cependant souhaiter que nos
expressions permettent aussi de parler de fonctions, de la même façon qu'elles
parlent d'entiers.

Pour travailler avec des fonctions, deux points sont essentiels~:
\begin{itemize}
\item avoir un moyen de construire une fonction (un constructeur)~;
\item avoir un moyen d'appliquer une fonction à un argument (un destructeur).
\end{itemize}
La façon naturelle de construire une fonction est alors de considérer une
expression, telle que $e$, et d'abstraire une de ses variables pour en faire
un argument de fonction, ce que l'on notera
\[e' \defeq \lambda x.e\]
pour définir la fonction qui, à $a$ associe l'évaluation de $e$ où $x$ prend la
valeur $a$. L'expression résultante, $e'$, est alors une fonction pour chaque
paramètre $y$ fixé, et on pourrait donc définir encore
\[e'' \defeq \lambda y.e'\]
pour obtenir une fonction, retournant elle-même une fonction.

On obtient donc assez naturellement un formalisme, dans lequel on se permet de
construire à partir d'expressions, de nouvelles expressions représentant des
fonctions. L'autre étape, l'application d'une fonction à un argument, est alors
naturelle~: si $e$ et $e'$ sont des expressions, alors $e(e')$ est une nouvelle
expression qui s'évalue en l'application de la fonction représentée par $e$
en la valeur représentée par $e'$.

\subsection{Termes, substitutions, réductions}

Les deux principes d'abstraction et d'application nous suffisent en fait, comme
nous allons le voir, pour définir l'ensemble des fonctions calculables, dans
un formalisme où toutes les expressions sont des fonctions sur toutes les
expressions possibles. Au lieu d'évaluer des expressions, on décide alors de
travailler de façon purement syntaxique, en créant une relation représentant
l'évaluation d'une expression, encore appelée $\lambda$-terme.

\begin{definition}[$\lambda$-terme - \ordinalnumeralfeminin{1} version]
  On fixe un ensemble $\lamVar$ dénombrable de $\lambda$-variables, dont on
  notera les éléments $x,y,z,\ldots$ On définit l'ensemble $\lamSet_0$ des
  $\lambda$-termes par la BNF suivante~:
  \[t,u\Coloneq x\mid \lambda x.t\mid t\;u\]
  Un terme de la forme $x \in \lamVar$ est appelé une variable, un terme de la
  forme $\lambda x.t$ est appelé une abstraction, et un terme de la forme
  $t\;u$ est appelé une application.
\end{definition}

\begin{remark}
  Plusieurs conventions existent pour parenthéser des $\lambda$-termes. La
  convention à la Krivine, par exemple, est d'écrire $(t)u$ pour le terme
  $t\;u$ précédent. Donc notre cas, nous appliquons un parenthésage uniquement
  pour supprimer des ambigüités, et définissons l'application comme associative
  à gauche, ce qui signifie que $t\;u\;v$ doit se lire $(t\;u)\;v$.
\end{remark}

Les $\lambda$-termes représentent donc des fonctions lorsqu'ils sont de la
forme $\lambda x.t$, mais tout terme peut s'appliquer à tout autre terme, donc
même un terme de la forme $x$ ou $t\;u$ peut s'appliquer à un autre terme.

Cependant, c'est bien pour un terme de la forme $\lambda x.t$ que l'idée de
fonction prend tout son sens. On peut alors, naturellement, imaginer comment
réduire (de façon purement syntaxique) une fonction appliquée à un argument~:
si je considère $f(a)$ et que $f$ est de la forme $x \mapsto e$, alors
$f(a)$ correspond exactement à l'expression $e$ dans laquelle $x$ a été
substitué par $a$.

La même idée permet alors de définir une réduction sur les $\lambda$-termes,
en réduisant $(\lambda x.t)u$ en l'expression $t$ où $u$ remplace $x$. On a donc
besoin de la notion de substitution.

\begin{definition}[Substitution - \ordinalnumeralfeminin{1} version]
  Soient $t,u\in\lamSet_0$ et $x \in \lamVar$. On définit la substitution de
  $x$ par $u$ dans $t$, notée $t[u/x]$, par induction sur $t$~:
  \begin{itemize}
  \item si $t = x$, alors $t[u/x] \defeq u$.
  \item si $t = y$ où $y \in \lamVar$ et $y \neq x$, alors $t[u/x] \defeq t$.
  \item si $t = \lambda x.t'$, alors $t[u/x] \defeq t$.
  \item si $t = \lambda y.t'$ où $y \neq x$, alors
    $t[u/x] \defeq \lambda y.t'[u/x]$.
  \item si $t = t'\;t''$, alors $t[u/x] \defeq (t'[u/x])\;(t''[u/x])$.
  \end{itemize}
\end{definition}

En réalité, cette définition n'est pas bonne. Prenons par exemple le terme
$t \defeq \lambda x.\lambda y.z$ et le terme $u \defeq x$. On a alors l'égalité
\[t[u/z] = \lambda x.\lambda y.x\]
qui correspond moralement à prendre un argument, puis retourner la fonction
constante en cet argument. Pourtant, si on considère
$t' \defeq \lambda a.\lambda y.z$, alors $t'[u/z]$ est un terme qui se
comporte bien différemment, car la variable $x$ de $u$ n'est alors pas capturée.

Pourtant, il est clair que la fonction $x \mapsto e(x)$ et la fonction
$y \mapsto e(y)$ doivent être les mêmes, et la substitution ne devrait donc pas
donner deux résultats différents. Il nous faut donc d'abord gérer les variables
libres d'un terme.

\begin{definition}[Variable libre]
  Soit $t \in \lamSet_0$, on définit par induction sur $t$ les ensembles $\VLie$
  de ses variables et $\VL(t)$ de ses variables libres~:
  \begin{itemize}
  \item si $t = x$ alors $\VLie(x) = \varnothing$ et $\VL(t) = \{x\}$.
  \item si $t = \lambda x.t'$ alors $\VLie(t) = \{x\} \cup \VLie(t')$ et
    $\VL(t) = \VL(t')\setminus\{x\}$.
  \item si $t = t'\;t''$ alors $\VLie(t) = \VLie(t') \cup \VLie(t'')$ et
    $\VL(t) = \VL(t') \cup \VL(t'')$.
  \end{itemize}

  Si $\VL(t) = \varnothing$, alors on dit que $t$ est un terme clos.
\end{definition}

Avec la notion de variable libre, on peut procéder à une correction importante~:
si $t,u \in \lamSet$, pour effectuer la substitution $t[u/x]$ et éviter toute
capture de variable, il nous suffit de demander que
$\VLie(t)\cap\VL(u)=\varnothing$. Cette condition, comme on l'a vu précédemment,
n'est pas pour autant toujours respectée, mais on remarque qu'il nous suffit
de modifier les variables liées de $t$ pour l'assurer. Intuitivement, puisque
$x$ est une variable muette dans $\lambda x.t$, il est parfaitement légitime
de considérer égaux les termes $\lambda x.t$ et $\lambda y.t[y/x]$.

\begin{definition}[$\alpha$-équivalence]
  On définit la relation d'$\alpha$-équivalence $=_\alpha$ comme la plus petite
  congruence sur $\lamSet_0$ contenant les paires
  \[\lambda x.t =_\alpha \lambda y.t[y/x]\]
  où $y \notin \VL(t)$.
\end{definition}

\begin{definition}[$\lambda$-terme - \ordinalnumeralfeminin{2} version]
  L'ensemble $\lamSet$ est défini comme le quotient par l'$\alpha$-équivalence~:
  \[\lamSet \defeq \lamSet_0 / =_\alpha\]
\end{definition}

\begin{remark}
  Dans $\lamSet$, l'ensemble $\VL$ est bien défini mais l'ensemble $\VLie$ ne
  l'est pas.
\end{remark}

On peut maintenant vérifier le lemme permettant d'éviter les captures de
variables.

\begin{lemma}
  Soient $t,u \in \lamSet_0$, alors il existe $t' \in \lamSet_0$ tel que
  $t' =_\alpha t$ et tel que $\VLie(t') \cap \VL(u) =\varnothing$.
\end{lemma}

\begin{proof}
  Il suffit, pour chaque abstraction dans $t$ liant une variable $x$ libre dans
  $u$, de remplacer $x$ par une variable $y \notin\VL(u)$ (comme $\lamVar$
  est infini, il existe un tel $y$) grâce à l'$\alpha$-équivalence.
\end{proof}

On peut maintenant définir la substitution sans capture de variable.

\begin{definition}[Substitution - \ordinalnumeralfeminin{2} version]
  Soient $t,u\in\lamSet_0$ et $x \in \lamVar$. On définit la substitution sans
  capture, de $x$ par $u$ dans $t$, notée $t[u/x]$, par induction sur $t$~:
  \begin{itemize}
  \item si $t = x$, alors $t[u/x] \defeq u$.
  \item si $t = y$ où $y \in \lamVar$ et $y \neq x$, alors $t[u/x] \defeq t$.
  \item si $t = \lambda x.t'$, alors $t[u/x] \defeq t$.
  \item si $t = \lambda y.t'$ où $y \notin \VL(u)$, alors
    $t[u/x] \defeq \lambda y.t'[u/x]$.
  \item si $t = t'\;t''$, alors $t[u/x] \defeq (t'[u/x])\;(t''[u/x])$.
  \end{itemize}
\end{definition}

\begin{proposition}
  Pour tous $t,u \in \lamSet$ et $x \in \lamVar$, il existe au moins un
  représentant $t_0 \in t$ et un représentant $u_0 \in u$ tels que
  $t_0[u_0/x]$ est bien défini, et pour tous $t_1\in t, u_1\in u$,
  $t_0[u_0/x] =_\alpha t_1[u_1/x]$ si cette dernière valeur est définie.
\end{proposition}

\begin{notation}
  On note désormais $t[u/x]$ le résultat de cette substitution relevé en tant
  que fonction $\lamSet\times\lamSet\times\lamVar \to \lamSet$.
\end{notation}

\begin{exercise}
  Montrer la proposition précédente.
\end{exercise}

On peut maintenant définir correctement la notion de réduction sur des
$\lambda$-termes.

\begin{definition}[$\beta$-réduction]
  On définit la $\beta$-réduction, notée $\bred$, comme la plus petite relation
  $\bred\subseteq\lamSet\times\lamSet$ compatible et contenant les paires
  \[(\lambda x.t)u\bred t[u/x]\]
  On appelle redex (\foreignexpr{reducible expression}) les sous-termes d'un
  terme $t$ de la forme $(\lambda x.u)v$.
\end{definition}

\begin{remark}
  Notre définition de relation compatible ne peut techniquement plus s'appliquer
  pusqu'on travaille ici avec des classe d'équivalences et non directement
  avec l'ensemble inductif. Cependant, il est clair qu'on peut définir
  $\bred$ sur l'ensemble $\lamSet_0$ puis le relever à l'ensemble $\lamSet$.
  Ce type de procédure étant purement technique et peu profonde, on continuera
  de travailler de la même façon sur $\lamSet$ et sur $\lamSet_0$, en
  considérant que toutes les opérations et relations qu'on définit se relèvent
  en pratique en des opérations et relations sur $\lamSet$.
\end{remark}

Si on considère un $\lambda$-terme comme un programme, la réduction $\bred$
consiste à exécuter le programme, en obtenant potentiellement une valeur.

\begin{exercise}
  On définit les $\lambda$-termes~:
  \[\omega \defeq \lambda x.x\;x \qquad \Omega\defeq \omega\;\omega\]
  Vérifier que $\Omega\bred \Omega$. En déduire que la relation $\bred$ n'est
  pas normalisante.
\end{exercise}

La $\beta$-réduction permet de définir un processus de calcul qui est dirigé~:
il cherche à remplacer les redexes et poursuit ainsi autant que possible. On
peut cependant être intéressé par une autre relation à partir de la
$\beta$-réduction, en considérant que le processus de calcul nous donne une
notion d'égalité de programmes.

\begin{definition}[$\beta$-équivalence]
  On définit la relation $\Beq$ comme la plus petite congruence contenant
  $\bred$.
\end{definition}

\begin{exercise}\label{exo.subst.subst}
  Soient $t,u,v \in \lamSet$, $x,y\in \lamVar$. Montrer l'égalité
  \[t[u/x][v/y] = t[v[u/x]/y][u/x]\]
\end{exercise}

\begin{exercise}\label{exo.subst.red}
  Soient $t,t',u\in\lamSet, x \in \lamVar$. Montrer que si $t\bred t'$ alors
  $t[u/x] \bred t'[u/x]$. Pour $t,u,u'\in\lamSet$ tels que $u \bred u'$,
  montrer que $t[u/x] \bred^\star t'[u/x]$. Montrer que, suivant la forme de
  $t$, la réduction précédente peut se faire en $0$ étapes ou, au contraire
  en plus de $2$ étapes.
\end{exercise}

\paragraph{La curryfication}
Un point important est la gestion de fonctions à plusieurs variables. Pour
l'instant, le constructeur $\lambda$ ne permet d'abstraire qu'une variable.
Cependant, il est possible d'accumuler les abstractions, pour écrire par exemple
\[\lambda x.\lambda y.x\]
Comment se comporte un tel terme ? Il prend en argument un terme $t$, pour
retourner une fonction prenant elle-même en argument un terme $u$, puis
retourne finalement $t$. La fonction totale a donc deux arguments, en retournant
chaque fois une fonction tant que tous les arguments ne sont pas donnés. On
appelle ce procédé la curryfication, et on peut le décrire par l'isomorphisme
\[((X\times Y) \to Z)\cong X \to (Y \to Z)\]
On comprend alors l'intérêt de la notation $t\;u\;v$ pour écrire $(t\;u)\;v$,
puisqu'alors en voyant $t$ comme une fonction à deux argument curryfiée,
$t\;u\;v$ représente bien la fonction à laquelle on donne les deux arguments
$u$ et $v$.

\subsection{La relation $\eta$}

Continuons notre exploration du $\lambda$-calcul. Le lecteur catégoricien
peut trouver une ressemblance entre ce calcul et le langage catégorique, en ce
qu'il se concentre sur un langage portant sur les fonctions. Dans le cadre
catégorique, une catégorie possède des fonctions identités $\id_X$ et une
opération de composition $\circ$. Ces fonctions peuvent s'écrire dans le
$\lambda$-calcul.

\begin{definition}[Identité et composition]
  On définit les deux $\lambda$-termes suivants~:
  \[\id \defeq \lambda x.x \qquad \circ \defeq
  \lambda f.\lambda g.\lambda x.f\;(g\;x)\]
  On notera naturellement $f\circ g$ pour $\circ\;f\;g$.
\end{definition}

Comme avec les catégories, on peut s'attendre à une théorie équationnelle
exprimant que $\id$ est neutre pour la composition, et que la composition est
associative.

Pour la composition, il nous suffit de faire le calcul~:
\begin{align*}
  f\circ (g\circ h) &\bred^2 \lambda x. f\;((g\circ h) x)\\
  &\bred^2 \lambda x. f\;(g\;(h\;x))\\
  (f\circ g)\circ h) &\bred^2 \lambda x. (f\circ g)\;(h\;x)\\
  &\bred^2 \lambda x. f\;(g\;(h\;x))\\
  &\Beq f\circ (g\circ h)
\end{align*}

On veut maintenant montrer que $\id\circ f \Beq f$, mais la réduction de
l'expression de gauche nous donne
\[\lambda x.f\;x\]
Cette fonction, représentant $x \mapsto f(x)$, semble parfaitement identique à
$f$~: elle associe les mêmes valeurs aux mêmes arguments. Cette égalité n'est
pourtant pas vérifiée dans $\Beq$ (on pourra le prouver avec la propriété de
Church-Rosser), mais elle peut s'axiomatiser.

\begin{definition}[\'Egalité extensionnelle]
  On définit l'égalité extensionnelle $\cong$ comme la plus petite congruence
  contenant $\Beq$ et vérifiant la règle
  \begin{prooftree}
    \AxiomC{$\forall u \in \lamSet, t\;u \cong t'\;u$}
    \UnaryInfC{$t \cong t'$}
  \end{prooftree}
\end{definition}

On peut alors vérifier que $\id\circ f \cong f$. Cependant, la relation $\cong$
est définie de façon sémantique, et quantifie sur un ensemble infini qu'est
$\lamSet$. On remarque pourtant que, dans le cas précédent, il nous suffit
de réduire $\lambda x.f\;x$ pour en déduire le résultat. On introduit alors
la règle $\eta$.

\begin{definition}[$\beta\eta$-réduction]
  On définit la $\beta\eta$-réduction comme la plus petite relation compatible
  contenant les paires
  \[(\lambda x.t)u \bered t[u/x] \qquad\qquad
  \lambda x.t\;x \bered t \quad x\notin \VL(t)\]
  On définit $\BEeq$ comme la plus petite congruence contenant ces paires.
\end{definition}

\begin{exercise}
  Montrer que $\BEeq$ et $\cong$ sont des relations équivalentes.
\end{exercise}

On a donc une nouvelle relation qui égalise les termes définissant les mêmes
fonctions $\lamSet \to \lamSet$, et qui est définissable de façon purement
syntaxique.

Cependant, la relation $\Beq$ nous suffit pour l'usage de ce cours, et c'est
donc celle que nous privilégions.

\subsection{S'affranchir des $\alpha$-équivalences}

La définition de $\lamSet$ en tant que quotient est insatisfaisante si on veut,
par exemple, formaliser des résultats de $\lambda$-calcul dans un assistant de
preuves. Devoir définir un système syntaxique par une relation d'équivalence et
avoir une substitution partiellement définie (bien que totale sur les classes
d'équivalence) donne lieu à des technicités si l'on souhaite raisonner de façon
purement formelle.

Heureusement, autoriser un discours légèrement informel n'est pas limitant dans
le cadre d'un cours, mais nous souhaitons néanmoins proposer une façon de
formaliser plus rigoureusement nos définitions, en utilisant les indices de
De Bruijn.

Cette sous-section est donc à part. En particulier, on redéfinit les opérations
et les objets en les notant de la même façon qu'ailleurs. Hors de cette
sous-section, toutes les définitions sont à considérer comme celles précédemment
données.

\begin{definition}[$\lambda$-termes \cite{de_bruijn_1972}]
  On définit par induction l'ensemble $\lamSet$ des $\lambda$-termes par
  la BNF suivante~:
  \[t,u\Coloneq n\mid \lambda t\mid t\;u\]
  où $n \in \bN$.
\end{definition}

Cette définition peut paraître surprenante~: au lieu de variables, on introduit
des entiers, et n'ajoute aucune variable liante aux abstractions. Le choix des
entiers n'est donc pas simplement une réécriture des variables en les énumérant
par $x_0,x_1,\ldots$ mais bien une version alternative de lire des variables.

La façon de lire un terme dans cette syntaxe est d'imaginer que les termes sont
interprété dans un contexte, qui associe un objet aux variables libres. On
pourrait par exemple imaginer le terme $x\;y$ comme s'interprétant dans le
contexte $x \mapsto a, y \mapsto b$. Si on oublie le nom des variables, mais
qu'on garde en mémoire le contexte, on peut encore référer à l'objet $a$ ou à
l'objet $b$ associé, en donnant l'indice de l'objet dans le contexte.
Précisons que cette idée de contexte n'est pas formelle~: on n'y fait référence
que pour motiver la notation.

Ainsi, le terme $0$ représente par exemple la première valeur du contexte, et
le terme $1\;0$ représente l'application de la deuxième valeur du contexte à la
première (on fais commencer la numérotation à $0$).

Pour interpréter un terme $\lambda\;t$, on a alors besoin d'un contexte plus
grand pour interpréter $t$. Imaginons une liste $\ell$ interprétant le contexte
de $\lambda \;t$, on va alors interpréter $t$ par la liste $a,\ell$, où $a$ est
en première position. On peut alors voir une variable liée comme indiquant de
combien de $\lambda$ on remonte pour trouver son lieur.

\begin{figure}[ht!]
  \centering
  \hrule

  \vspace{0.2cm}
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
    \node (a0) at (0,0) {Contexte~: $[a,$};
    \node (b0) at (1.3,0){$b$};
    \node (c0) at (1.6,0) {$,c]$};
    \node (a) at (0,-1) {$\lambda$};
    \node (b) [below = of a] {$\lambda$};
    \node (c) [below = of b] {$@$};
    \node (d) [below left = of c] {$0$};
    \node (e) [below right = of c] {$3$};
    \draw (a) -- (b);
    \draw (b) -- (c);
    \draw (c) -- (d);
    \draw (c) -- (e);
    \draw[->,>=latex, color = red] (d) to[bend right] (c);
    \draw[->,>=latex, color = red] (e) to[bend right] (b0);
  \end{tikzpicture}

  \vspace{0.2cm}
  \hrule

  \vspace{0.4cm}
  \caption{Exemple de terme en indices de De Bruijn~: $\lambda\;\lambda\;0\;3$}
  \label{fig.deBruijn.ex}
  \hrule
\end{figure}

Dans la \cref{fig.deBruijn.ex}, on voit la différence entre une variable liée,
dont l'indice ramène à l'intérieur du terme, et une variable libre dont l'indice
amène à l'extérieur du terme. Remarquons aussi que la valeur d'une variable
libre dépend du nombre de lieurs qui la précède~: si on considère le terme
$\lambda\;\lambda\;0\;3$, la variable libre $3$ est en réalité la variable
$1$ au sens du contexte extérieur. L'ensemble des variables libres peut donc
être surévalué par l'indice maximal d'une variable apparaissant dans le terme,
une fois retranché le nombre de lieurs la précédant. On peut donc définir
$\VL$ non par comme un ensemble, mais comme un nombre.

\begin{definition}[Variable libre maximale]
  On définit pour tout $t \in \lamSet$ le nombre $\VL(t)$ par induction sur
  $t$~:
  \begin{itemize}
  \item si $t = n$, alors $\VL(t) \defeq n + 1$~;
  \item si $t = \lambda \;u$, alors $\VL(t) \defeq \VL(u) - 1$~;
  \item si $t = u\;v$, alors $\VL(t) \defeq \max(\VL(u),\VL(v))$.
  \end{itemize}
  Le terme $t$ est clos lorsque $\VL(t) = 0$.
\end{definition}

La valeur de $\VL(t)$ peut s'interpréter par le fait que l'ensemble des
variables à l'intérieur de $t$ sont strictement inférieures à $\VL(t)$ (modulo
l'ajout des lieurs).

On peut maintenant définir le relèvement d'un terme, qui correspond à une forme
d'affaiblissement sur les contextes.

\begin{definition}[Relèvement d'un terme]
  Soient $n,k \in \bN$. On définit par induction sur $t$ le relèvement de $t$
  par $k$ en $n$, par~:
  \begin{itemize}
  \item si $t = p$ et $p < k$, alors $\lift t k n \defeq p$.
  \item si $t = p$ et $p \leq k$, alors $\lift t k n \defeq p + n$.
  \item si $t = \lambda\;u$, alors
    $\lift t k n \defeq \lambda (\lift u {k+1} n)$.
  \item si $t = u\;v$, alors $\lift t k n \defeq (\lift u k n)\;(\lift v k n)$.
  \end{itemize}
\end{definition}

Le relèvement $\lift t k n$ correspond à ajouter $n$ objets au contexte
d'interprétation, à partir de l'indice $k$ du contexte. Son intérêt se joue dans
la définition de la substitution~: lorsqu'on définit $(\lambda\;t)[u/n]$, on
souhaite que la substitution de $u$ à l'intérieur de $t$ ne capture pas la
variable déclarée par le $\lambda$, ce qui se fait en relevant $u$ de $1$
pour que, dans le contexte de $u$, la variable du $\lambda$ soit prise en
compte.

\begin{definition}[Substitution]
  Soient $t,u \in \lamSet$ et $n \in \bN$. On définit inductivement sur $t$
  la substitution $t[u/n]$~:
  \begin{itemize}
  \item si $t = n$ alors $t[u/n] \defeq u$.
  \item si $t = k \neq n$ alors $t[u/n] \defeq t$.
  \item si $t = \lambda\;u$ alors
    $t[u/n] \defeq \lambda\;(t[\lift u 0 1/n+1])$.
  \item si $t = t'\;t''$ alors $t[u/n] \defeq (t'[u/n])\;(t''[u/n])$.
  \end{itemize}
\end{definition}

\begin{definition}[$\beta$-réduction]
  La relation $\bred \subseteq \lamSet\times\lamSet$ est la plus petite relation
  compatible contenant les couples
  \[(\lambda\;t)u\bred t[u/0]\]
\end{definition}

\section{Calculabilité dans le $\lambda$-calcul}

Comme dit auparavant, le $\lambda$-calcul permet de représenter toutes les
fonctions calculables (au sens des fonctions $\bN^k \partialto \bN$). On va
donc prouver ce théorème de représentation.

\subsection{Représenter des fonctions}

Tout d'abord, comment représenter des entiers ? C'est en effet, la première
étape pour parler de fonctions $\bN^k\partialto\bN$. Pour cela, on introduit
les entiers de Church, qui sont une représentation des entiers en
$\lambda$-calcul, fondée sur l'idée qu'un entier $n$ est l'application d'une
action $n$ fois.

\begin{definition}[Entiers de Church]
  Soit $n\in\bN$, on définit l'entier de Church $\encode n$ par
  \[\encode n \defeq \lambda f.\lambda x.f^n\;x\]
\end{definition}

\begin{remark}
  Dans la notation $f^n\;x$, il faut lire $f\;(f\;(f\cdots(f\;x)\cdots))$, et
  non $f\;f\;f\cdots f\;x$.
\end{remark}

\begin{exercise}
  Montrer que pour tout $n \in \bN$, $\encode n$ est une forme normale
  (sous-entendu pour la relation $\bred$).
\end{exercise}

Un entier $n$ est donc représenté comme un terme prenant une fonction et
l'appliquant $n$ fois à son argument. On peut désormais définir la
représentation des fonctions d'entiers.

\begin{definition}[Représentation d'une fonction]
  Soit $f : \bN^k \to \bN$. On dit que $t \in \lamSet$ représente $f$ si
  \[\forall (n_1,\ldots,n_k) \in \bN^k,
  t\;\encode{n_1}\cdots\encode{n_k} \Beq \encode{f(n_1,\ldots,n_k)}\]
\end{definition}

\begin{notation}
  On utilisera, pour compactifier les écritures, la notation
  $t\;\encode{\vec n}$ pour signifie $t\;\encode{n_1}\cdots\encode{n_k}$.
\end{notation}

Les fonctions récursives étant potentiellement partielles, on définit aussi la
représentation (au sens fort) des fonctions partielles.

\begin{definition}[Représentation d'une fonction partielle]
  Soit $f : \bN^k \partialto \bN$. On dit que $t \in \lamSet$ représente $f$ si
  pour tout $\vec n \in \bN^k$, si $f(\vec n) \convcal$ alors
  $t\;\encode{\vec n}$ se réduit en $\encode{f(\vec n)}$ et si
  $f(\vec n)\divcal$ alors
  $t\;\encode{\vec n}$ ne se réduit en aucune forme normale.
\end{definition}

\begin{exercise}
  Montrer que la fonction nulle part définie est représentable par un
  $\lambda$-terme.
\end{exercise}

On donne aussi un encodage des tuples, de sorte à pouvoir définir des fonctions
calculables $\bN^k\partialto \bN^p$.

\begin{definition}[Représentation des paires]
  On définit les termes $\langle-,-\rangle$, $\pi_1$ et $\pi_2$ comme suit~:
  \begin{align*}
    \langle-,-\rangle &\defeq \lambda t\;u.\lambda p. p\;t\;u\\
    \pi_1 &\defeq \lambda p.p\;(\lambda x\;y.x)\\
    \pi_2 &\defeq \lambda p.p\;(\lambda x\;y.y)
  \end{align*}
  On note $\langle t,u\rangle$ pour $\langle-,-\rangle\;t\;u$.
\end{definition}

On vérifie par un calcul que $\pi_1\;\langle t,u\rangle \bred t$ et que
$\pi_2\;\langle t,u\rangle \bred u$~:
\begin{align*}
  \pi_1\;\langle t,u\rangle &\bred \langle t,u\rangle (\lambda x\;y.x)\\
  &\bred^3 (\lambda x\;y.x)\;t\;u\\
  &\bred^2 t \\
  \pi_2\;\langle t,u\rangle &\bred \langle t,u\rangle (\lambda x\;y.y)\\
  &\bred^3 (\lambda x\;y.y)\;t\;u\\
  &\bred^2 u
\end{align*}
On peut ainsi travailler avec des paires de termes, et représenter ainsi des
tuples d'entiers.

\begin{exercise}
  Donner un encodage des $k$-uplets de termes, avec une fonction construisant
  ces $k$-uplets et des fonctions de projection correspondantes.
\end{exercise}

On peut aussi encoder les booléens.

\begin{definition}[Représentation des booléens]
  On définit les termes $\top$ et $\bot$ par
  \begin{align*}
    \top &\defeq \lambda x\;y.x\\
    \bot &\defeq \lambda x\;y.y
  \end{align*}
  Une fonction $f : \{0,1\}^k \to \{0,1\}$ est représentée par $t \in \lamSet$
  si $t\;\encode{\vec b} \Beq \encode{f(\vec b)}$ en posant
  $\encode 1 \defeq \top$ et $\encode 0 \defeq \bot$.
\end{definition}

\begin{exercise}
  Montrer que les opérations booléennes $\lor,\land,\lnot$ peuvent sont
  représentables par des $\lambda$-termes.
\end{exercise}

\begin{definition}[Représentation des ensembles d'entiers]
  Une partie $X\subseteq \bN^k$ est représentable par un terme $t$ si
  \[\forall \vec n \in \bN^k, \begin{cases}
    \vec n \in X \iff t\;\encode{\vec n} \Beq \top\\
    \vec n \notin X \iff t \;\encode{\vec n} \Beq \bot
  \end{cases}\]
\end{definition}

\begin{proposition}
  La partie $\{0\}\subseteq \bN$ est représentable.
\end{proposition}

\begin{proof}
  On donne le terme représentant cette partie~:
  \[\eqZ\defeq \lambda n.n\;(\lambda x.\bot)\;\top\]
  On vérifie par récurrence sur $n$ que $\eqZ\;\encode{n}$ se réduit à $\top$
  si $n = 0$, et à $\bot$ sinon~:
  \begin{itemize}
  \item
    $\eqZ\;\encode 0 = (\lambda f\;x.x)\;(\lambda x.\bot)\;\top\bred^2\top$.
  \item
    $\eqZ\;\encode{n+1} \bred^2 (\lambda x.\bot)\;u$ où $u$ est un terme
    qui n'importe pas, puisque ce terme se réduit dans tous les cas vers
    $\bot$.
  \end{itemize}
\end{proof}

On donne aussi la représentation du branchement conditionnel if/then/else.

\begin{proposition}
  Soient $f,g : \bN^k\to \bN$ des fonctions représentées respectivement par
  $t$ et $u$, et $X \subseteq \bN^k$ une partie représentée par $v$. Alors
  la fonction telle que, si $\vec n \in X$, renvoie $f(\vec n)$, et sinon
  renvoie $g(\vec n)$, est représentée par
  \[\ifrm v \thenrm t \elserm u \defeq
  \lambda \vec n.v\;\vec n\;(t\;\vec n)\;(u\;\vec n)\]
\end{proposition}

\begin{proof}
  Si $\vec n \in X$, alors $v\;\vec n \bred \top$, et $\top\;a\;b \bred a$,
  donc $\ifrm v \thenrm t \elserm u \bred^\star t\;\vec n$, d'où le résultat
  par représentation de $f$ par $t$.

  Si $\vec n \notin X$, alors $v\;\vec n \bred \bot$, et $\bot\;a\;b\bred b$,
  d'où le résultat par représentation de $g$ par $u$.
\end{proof}

\subsection{Fonctions primitives récursives}

On commence par encoder les fonctions RP. Les projections se représentent
facilement en définissant
$\pi^k_i \defeq \lambda x_1\cdots x_k.x_i$,
la fonction nulle est simplement
$\lambda x.\encode 0$
et la fonction successeur peut s'écrire par
$S \defeq \lambda n.\lambda f.\lambda x.f\;(n\;f\;x)$.

\begin{exercise}
  Montrer que les termes donnés représentent bien les fonctions annoncées.
\end{exercise}

La composition ayant déjà été écrite dans le cas de fonctions unaires, il est
direct de généraliser la chose. On souhaite donc encoder la récursion primitive.
Remarquons que, naturellement, un entier $n$ représente un itérateur. On peut
donc simplement appliquer $n$ pour obtenir le résultat attendu, en faisant
attention à garder à l'esprit les paramètres de la récursion primitive.

\begin{proposition}
  Si $f : \bN^{k+2}\to\bN$ est représentée par $t$, que
  $g : \bN^k \to \bN$ est représentée par $u$, alors la fonction
  $\rec(f,g)$ est représentable, de représentation donnée par
  \[\rec(t,u)\defeq \lambda \vec n. \lambda n. \pi_2\;(n\;
  (\lambda x. \langle S\;(\pi_1\;x),
  t\;\vec n\;(\pi_2\;x)\;(\pi_1\;x)\rangle)\;
  \langle \encode 0, u\;\vec n\rangle)\]
\end{proposition}

\begin{proof}
  Notons $\rec_0(t,u)$ le terme obtenu en enlevant la projection $\pi_2$
  précédant le $n$. Montrons par récurrence sur $n$ que pour tout
  $\vec n \in \bN^k$, $\rec_0(t,u)\;\encode{\vec n}\;\encode n$ se
  réduit en $\langle \encode n,\encode{\rec(f,g)(\vec n,n)}\rangle$~:
  \begin{itemize}
  \item si $n = 0$, alors le terme se réduit en
    $\langle \encode 0,u\;\vec n\rangle$ et, comme $u$ représente
    $g$, on en déduit le résultat.
  \item si $n = p + 1$, alors le terme se réduit en
    $(\lambda x.\langle S\;(\pi_1\;x), t \;\vec n\;(\pi_2\;x)\;
    (\pi_1\;x)\rangle)\;u'$
    où $u'$, par hypothèse de récurrence, se réduit en
    $\langle \encode p, \encode{\rec(f,g)(\vec n, p)}$ donc,
    comme $t$ représente $f$, le terme total se réduit en
    $\langle \encode n,\encode{\rec(f,g)(\vec n,n)}$, d'où le résultat.
  \end{itemize}
  On en déduit par récurrence, et en composant par $\pi_2$, que
  $\rec(t,u)$ représente $\rec(f,g)$.
\end{proof}

\begin{remark}
  Si on prend $f = \lambda n\;p.n$, on obtient pour $\rec_0$ une fonction qui
  retourne $\langle 0,0\rangle$, puis $\langle n,n-1\rangle$, pour finalement
  retourner $n-1$ une fois la projection effectuée. On peut donc obtenir
  l'opération de prédecesseur de cette manière, puis l'opération $-$ en
  itérant le prédecesseur.
\end{remark}

On en déduit un premier théorème de représentation.

\begin{theorem}[Représentation des fonctions RP]
  Pour toute fonction $f : \bN^k \to \bN$ RP, il existe un terme
  $t \in \lamSet$ représentant $f$.
\end{theorem}

\subsection{Cas de la minimisation}

L'opérateur $\mu$ de minimisation, permettant de passer des fonctions RP aux
fonctions récursives, demande de construire un itérateur potentiellement
infini (c'est la cause du passage de fonction totale à fonction partielle).
Un moyen simple de créer une telle fonction est d'utiliser un point fixe, de
façon analogue au \cref{thm.Kleene.fix}. On peut alors définir $\mu(f)$
comme un point fixe~: on construit une fonctions qui appelle toutes les
valeurs de $f$ successivement, et retourne l'indice de la première valeur
d'annulatio de $f$. Puisqu'en $\lambda$-calcul, tous les objets sont des
fonctions, le théorème de point fixe peut se construire bien plus facilement
en donnant un terme construisant explicitement un point fixe.

\begin{definition}[Combinateur de point fixe]
  On définit le point fixe de Curry par~:
  \[y \defeq \lambda x.f\;(x\;x)
  Y \defeq \lambda f.y\;y\]
  On définit le point fixe de Turing par~:
  \[\theta \defeq \lambda x\;y.y\;(x\;x\;y) \qquad
  \Theta \defeq \theta\;\theta\]
  Pour chacun des deux termes, qu'on notera $T$, et pour tout $t \in \lamSet$,
  on a l'égalité
  \[T\;t \Beq t\;(T\;t)\]
\end{definition}

\begin{proof}
  Il suffit d'effectuer la réduction~:
  \begin{align*}
    Y\;t &\bred (\lambda x.t\;(x\;x))\;(\lambda x.t\;(x\;x))\\
    &\bred t\;(y[t/f]\;y[t/f]) \\
    t(Y\;t) &\bred t\;(y[t/f]\;y[t/f])\\
    \Theta\;t &\bred (\lambda y.y\;(\theta\;\theta\;y))\;t \\
    &\bred t\;(\theta\;\theta\;t) \\
    &= t\;(\Theta\;t)
  \end{align*}
  D'où le résultat.
\end{proof}

Le combinateur $Y$ est surement le plus naturel à considérer quand on adapte
l'argument diagonal~: la forme du point fixe construit dans le
\cref{thm.Kleene.fix} est exactement la même, mais où le théorème $s_m^n$ est
nécessaire pour construire des abstractions. Dans le $\lambda$-calcul,
le terme en devient donc d'autant plus simple.

Le terme $\Theta$, lui, a l'avantage de donner un point fixe uniquement en
réduisant, contrairement à $Y\;t$ qui n'est égal à $t\;(Y\;t)$ qu'en effectuant
une antiréduction à la fin.

On peut maintenant représenter l'opérateur $\mu$.

\begin{proposition}
  Soit $f : \bN^{k+1} \partialto \bN$ représentée par le terme $t$, alors
  $\mu(f)$ est représentée par le terme
  \[\mu(t) \defeq \lambda
  \vec n.\Theta(\lambda f.\lambda m.\ifrm \eqZ t\;\vec n\;m
  \thenrm m \elserm f\;(S\;m))\;\encode 0\]
\end{proposition}

\begin{proof}
  Fixons le paramètre $\vec n$.
  Supposons que $f$ admette un point d'annulation, que son plus petit
  point d'annulation est $k \in \bN$ et que $f$ est définie pour toute valeur
  inférieure à $k$. Notons $u$ la fonction définie par
  le point fixe $\Theta$, et prouvons par récurrence sur $n$ que
  $u\;\encode{k-n}$ retourne $k$~:
  \begin{itemize}
  \item pour $n = 0$, on considère donc $u\;\encode k$, qui se réduit en
    $\ifrm\eqZ t\;\encode{\vec n}\;\encode k\thenrm \encode k\elserm
    u\;(S\;\encode k)$, qui se réduit lui-même directement en
    $\encode k$.
  \item pour $n = p + 1$, on sait que $f(k-n)\neq 0$, donc
    le terme $u\;\encode{k-n}$ se réduit en
    $u\;(S\;\encode{k-n})$, mais $S\;\encode{k-n} \bred \encode{k-p}$, d'où
    le résultat par récurrence.
  \end{itemize}

  Si $f$ n'est pas définie en un point $i$ précédent son plus petit point
  d'annulation, alors une récurrence similaire nous permet de montrer que
  $u\;p \bred \ifrm\eqZ t\;\encode{\vec n}\;\encode i\thenrm \encode i \elserm
  u\;(S\;\encode i)$, et comme le terme $t\;\encode{\vec n}\;\encode i$ n'a
  pas de forme normale et est en tête du terme, on en déduit que le terme
  total n'a pas de forme normale.

  Si $f$ n'a pas de point d'annulation, alors on peut montrer que
  $\mu(t)$ s'exécute en au moins $n$ étapes.
\end{proof}

On en déduit la représentation des fonctions calculables.

\begin{theorem}[Représentation des fonctions récursives]
  Toute fonction récursive $f : \bN^k \partialto \bN$ est représentable au sens
  fort par un $\lambda$-terme.
\end{theorem}

Le sens réciproque de ce théorème de représentation est laissé en exercice.

\begin{exercise}
  Soit $t\in\lamSet$. On définit son codage de Gödel par induction sur $t$
  (pris comme écrit en indices de De Bruijn)~:
  \begin{itemize}
  \item si $t = n$, alors $\godcod t \defeq 3n$
  \item si $t = \lambda\;t'$, alors $\godcod t \defeq 3\godcod{t'} + 1$
  \item si $t = t'\;t''$, alors
    $\godcod t \defeq 3\langle \godcod{t'},\godcod{t''}\rangle + 2$.
  \end{itemize}

  Montrer que la relation $\bred$ est calculable sur les codes de termes.
  En déduire que toute fonction $\bN^k\partialto \bN$ représentée par un
  terme $t$ est calculable.
\end{exercise}

\subsection{Conséquence de la représentation}

Puisque le $\lambda$-calcul est un formalisme équivalent aux autre formalismes
de calculabilité, on déduit les faits suivants~:

\begin{proposition}
  Il existe une fonction $\godcod - : \lamSet \to \bN$ et un terme
  $U$ tels que
  \[\forall t \in \lamSet, U\;\encode{\godcod t}
  \Beq \encode{\godcod{n_f}}\]
  où $n_f$ est la forme normale de $t$ si elle existe, et où le terme
  $U\;\encode{\godcod{t}}$ n'a pas de forme normale sinon.
\end{proposition}

\begin{proposition}
  La partie
  \[\{\godcod t \mid t \in \lamSet, t\text{ est normalisant}\}\]
  est r.e.-complète pour la réduction many-one.
\end{proposition}

On en déduit qu'il n'existe pas de terme $\HALT$ tel que $\HALT\;t$ se réduit
en $\top$ si $t$ a une forme normale et en $\bot$ sinon.

On peut aussi en déduire, par le théorème de Rice~:

\begin{proposition}
  Il n'existe aucun terme $e$ tel que $e\;t\;u$ se réduit en $\top$ si
  $t \BEeq u$ et en $\bot$ sinon.
\end{proposition}

\begin{proof}
  Si un tel terme existait, on pourrait calculer l'ensemble
  \[\{(\godcod t,\godcod u)\mid t, u \in \lamSet, t \BEeq u\}\]
  qui est un problème sémantique.
\end{proof}

Dans le cas de la $\beta$-équivalence, on n'a pas tout à fait ce résultat,
puisque l'ensemble n'est pas sémantique. On définit donc des notions analogues à
celles de calculabilité pour le cas de la $\beta$-réduction. Tout d'abord,
on donne une version du théorème de point fixe utilisant le codage de Gödel des
$\lambda$-termes.

\begin{theorem}[Point fixe]
  Soit $t\in\lamSet$, alors il existe $F_t$ tel que
  \[t\;\encode{\godcod F_t} \Beq F_t\]
\end{theorem}

\begin{proof}
  On se donne un terme $\delta$ tel que
  \[\forall u\in \lamSet, \delta\;\encode{\godcod{u}} \bred^\star
  \encode{\godcod{u\;\encode{\godcod{u}}}}\]
  En posant $v \defeq \lambda x.t\;(\delta\;x)$ (où $x$ n'apparaît ni dans $t$,
  ni dans $\delta$), on obtient
  \[F_t \defeq v\;\encode{\godcod v}\]
  En effet, en faisant la réduction~:
  \begin{align*}
    F_t &\bred t\;(\delta\;\encode{\godcod{v}})\\
    &\bred^\star t\;\encode{\godcod{v\;\encode{\godcod{v}}}}\\
    &= t\;\encode{\godcod{F_t}}
  \end{align*}
  D'où le résultat.
\end{proof}

\begin{definition}[Ensembles récursivement séparables]
  On dit que $A,B\subseteq \lamSet$ sont récursivement séparables s'il existe
  un terme $t$ tel que
  \[\forall u \in \lamSet, t\;\encode{\godcod u} \bred^\star
  \begin{cases}
    \encode \bot\text{ si } u \in A\\
    \encode \top\text{ si } u \in B
  \end{cases}\]
  $A$ et $B$ sont dit récursivement inséparables sinon.
\end{definition}

Un ensemble sémantique, mais dans le sens de $\bred$, sera dit saturé ici.

\begin{definition}[Ensemble saturé]
  Une partie $A\subseteq \lamSet$ est dite saturée si
  \[\forall t,u \in \lamSet, t \Beq u \implies t \in A \implies u \in A\]
\end{definition}

\begin{theorem}
  Deux ensembles disjoints saturés sont récursivement inséparables.
\end{theorem}

\begin{proof}
  Supposons que deux ensembles $A,B$ vérifiant les hypothèses sont récursivement
  séparables, et soit $t$ un séparateur tel que donné dans la définition.
  Soient $t_A \in A$ et $t_B \in B$, et
  \[u \defeq \lambda n.\eqZ\;(t\;n)\;t_A\;t_B\]
  On utilise maintenant le théorème de point fixe pour trouver $F_u$ tel que
  $u\;\encode{\godcod{F_u}}\Beq F_u$. On en déduit~:
  \begin{itemize}
  \item si $t\;\encode{\godcod{F_u}}\bred^\star \bot$, alors $F_u\bred^\star t_B$
    donc $F_u \Beq t_B \in B$, mais alors
    $t\;\encode{\godcod{F_u}}\bred^\star \top$
  \item de même, si $t\;\encode{\godcod{F_u}}\bred^\star \top$, alors
    $F_u \Beq t_A \in A$, donc
    $t\;\encode{\godcod{F_u}}\bred^\star \bot$.
  \end{itemize}
  On en déduit une contradiction.
\end{proof}

\begin{remark}
  La fonction construite est parfaitement analogue à la réduction construite
  pour le théorème de Rice, suivi de la preuve de la non calculabilité du
  problème de l'arrêt avec un point fixe.
\end{remark}

On peut alors prouver les résultats pour la réduction $\bred$.

\begin{theorem}
  La relation $\Beq$ est indécidable, et l'ensemble
  \[\{\godcod t \mid t \in \lamSet, t \textit{ faiblement normalisant}\}\]
  est indécidable.
\end{theorem}

On en déduit aussi le théorème de l'image.

\begin{theorem}[Image]
  Soit $\overline t \in \lamSet/\Beq$, $t$ définit une fonction
  \[\makeFun{f_{\overline t}}{\lamSet/\Beq}{\lamSet/\Beq}{\overline u}{
    \overline{t\;u}}\]
  qui est une fonction constante ou une fonction dont l'image est infinie.
\end{theorem}

\begin{proof}
  En effet, supposons qu'il existe deux valeurs $t_1$ et $t_2$ telles que
  $\im(f_{\overline t}) = \{t_1,t_2\}$ (dans le cas de plus de valeurs,
  l'argument s'adapte facilement). Les ensembles
  \[A_{t_1} \defeq \{ u \in \lamSet\mid t\;u \Beq t_1\}\qquad
  A_{t_2}\defeq \{ u \in \lamSet\mid t\;u \Beq t_2\}\]
  sont alors des ensembles disjoints et saturés~: ils sont donc inséparables.
  Pourtant, puisqu'on sait que $A_{t_1}\cup A_{t_2} = \lamSet$, que les deux
  ensembles sont disjoints et qu'ils sont c.e., on en déduit qu'ils sont tous
  deux décidables, ce qui est une contradiction.
\end{proof}

\section{Propriétés de la réduction}

On s'attarde maintenant sur $\bred$. L'objectif de cette section est de montrer
certaines propriétés de cette réduction, en particulier~:
\begin{itemize}
\item que $\bred$ a la propriété de Church-Rosser, ce qui permet de définir de
  façon univoque la forme normale d'un terme si elle existe, et d'avoir un
  algorithme qui, sous réserve de convergence, teste la $\beta$-équivalence de
  deux termes (avec ce qu'on a vu avant, on sait déjà que la non convergence
  rend l'égalité indécidable)~;
\item que toute réduction pour $\bred$ peut se factoriser suivant deux
  sous-réductions qui sont la réduction de tête et la réduction en profondeur~;
\item qu'il existe un choix de réduction permettant systématiquement d'atteindre
  une forme normale, si elle existe.
\end{itemize}

\subsection{Propriété de Church-Rosser}

Pour prouver la propriété de Church-Rosser, on utilise une méthode développée
par Tait et Martin-Löf (d'après \cite{Barendregt1984}), et affinée dans
\cite{TAKAHASHI1995120}, impliquant la réduction parallèle.

Pour prouver la confluence du $\lambda$-calcul, la difficulté principale est,
étant donnés deux redexes dans une expression, de montrer que les deux ordres
de réduction mènent au même résultat. Cependant, une première réduction peut
multiplier des redexes, dont le redex de la deuxième réduction. La réduction
parallèle permet de réduire en une seule étape ces deux redexes, de sorte
que la propriété du carreau est vérifiée (et donc, par extension, la
confluence).

On définit donc la réduction parallèle.

\begin{definition}[Réduction parallèle]
  La réduction parallèle $\redPar$ est définie par les règles suivantes~:
  \begin{center}
    \begin{tabular}{cc}
      \bottomAlignProof
      \AxiomC{}
      \UnaryInfC{$x \redPar x$}
      \DisplayProof
      &
      \bottomAlignProof
      \AxiomC{$t\redPar t'$}
      \AxiomC{$u\redPar u'$}
      \BinaryInfC{$t\;u\redPar t'\;u'$}
      \DisplayProof
      \\
      \\
      \bottomAlignProof
      \AxiomC{$t\redPar t'$}
      \UnaryInfC{$\lambda x.t\redPar \lambda x.t'$}
      \DisplayProof
      &
      \bottomAlignProof
      \AxiomC{$t\redPar t'$}
      \AxiomC{$u\redPar u'$}
      \BinaryInfC{$(\lambda x.t)u \redPar t'[u'/x]$}
      \DisplayProof
    \end{tabular}
  \end{center}
\end{definition}

L'objectif est donc d'utiliser le \cref{lem.carreau.confluence.clot} en montrant
que $\bred \subseteq \redPar \subseteq \bred^\star$ et que $\redPar$ a la
propriété du carreau.

\begin{property}
  Les propriétés suivantes sont vérifiées pour $\redPar$~:
  \begin{itemize}
  \item $\redPar$ est réflexive~;
  \item $\bred\subseteq \redPar$~;
  \item si $t\redPar t'$ et $u \redPar u'$, alors $t[u/x] \redPar t'[u'/x]$~;
  \item $\redPar \subseteq\bred^\star$.
  \end{itemize}
\end{property}

\begin{proof}
  Montrons les différentes propriétés~:
  \begin{itemize}
  \item on montre par induction sur $t$ que $t\redPar t$. Si $t = x$, le
    résultat est évident, si on suppose que $t\redPar t$ et $u\redPar u$
    alors $t\;u\redPar t\;u$ et $\lambda x.t\redPar \lambda x.t$.
  \item puisque $\redPar$ est réflexive, et vu la forme des règles, on en
    déduit que $\redPar$ est une relation compatible. La dernière règle,
    en utilisant la réflexivité, nous indique que
    $(\lambda x.t)u\redPar t[u/x]$, donc $\bred\subseteq \redPar$.
  \item on raisonne par induction sur $t\redPar t'$~:
    \begin{itemize}
    \item si $t = t' = x$, on doit montrer que $u \redPar u'$, ce qui est vrai
      par hypothèse.
    \item si $t = t' = y$ où $y \neq x$, on doit montrer que $t \redPar t$,
      ce qui est vrai par réflexivité de $\redPar$.
    \item si $t = t_0\;t_1$, $t' = t'_0\;t'_1$, que $t_0 \redPar t'_0$ et
      $t_1\redPar t'_1$, alors on sait par hypothèse d'induction que
      $t_0[u/x] \redPar t'_0[u'/x]$ et $t_1[u/x] \redPar t'_1[u'/x]$, donc
      $t[u/x] \redPar t'[u'/x]$.
    \item si $t = \lambda y.t_0$ et $t' = \lambda y.t'_0$, où
      $t_0[u/x]\redPar t'_0[u'/x]$, alors
      $(\lambda y.t_0)[u/x] \redPar (\lambda y.t'_0)[u'/x]$.
    \item si $t = (\lambda y.t_0)\;t_1$ et $t' = t'_0[t'_1/y]$, avec comme
      hypothèse d'induction que $t_0[u/x]\redPar t'_0[u'/x]$ et
      $t_1[u/x]\redPar t'_1[u'/x]$, alors on sait que
      $(\lambda y.t_0[u/x]) \redPar t'_0[u'/x][t'_1[u'/x]/y]$, mais on a
      l'égalité
      \[t'_0[t'_1/y][u'/x] = t'_0[u'/x][t'_1[u'/x]/y]\]
      d'après l'\cref{exo.subst.subst}, d'où le résultat.
    \end{itemize}
    On en déduit que $t[u/x] \redPar t'[u'/x]$.
  \item on montre par induction sur $\redPar$ que si $t\redPar u$ alors
    $t\bred^\star u$~:
    \begin{itemize}
    \item puisque $\bred^\star$ est transitive, on sait que $x\bred^\star x$.
    \item si $t\bred^\star t'$ et $u\bred^\star u'$, alors
      $t\;u\bred^\star t'\;u\bred^\star t'\;u'$ par compatibilité.
    \item si $t\bred^\star t'$, alors
      $\lambda x.t\bred^\star \lambda x.t'$ par compatibilité.
    \item si $t\bred^\star t'$ et $u\bred^\star u'$, alors
      $(\lambda y.t)\;u \bred t[u/x] \bred^\star t'[u/x]\bred^\star t'[u'/x]$
      d'après l'\cref{exo.subst.red}.
    \end{itemize}
    Donc, par induction sur $\redPar$, on en déduit que
    $\redPar\subseteq\bred^\star$.
  \end{itemize}

  Les propriétés sont donc toutes vérifiées.
\end{proof}

Il nous reste maintenant à prouver que la réduction parallèle a la propriété du
carreau. Pour cela, depuis un terme $t$ ayant des redexes $r_1,\ldots,r_p$,
on pourrait considérer que, lorsque $t \redPar u$, on choisit des redexes
$\{r_i\}_{i \in I}$, et lorsque $t \redPar v$, on choisit des redexes
$\{r_i\}_{i \in J}$. Un réduit commun à $u$ et $v$ est alors la réduction
effectuée en choisissant les redexes $\{r_i\}_{i \in I \cup J}$.

Cette méthode fonctionne, mais n'est pas nécessaire pour le résultat, que l'on
souhaite montrer~: il est possible de prendre comme réduit commun, peu importe
$u$ et $v$, le terme obtenu depuis $t$ en effectuant tous les redexes dans $t$.
On définit pour cela le développement en un pas.

\begin{definition}[Développement en un pas]
  On définit par induction sur $t\in \lamSet$ le terme $t^* \in \lamSet$~:
  \begin{itemize}
  \item si $t = x$, alors $t^* \defeq t$.
  \item si $t = \lambda x.u$, alors $t^* \defeq \lambda x. u^*$.
  \item si $t = u\;v$ où $u$ n'est pas une abstration, alors
    $t^* \defeq u^*\;v^*$.
  \item si $t = (\lambda x.u)\;v$, alors $t^* \defeq u^*[v^*/x]$.
  \end{itemize}
\end{definition}

\begin{proposition}
  Soit $t \in \lamSet$. Pour tout $u \in \lamSet$ tel que $t\redPar u$, on a
  $u\redPar t^*$.
\end{proposition}

\begin{proof}
  On procède par induction sur $t\redPar u$~:
  \begin{itemize}
  \item le cas où $t = u = x$ est automatique.
  \item si $t = t_0\;t_1$, $u = u_0\;u_1$, $t_0 \redPar u_0$ et
    $t_1\redPar u_1$, on sait par hypothèse d'induction que
    $u_0\redPar t_0^*$ et que $u_1\redPar t_1^*$, donc
    $u_0\;u_1\redPar t_0^*\;t_1^*$. Si $t_0$ est une abstraction, alors
    on utilise à la place la dernière règle. Dans les deux cas, on
    en déduit que $u\redPar t^*$.
  \item si $t = \lambda x.t_0$, $u = \lambda x.u_0$ et $t_0\redPar u_0$, alors
    par hypothèse d'induction $u_0\redPar t_0^*$ donc
    $\lambda x.u_0\redPar \lambda x.t^*_0$, d'où le résultat.
  \item si $t = (\lambda x.t_0)\;t_1$, $u = u_0[u_1/x]$ et, par hypothèse
    d'induction, $u_0\redPar t_0^*$ et $u_1\redPar t_1^*$, alors
    par la propriété précédente, $u_0[u_1/x]\redPar t_0^*[t_1^*/x]$, donc
    $u\redPar t^*$.
  \end{itemize}
  D'où, par induction, $u\redPar t^*$.
\end{proof}

\begin{corollary}
  La relation $\bred$ est confluente. De façon équivalente, elle vérifie la
  propriété de Church-Rosser. Il y a donc unicité de la forme normale vers
  laquelle se réduit un terme $t$.
\end{corollary}

\begin{proof}
  On a vérifié les hypothèses du \cref{lem.carreau.confluence.clot} pour
  $\redPar$ et $\bred$, la propriété du diamant pour $\redPar$ étant obtenue
  en considérant, pour $t \redPar u,v$, par $u,v\redPar t^*$. Comme la
  propriété de Church-Rosser et la confluence sont équivalents, on en déduit
  que $\bred$ vérifie aussi la propriété de Church-Rosser, et en conséquent
  on a l'unicité de la forme normale.
\end{proof}
