\chapter{Automates finis et langages réguliers}
\label{chp.auto}

\minitoc

\lettrine{P}{our} aborder la calculabilité, plusieurs approches existent. L'une
d'entre elles est de considérer directement les formalismes de fonctions
calculables. Cette approche est raisonnable puisqu'elle permet d'aller à
l'essentiel, mais cela donne une vision assez restrictive des modèles de calculs
plus faibles existants, et qui sont souvent très utiles.

C'est pourquoi nous faisons le choix dans cet ouvrage (où nous ne sommes limités
ni par le temps d'un cours ni par l'espace d'un livre imprimé) de traiter, avant
les formalismes de fonctions calculables, les formalismes liés à la hiérarchie
de Chomsky. Nous pensons en particulier que les automates permettent d'illuminer
profondément le fonctionnement intuitif d'une machine de Turing, plus complexe
mais basée sur des notions très proches.

Ce chapitre couvre donc les bases de l'étude des langages réguliers et des
automates finis. Cette classe de langage peut être décrite par de nombreux
formalismes, mais nous nous contenterons des automates finis, des expressions
régulières et des monoïdes.

Ce chapitre commence par la base de la théorie des langages~: les définitions
de ce qu'est un alphabet, un mot, un langage\ldots Nous aborderons ensuite la
classe des langages réguliers en abordant les trois formalismes décrits que sont
les automates, les expressions régulières et les langages reconnus par des
monoïdes, puis la preuve de leur équivalence. Enfin, nous verrons les théorèmes
de structure sur ces langages~: le lemme de pompage et le théorème de
Myhill-Nérode, ainsi que ses conséquences.

\section{Alphabet, mot, langage}

Pour étudier de façon plus systématique les langages, nous étudierons aussi de
l'algèbre avec la structure de monoïde, qui est intimement liée à celle
d'ensemble de mots. Nous verrons donc tout d'abord l'aspect concret de ce qu'est
un mot et un langage, puis nous aborderons les côtés théoriques de l'étude des
monoïdes.

\subsection{Premières définitions}

Tout d'abord, il nous faut définit ce qu'est un alphabet. Intuitivement, cela
désigne l'ensemble des symboles que nous utilisons pour écrire. Pour avoir un
trairement uniforme, on considère que des symboles comme \og ( \fg font aussi
partie de l'alphabet. C'est alors un objet particulièrement quelconque~: on peut
imaginer écrire avec à peu près n'importe quel ensemble de symboles. D'où la
définition semblant inutile d'un alphabet~: parler d'alphabet permet surtout de
situer le contexte d'étude.

\begin{definition}[Alphabet]
  Un alphabet $\Sigma$ est un ensemble fini non vide.
\end{definition}

L'intérêt d'un alphabet est avant tout de pouvoir écrire des mots avec. La
notion de mot est la notion finie par excellence~: un mot est donc simplement
une suite finie de lettres.

\begin{definition}[Mot]
  Un mot $u$ sur un alphabet $\Sigma$ est une suite finie à valeurs dans
  $\Sigma$, c'est-à-dire
  $u = (u_0,\ldots,u_{n-1})\in \Sigma^n$ pour un certain entier $n\in\mathbb N$.

  On note $\Sigma^*$ l'ensemble des mots sur $\Sigma$~:
  \[\Sigma^* \defeq \bigcup_{n\in \mathbb N} \Sigma^n\]
\end{definition}

\begin{notation}
  Pour tout mot $u\in\Sigma^n$, on note $u_i$ pour la
  \ordinalnumeralfeminin{$i$} lettre, c'est-à-dire l'image de $u$ par la
  projection $\pi_i : \Sigma^n \to \Sigma$.

  Pour tout mot $u\in\Sigma^*$, on note $|u|\in\mathbb N$ l'entier $n$ tel que
  $u\in \Sigma^n$.
\end{notation}

Remarquons qu'une suite vide est une suite finie~: on peut donc définir le mot
vide, qu'on notera $\varepsilon$.

On peut désormais définir un langage~: c'est un ensemble de mots.

\begin{definition}[Langage]
  Soit $\Sigma$ un alphabet. Un langage $\mathcal L$ sur $\Sigma$ est une partie
  $\mathcal L\subseteq\Sigma^*$.
\end{definition}

Parlons dès maintenant de stabilité~:

\begin{definition}[Stabilité]
  Soit $\Sigma$ un alphabet et $\star$ une opération binaire sur $\Sigma^*$. On
  dit qu'un langage $\mathcal L$ sur $\Sigma$ est stable par $\star$ si
  \[\forall u,v\in \mathcal L, u\star v \in \mathcal L\]
\end{definition}

Cette notion de stabilité se généralise très bien à des classes de langages,
dont il convient donc d'introduire la définition.

\begin{definition}[Classe de langages]
  Soit un alphabet $\Sigma$. On appelle classe de langages une partie
  $\mathcal C\subseteq \powerset(\Sigma^*)$ (ses éléments sont donc des
  langages).
\end{definition}

\begin{definition}[Stabilité d'une classe de langages]
  Soit $\Sigma$ un alphabet et $\star$ une opération binaire sur
  $\powerset(\Sigma^*)$. On dit qu'une classe de langages $\mathcal C$ sur
  $\Sigma$ est stable par $\star$ si
  \[\forall \mathcal L,\mathcal M\in\mathcal C,
  \mathcal L\star \mathcal M\in\mathcal C\]
\end{definition}

Pour le reste de cette sous-section, nous allons juste voir des exemples de
langages, d'opérations et de classes de langages.

\begin{example}
  Nous allons dès maintenant définir l'alphabet qui nous sera le plus utile~:
  \[\btwo \defeq \{0,1\}\]

  Voici quelques langages sur $\btwo$ ou un alphabet $\Sigma$ quelconque~:
  \begin{itemize}
  \item le langage des mots commençant par $0$~:
    \[\mathcal L_0 \defeq \{u\in\Sigma^*\mid u_0 = 0\}\]
  \item le langage des mots ayant une taille paire~:
    \[\mathcal L_{\mathrm{pair}} \defeq \{u\in\Sigma^*\mid |u|\in2\mathbb N\}\]
  \item le langage des mots dont le début et la fin sont la même lettre~:
    \[\mathcal L_{\mathrm{debut}=\mathrm{fin}}\defeq
    \{u\in\Sigma^*\mid u_0 = u_{|u| - 1}\}\]
  \item pour un langage $\mathcal L$, le langage $\overline{\mathcal L}$ des
    mots pris dans l'autre sens~:
    \[\overline{\mathcal L}\defeq
    \{u\in\Sigma^*\mid u_{|u|-1}\ldots u_0 \in \mathcal L\}\]
  \item l'intersection de deux langages.
  \item l'union de deux langages.
  \end{itemize}
\end{example}

Nous allons définir une nouvelle opération, fortement liée à la structure de
$\Sigma^*$, qui nous permettra de donner plus d'exemples de langages.

\begin{definition}[Concaténation]
  Soit un alphabet $\Sigma$. On définit l'opération de concaténation
  $\star : \Sigma^*\times\Sigma^*\to\Sigma^*$ comme le fait, étant donnés deux
  mots $u,v\in\Sigma^*$, de lire les deux mots à la suite. Formellement, on
  définit
  \[u\star v \defeq (u_0,\ldots,u_{|u|-1},v_0,\ldots,v_{|v|-1})\]

  Pour tout $n\in \mathbb N$, on notera $u^n$ pour l'itération de l'opération
  $\star$~:
  \[u^0 \defeq \varepsilon \qquad
  \forall n \in \mathbb N, u^{n+1} = u^n \star u\]
\end{definition}

\begin{remark}
  Le mot vide, $\varepsilon$, est neutre pour $\star$~: $u\star\varepsilon = u$
  et $\varepsilon \star u = u$.
\end{remark}

\begin{example}
  Voici plusieurs autres langages possibles sur un alphabet $\Sigma$~:
  \begin{itemize}
  \item pour deux langages $\mathcal L, \mathcal L'$, le langage concaténé des
    deux langages~:
    \[\mathcal L\star\mathcal L'\defeq
    \{u\star u'\mid u \in \mathcal L, u' \in \mathcal L' \}\]
  \item pour un langage $\mathcal L$, l'itération de concaténation sur ce
    langage~:
    \[\mathcal L^{\star 0} \defeq \{\varepsilon\}\qquad
    \forall n \in \mathbb N, \mathcal L^{\star(n+1)} \defeq
    \mathcal L^{\star n}\star\mathcal L\]
  \item pour un langage $\mathcal L$, le langage des mots dont toutes les
    concaténations sont encore dans $\mathcal L$~:
    \[\mathcal L_{\mathrm{stable}\star}\defeq
    \{u\in \Sigma^*\mid \forall n \in \mathbb N, u^n \in \mathcal L\}\]
  \item pour un langage $\mathcal L$, le langage des itérations de mots de
    $\mathcal L$~:
    \[\mathcal L^\star \defeq
    \{u_0\star\cdots\star u_{n-1}\mid
    n \in \mathbb N, \forall i\in \{0,\ldots,n -1\}, u_i \in \mathcal L\}\]
  \end{itemize}
\end{example}

\begin{exercise}
  Montrer que pour tout langage $\mathcal L$ sur un alphabet $\Sigma$, on a
  l'égalité suivante~:
  \[\mathcal L^\star = \bigcup_{n \in \mathbb N} \mathcal L^{\star n}\]
\end{exercise}

\begin{exercise}
  Pour tout langage $\mathcal L$ sur un alphabet $\Sigma$, on a
  $\varepsilon \in \mathcal L^\star$.
\end{exercise}

\begin{example}
  Donnons quelques exemples de classes de langages sur un alphabet $\Sigma$~:
  \begin{itemize}
  \item la classe des langages contenant $\varepsilon$~:
    \[\mathcal C_\varepsilon \defeq \{\mathcal L \subseteq \Sigma^*\mid
    \varepsilon \in \mathcal L\}\]
  \item la classe des langages stables par $\star$~:
    \[\mathcal C_\star \defeq \{\mathcal L \subseteq \Sigma^*\mid
    \forall u,v\in\mathcal L, u\star v \in \mathcal L\}\]
  \end{itemize}
\end{example}

\subsection{Aspect algébrique des langages}

Nous nous intéressons maintenant à l'aspect algébrique des langages. L'objectif
de cette sous-section est d'aboutir à la caractérisation de l'ensemble des mots
comme construction universelle (celle du monoïde libre). Pour cela, commençons
par voir ce qu'est un monoïde.

\begin{definition}[Monoïde]
  Un monoïde est un ensemble $M$ muni d'une opération binaire
  $\cdot : M \times M \to M$ et d'un élément neutre $e$,
  c'est-à-dire un élément $e\in M$ tel que
  \[\forall x\in M, x\cdot e = e \cdot x = x\]
  et tel que $\cdot$ est associative, c'est-à-dire
  \[\forall x,y,z\in M, x\cdot (y\cdot z) = (x\cdot y) \cdot z\]
\end{definition}

Définissons la notion de morphisme associée à la structure de monoïde.

\begin{definition}[Morphisme de monoïde]
  Soient $(M,\cdot,e)$ et $(N,\diamond,e')$ deux monoïdes. Un morphisme entre
  ces deux monoïdes est une fonction $f : M \to N$ vérifiant les deux conditions
  \begin{equation}
    \forall x,y\in M, f(x\cdot y) = f(x)\diamond f(y)
  \end{equation}
  \begin{equation}
    f(e) = e'
  \end{equation}
\end{definition}

Remarquons que contrairement au cas des groupes, les morphismes de monoïdes ont
besoin de stabiliser l'élément neutre.

L'exemple le plus évident de monoïde est $(\mathbb N,+,0)$, mais nous allons
voir que la structure des mots généralise de façon naturelle ce cas.

\begin{exercise}
  Soit $\Sigma$ un alphabet, montrer que $(\Sigma^*, \star,\varepsilon)$ est un
  monoïde.
\end{exercise}

Ce fait généralise le cas de $\mathbb N$ car on peut représenter un entier en
unaire comme un mot sur l'alphabet $\{*\}$~: la seule information d'un tel mot
est sa longueur.

L'étude des monoïdes permet donc d'inclure l'étude de la structure de
$\Sigma^*$. Nous allons maintenant voir qu'en fait, $\Sigma^*$ peut être
construit comme la structure de monoïde la plus simple engendrée par $\Sigma$.
Cela se traduit par la propriété universelle du monoïde libre.

\begin{theorem}[Propriété universelle du monoïde libre]
  Soit $\Sigma$ un alphabet, $(M,\diamond,e)$ un monoïde et $f : \Sigma \to M$
  une fonction (quelconque). Alors il existe un unique morphisme de monoïde
  $\tilde f$ entre $\Sigma^*$ et $M$ tel que $\tilde f (x) = f(x)$ pour tout
  $x \in \Sigma$.
\end{theorem}

\begin{proof}
  On procède par analyse-synthèse~:
  \begin{itemize}
  \item supposons que $\tilde f$ existe et vérifie les conditions décrites.
    Alors pour tout mot $u = u_0\ldots u_{n-1}$, on sait par récurrence sur
    $n$ que $\tilde f(u) = f(u_0)\diamond \cdots \diamond f(u_{n-1})$. La
    fonction ainsi définie est unique, étant donnée la construction.
  \item en considérant la fonction proposée précédemment, on voit d'abord que
    $\tilde f(x) = f(x)$ pour $x\in \Sigma$, et que si $u = v\star w$ alors
    $\tilde f(u) = \tilde f(v)\diamond \tilde f(w)$, où l'associativité est
    nécessaire pour pouvoir couper le produit au milieu sans changer le
    résultat.
  \end{itemize}
  On voit donc qu'un seul candidat est possible pour la fonction donnée, et que
  ce candidat vérifie la proposition attendue.
\end{proof}

Remarquons qu'en choisissant une fonction $f : \Sigma \to M$ sans propriété
particulière, on peut potentiellement atteindre avec $\tilde f$ des valeurs qui
ne sont pas atteintes par $f$ directement. Par exemple si on prend la fonction
\[\begin{array}{ccccc}
f & : & \Sigma & \longrightarrow & \mathbb N\\
& & \alpha & \longmapsto & 1
\end{array}\]
alors l'image d'un mot de taille $n$ est $n$. De cette façon, on vient de voir
que l'ensemble des mots de taille $n$ peut être décrit à partir du monoïde
$(\mathbb N,+,1)$ en considérant une partie du monoïde et une fonction
$f : \Sigma \to \mathbb N$.

\begin{definition}
  Soit $\Sigma$ un alphabet, $(M,\cdot,e)$ un monoïde, $h : \Sigma \to M$ une
  fonction et $S\subseteq M$. On dit que $\mathcal L(\Sigma,M,\cdot,e,h)$ est
  le langage induit par $(\Sigma,M,\cdot,e,h,S)$, qui est défini par~:
  \[\mathcal L(\Sigma,M,\cdot,e,h,S)\defeq
  \{u\in\Sigma^*\mid \tilde h(u)\in S\}\]
\end{definition}

En reprenant l'exemple de $\alpha \mapsto 1$, on voit qu'en prenant $S = \{n\}$,
on induit le langage $\Sigma^n$.

\section{Automate fini et langage reconnaissable}

On peut désormais s'intéresser plus en profondeur aux automates finis et aux
langages reconnaissables.

\subsection{Définition d'un automate}

Pour présenter un automate, le meilleur moyen est de commencer par une approche
graphique~: un automate se visualise comme une machine effectuant des opérations
élémentaires sur des mots. Dans notre premier cas, l'opération est
particulièrement simple puisque la machine se contente de lire le mot. Un
automate fini est une machine lisant linéairement un mot (elle lit chaque lettre
l'une après l'autre, sans pouvoir faire demi-tour). A chaque lettre lue,
l'automate change (ou non) d'état, parmi un ensemble fini d'états~: le mot lu
est accepté si la lecture aboutit à un certain état considéré comme acceptant.

Le formalisme derrière cette définion est lourd, mais nécessaire, nous donnons
donc la définition formelle d'un automate.

\begin{definition}[Automate fini déterministe]
  Soit un alphabet $\Sigma$. Un automate fini déterministe $\mathcal A$ sur
  $\Sigma$ est un quadruplet $(Q,q_0,\delta,F)$ où~:
  \begin{itemize}
  \item $Q$ est un ensemble fini appelé ensemble des états de $\mathcal A$,
  \item $q_0 \in Q$ est appelé l'état initial,
  \item $\delta : Q\times \Sigma \partialto Q$ est une fonction partielle
    appelée la fonction (ou table) de transitions,
  \item $F \subseteq Q$ est appelé l'ensemble des états terminaux.
  \end{itemize}

  On notera $\mathcal A_\Sigma$ l'ensemble des automates sur $\Sigma$.
\end{definition}

Le processus de lecture décrit plus haut, en reprenant les notations
introduites, consiste à prendre un mot $u = u_0\ldots u_n$ et calculer
$\delta(\delta(\cdots\delta(q_0,u_0)\cdots),u_n)$ puis vérifier que cette
valeur appartient à $F$.

\begin{definition}[Fonction de transition étendue]
  Soit un automate fini déterministe $\mathcal A$ sur un alphabet $\Sigma$ et
  $\delta$ sa fonction de transition. On appelle fonction de transition
  étendue la fonction $\delta^* : Q \times \Sigma^* \partialto Q$ définie par
  induction sur $\Sigma^*$ par~:
  \[\delta^* (q,\varepsilon) = q \qquad
  \delta^* (q,u\star a) = \delta(\delta^*(q,u),a)\]
\end{definition}

\begin{definition}[Langage accepté par un automate]
  Soit $\mathcal A$ un automate sur un alphabet $\Sigma$. On dit que
  $\mathcal A$ accepte (ou reconnait) le mot $u \in \Sigma^*$ si
  $\delta^*(q_0,u) \in F$, ce qu'on note $\mathcal A \models u$. On définit le
  langage reconnu par $\mathcal A$ par~:
  \[\mathcal L_\mathcal A \defeq \{u \in \Sigma^* \mid \mathcal A \models u\}\]
\end{definition}

Maintenant que les définitions ont été introduites, donnons une intuition
graphique de ce qu'il se passe (intuition largement indispensable pour
comprendre les automates). Pour représenter un automate $\mathcal A$, la
convention est de dessiner un graphe donc les sommets sont les états (l'ensemble
$Q$), et où $\delta$ est représentée par des arcs dirigés et étiquetés par
$\Sigma$. Par exemple, entre deux états $q$ et $q'$, s'il existe $a$ tel que
$\delta(a,q) = q'$, alors on aura une flèche $q \xrightarrow{a} q'$. L'état
initial est représenté avec une flèche entrante, et les états terminaux sont
représentés par des doubles cercles.

Prenons par exemple un premier automate sur $\btwo$~:

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
    \node[state, initial] (q_0) {$q_0$};
    \node[state,accepting] (q_1) [right = of q_0] {$q_1$};
    \node[state] (q_2) [above right = of q_1] {$q_2$};
    \node[state, accepting] (q_3) [below right = of q_1] {$q_3$};
    \path[->,>=latex]
    (q_0) edge node {0,1} (q_1)
    (q_1) edge node {1} (q_2)
    edge node {0} (q_3)
    (q_2) edge node {0} (q_3)
    edge [loop above] node {1} ()
    (q_3) edge node {1} (q_0);
  \end{tikzpicture}
\end{figure}

En lisant simplement ce dessin, on peut voir que l'automate reconnaît, par
exemple, $00$. Cette représentation a l'avantage, en plus de la lisibilité,
de donner l'ensemble des informations nécessaires pour retrouver l'objet
mathématique représenté associé.

On a ainsi construit une classe de langages~: la classe des langages
reconnaissables.

\begin{definition}[Langage reconnaissable]
  Soit $\Sigma$ un alphabet. On appelle classe des langages reconnaissbles sur
  $\Sigma$ l'ensemble des langages reconnus par les automates sur $\Sigma$~:
  \[\Reco(\Sigma) \defeq \{\mathcal L \mid
  \exists \mathcal A \in \mathcal A_\Sigma, \mathcal L = \mathcal L_\mathcal A\}\]
\end{definition}

\begin{exercise}
  Trouver le langage reconnu par l'automate suivant sur $\btwo$ (et prouver que
  le langage reconnu est bien celui attendu)~:
  \begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance = 2cm, on grid, auto]
      \node[state, initial,accepting] (q_0) {$q_0$};
      \node[state] (q_1) [right = of q_0] {$q_1$};
      \path[->,>=latex]
      (q_0) edge [bend left] node {0} (q_1)
      edge [loop above] node {1} (q_0)
      (q_1) edge [bend left] node {0} (q_0)
      edge [loop above] node {1} (q_1);
    \end{tikzpicture}
  \end{figure}
\end{exercise}

Cette premier classe de langage est en fait le centre de l'étude de ce chapitre.
On le verra, mais plusieurs définitions de cette classe existent, par des
formalismes très différents, ce qui rend cette classe de langages assez
remarquable.

L'un de ces formalismes a déjà été présenté~: on verra que les langages associés
à des monoïdes sont en fait des langages reconnus par des automates.

\subsection{Langage rationnel}

Avant de donner notre dernier formalisme, décrivons une autre classe de
langages, qui s'avérera en fait être la même classe.

\begin{definition}[Langage rationnel]
  La classe des langages rationnels sur un alphabet $\Sigma$ est la plus petite
  classe $\mathcal R$ de langages sur $\Sigma$ telle que~:
  \begin{itemize}
  \item $\varnothing \in \mathcal R$
  \item pour tout $a \in \Sigma$, $\{a\}\in \mathcal R$
  \item si $\mathcal L,\mathcal L' \in \mathcal R$ alors
    $\mathcal L\cup \mathcal L' \in \mathcal R$
  \item si $\mathcal L,\mathcal L' \in \mathcal R$ alors
    $\mathcal L\star \mathcal L' \in \mathcal R$
  \item si $\mathcal L \in \mathcal R$ alors $\mathcal L^\star \in \mathcal R$.
  \end{itemize}

  On note $\Ratio(\Sigma)$ cette classe $\mathcal R$.
\end{definition}

\begin{remark}
  Le langage $\{\varepsilon\}$ est rationnel, car il peut s'écrire
  $\varnothing^\star$. On peut donc ajouter si on le souhaite le mot vide tout
  en gardant la rationnalité d'un langage.
\end{remark}

Cette définition est une définition par induction, comme on en a rencontré
de nombreuses fois depuis le début de ce livre. Cependant, il n'est pas
particulièrement facile de manipuler un tel ensemble de langages, en particulier
pour représenter un langage de façon efficace~: devoir décrire le procédé par
lequel on obtient le langage est, pour l'instant, fastidieux.

Heureusement, il existe un formalisme permettant exactement de décrire comment
on obtient un langage rationnel à partir de ces opérations inductives, c'est ce
qu'on appelle les expressions rationnelles.

\begin{definition}[Expression rationnelle]
  Soit un alphabet $\Sigma$. On définit l'ensemble des expressions rationnelles
  par la grammaire suivante~:
  \[e,e' \Coloneq \varnothing\mid a \mid e + e' \mid e e' \mid e^\star\]
  où $a \in \Sigma$. On note $\Regex(\Sigma)$ l'ensemble des expressions
  rationnelles sur $\Sigma$.
\end{definition}

\begin{remark}
  On appelle aussi ces expressions et langages des expressions régulières et des
  langages réguliers, d'où le terme \textit{regular expression} donnant lieu à
  \textit{regex}.
\end{remark}

La correspondance est assez naturelle~: une expression de la forme $a$
représente le langage $\{a\}$, $\varnothing$ le langage vide et les trois
opérations représentent les opérations par lesquelles est stable la classe des
langages rationnels.

On définit donc une fonction d'interprétation des expressions rationnelles. De
plus, on ajoute $\varepsilon$ dans nos expressoins rationnelles, par souci de
lisbilité.

\begin{definition}[Interprétation d'une expression rationnelle]
  On définit la fonction $\Val : \Regex(\Sigma)\to\Ratio(\Sigma)$ par
  induction~:
  \begin{itemize}
  \item $\Val(\varnothing) = \varnothing$
  \item $\Val(a) = \{a\}$
  \item $\Val(e+e') = \Val(e) \cup \Val(e')$
  \item $\Val(ee') = \Val(e) \star \Val(e')$
  \item $\Val(e^\star) = (\Val(e))^\star$
  \item $\Val(\varepsilon) = \{\varepsilon\}$
  \end{itemize}
\end{definition}

\begin{exercise}
  Montrer que $\Val$ est une surjection.
\end{exercise}

\begin{exercise}
  Trouver le langage interprété par l'expression rationnelle suivante sur
  $\btwo$~:
  \[(01^\star 0)^\star\]
\end{exercise}

\begin{remark}
  Cette surjection n'est pas pour autant injective, et ce même en retirant
  $\varepsilon$ des expressions rationnelles. Par exemple, $a + a$ a la même
  interprétation que $a$.
\end{remark}

On a ainsi une façon plus simple de manipuler la classe des langages rationnels.
Notre première équivalence va donc consister en deux étapes~:
\begin{itemize}
\item montrer que les langages reconnaissables sont stables par les
  constructions de la classe des langages rationnels.
\item étant donnée un automate $\mathcal A$, construire une expression
  rationnelle $e$ dont l'interprétation est le langage reconnu par $\mathcal A$.
\end{itemize}

Pour la première étape, nous aurons besoin de faire des constructions sur les
automates.

\subsection{Constructions d'automates}

Les langages rationnels contiennent les singletons $\{a\}$ pour $a \in \Sigma$,
l'ensemble vide et sont stables par trois opérations~:
\begin{itemize}
\item l'union,
\item la concaténation de langage,
\item l'étoile d'un langage.
\end{itemize}

Il est clair qu'on peut construire des automates pour les singletons~:
\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
      \node[state, initial] (q_0) {$q_0$};
      \node[state,accepting] (q_1) [right = of q_0] {$q_1$};
      \path[->,>=latex]
      (q_0) edge [bend left] node {$a$} (q_1);
  \end{tikzpicture}
\end{figure}
et pour l'ensemble vide~:
\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
      \node[state, initial] (q_0) {$q_0$};
  \end{tikzpicture}
\end{figure}

Le point essentiel est donc la stabilité par les trois opérations. On va donc
devoir introduire deux constructions d'automates~: l'automate union, et les
$\varepsilon$-transitions.

\begin{definition}[Automate union]
  Soient $\mathcal A$ et $\mathcal A'$ deux automates sur un alphabet $\Sigma$.
  On définit l'automate union $\mathcal A \sqcup \mathcal A'$ par~:
  \begin{itemize}
  \item $Q_{\mathcal A\sqcup \mathcal A'} \defeq Q\times Q'$
  \item $q_{0,\mathcal A\sqcup \mathcal A'} \defeq (q_0,q'_0)$
  \item $\delta_{\mathcal A \sqcup \mathcal A'}(q,a) \defeq (\delta_{\mathcal A}(q,a),
    \delta_{\mathcal A'}(q,a))$
  \item $F_{\mathcal A \sqcup \mathcal A'} \defeq F\times Q' \cup Q\times F'$
  \end{itemize}
\end{definition}

\begin{proposition}\label{prop.union.ratio}
  Pour tous automates $\mathcal A, \mathcal A'$ sur un alphabet $\Sigma$ donné,
  on a l'équation
  \[\mathcal L_{\mathcal A} \cup \mathcal L_{\mathcal A'} =
  \mathcal L_{\mathcal A \sqcup \mathcal A'}\]
\end{proposition}

\begin{proof}
  On montre d'abord par récurrence sur $u$ que pour tout $u \in \Sigma^\star$,
  on a
  \[\delta_{\mathcal A\sqcup\mathcal A'}^\star((q_0,q'_0),u) =
  (\delta_\mathcal A^\star(q_0,u),\delta_{\mathcal A'}^\star(q'_0,u))\]
  \begin{itemize}
  \item pour $u = \varepsilon$, le résultat est par définition.
  \item si l'égalité est vraie pour $u$ et pour tout $a \in \Sigma$, on a
    \begin{align*}
      \delta_{\mathcal A\sqcup\mathcal A'}^\star ((q_0,q'_0),u\star a) &=
      \delta_{\mathcal A\sqcup \mathcal A'}(
      \delta_{\mathcal A\sqcup \mathcal A'}^\star(q_0,q'_0),a)\\
      &= \delta_{\mathcal A\sqcup\mathcal A'}(
      (\delta_\mathcal A^\star(q_0,u),\delta_{\mathcal A'}^\star(q'_0,u)),a)\\
      &= (\delta_\mathcal A(\delta_\mathcal A^\star(q_0,u)),\delta_{\mathcal A'}(
      \delta_{\mathcal A'}^\star(q'_0,u)))\\
      &= (\delta_\mathcal A^\star(q_0,u\star a),
      \delta_{\mathcal A'}^\star(q'_0,u\star a))
    \end{align*}
  \end{itemize}

  De plus, $(q,q') \in F\times Q' \cup Q\times F'$ signifie que $q \in F$ ou
  $q' \in F'$. On en déduit donc, en utilisant le résultat précédent, que
  \[\mathcal A \sqcup \mathcal A'\models u \iff
  \mathcal A \models u \lor \mathcal A'\models u\]
\end{proof}

\begin{exercise}[Automate produit]
  Soient $\mathcal A$ et $\mathcal A'$ deux automates sur un alphabet $\Sigma$.
  On définit l'automate produit $\mathcal A \times \mathcal A'$ par~:
  \begin{itemize}
  \item $Q_{\mathcal A\sqcup \mathcal A'} \defeq Q\times Q'$
  \item $q_{0,\mathcal A\sqcup \mathcal A'} \defeq (q_0,q'_0)$
  \item $\delta_{\mathcal A \sqcup \mathcal A'}(q,a) \defeq (\delta_{\mathcal A}(q,a),
    \delta_{\mathcal A'}(q_a))$
  \item $F_{\mathcal A \sqcup \mathcal A'} \defeq F\times F'$
  \end{itemize}

  Montrer que cet automate reconnait
  $\mathcal L_\mathcal A \cap \mathcal L_{\mathcal A'}$, en déduire que les
  langages reconnaissables sont stables par intersection (binaire).
\end{exercise}

On veut maintenant montrer la stabilité par concaténation de deux langages et
par étoile d'un langage. L'idée derrière ces deux constructions est relativement
simple~: pour deux automates $\mathcal A,\mathcal A'$, l'automate reconnaissant
la concaténation est une copie de chacun des deux automates, en ajoutant des
transitions entre les états acceptants de $\mathcal A$ et l'état initial de
$\mathcal A'$. De même pour l'étoile d'un langage, on ajoute un nouvel état
initial, acceptant, on le relie à l'ancien état initial et on crée une
transition entre chaque état acceptant et le nouvel état initial.

Cependant, ces transitions demandent à pouvoir être effectuées automatiquement,
en ayant la possibilité pour un état de faire (ou non) cette transition avant
la lecture d'une nouvelle lettre. Cela nous pousse à ajouter deux choses~: le
non déterminisme, pour pouvoir choisir ou non si l'on fait une transition, et
les $\varepsilon$-transitions, qui sont des transitions qui, comme décrites
précédemment, peuvent s'exécuter ou non et sans lecture de lettre.

Commençons par présenter un automate non déterministe~: celui-ci est un automate
dans lequel, au lieu d'une fonction de transition indiquant à partir d'un état
et d'une lettre quel est l'état lu ensuite, on dispose d'une relation de
transition indiquant pour deux états et une lettre s'il existe une transition
entre ces deux états étiquetée par cette lettre. On lui préfère en général une
présentation équivalente~: à un état et une lettre on associe l'ensemble des
états possibles à atteindre.

\begin{definition}[Automate fini non déterministe]
  Soit $\Sigma$ un alphabet. On appelle automate fini non déterministe
  $\mathcal A$ un quadruplet $(Q,Q_0,\delta,F)$ où~:
  \begin{itemize}
  \item $Q$ est un ensemble fini appelé ensemble des états de $\mathcal A$,
  \item $Q_0\subseteq Q$ est l'ensemble des états initiaux,
  \item $\delta : Q\times \Sigma \partialto \powerset(Q)$ est la fonction de
    transition non déterministe,
  \item $F\subseteq Q$ est l'ensemble des états terminaux.
  \end{itemize}
\end{definition}

On peut définir la fonction de transition étendue, dont le principe est de
considérer l'union à chaque fois qu'on prend un ensemble d'états possibles.

\begin{definition}[Fonction de transition étendue]
  Soit un automate fini non déterministe $\mathcal A$ sur un alphabet $\Sigma$,
  on note $\delta^\star : Q \times \Sigma^\star \to \powerset(Q)$ sa fonction de
  transition étendue, définie par induction par~:
  \begin{itemize}
  \item $\delta^\star(q,\varepsilon) = \{q\}$
  \item $\displaystyle\delta^\star(q,u\star a) =
    \bigcup_{q' \in \delta^\star(q,u)} \delta(q',a)$
  \end{itemize}
\end{definition}

\begin{definition}[Langage accepté]
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate fini non déterministe
  sur $\Sigma$. On dit que $\mathcal A$ accepte (ou reconnaît) le mot
  $u \in \Sigma^\star$ s'il existe $q_0 \in Q_0$ tel que
  $\delta^*(q_0,u) \cap F\neq\varnothing$, ce qu'on note $\mathcal A \models u$.
  On définit le langage reconnu par $\mathcal A$ par~:
  \[\mathcal L_\mathcal A\defeq \{u \in \Sigma^\star \mid \mathcal A \models u\}\]
\end{definition}

Un automate fini non déterministe se représente comme un automate fini
déterministe, à ceci près qu'on accepte d'avoir plusieurs flèches depuis un
état qui sont étiquetées par la même lettre, et qu'on peut avoir plusieurs
états initiaux. Accepter un mot dans un tel automate est alors simplement
trouver au moins un chemin partant d'un état initial et arrivant à un état
terminal en suivant des transitions étiquetées par les lettres du mot lu.

Cela mène à une définition alternative de l'acceptation d'un mot, qu'on traite
en exercice. La notion de trace est assez générale, et représente l'historique
de l'exécution d'une entrée sur une machine~: ici, la trace d'un automate est
alors la suite des états dans lesquels est la machine en lisant un mot.

\begin{exercise}\label{exo.traces.auto}
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate fini non déterministe
  sur $\Sigma$. On définit, pour tout $u \in \Sigma^\star$, l'ensemble $\tr(u)$
  des traces de $u$ sur $\mathcal A$, comme l'ensemble des suites finies
  $(q_0,\ldots,q_n)$ d'états de $\mathcal A$ dont le premier élément est un
  élément de $Q_0$ et tel que $\delta(q_i,u_i) = q_{i+1}$ pour tout
  $i \in \{0,\ldots,n-1\}$. Montrer que $\mathcal A \models u$ si et seulement
  s'il existe un élément $p \in \tr(u)$ dont le dernier état est un état
  terminal.
\end{exercise}

On pourrait s'attendre à ce que relâcher tant de contraintes augmente la
puissance des automates, mais ce n'est en réalité pas le cas. Il est clair qu'un
automate déterministe peut être transformé en un automate non déterministe, en
prenant $Q_0 \defeq \{q_0\}$ et pour fonction de transition non déterministe le
singleton de l'image par la fonction de transition déterministe. La réciproque,
elle, demande une construction plus subtile, appelée l'automate des parties.

\begin{definition}[Automate des parties]
  Soit un alphabet $\Sigma$ et un automate fini non déterministe $\mathcal A$
  sur $\Sigma$. On définit l'automate des parties de $\mathcal A$, noté
  $\powerset(\mathcal A)$, par~:
  \begin{itemize}
  \item $Q_{\powerset(\mathcal A)} \defeq \powerset(Q_\mathcal A)$
  \item $q_0 \defeq Q_0$
  \item $\delta_{\powerset(\mathcal A)} (R,a) \defeq
    \bigcup_{q \in R} \delta_{\mathcal A}(q,a)$
  \item $F_{\powerset(\mathcal A)} \defeq \{R \subseteq Q\mid
    R\cap F \neq \varnothing\}$
  \end{itemize}
\end{definition}

\begin{proposition}
  Soit un automate non déterministe $\mathcal A$ sur un alphabet $\Sigma$, on a
  l'égalité
  \[\mathcal L_{\mathcal A} = \mathcal L_{\powerset(\mathcal A)}\]
\end{proposition}

\begin{proof}
  On prouve par induction sur $u$ que pour tout $u \in \Sigma^\star$, on a
  l'égalité suivante pour tout $R \subseteq Q$~:
  \[\delta^\star_{\powerset(\mathcal A)}(R,u) = \delta^\star_{\mathcal A}(R,u)\]
  \begin{itemize}
  \item dans le cas où $u = \varepsilon$, le résultat est direct.
  \item supposons que l'hypothèse d'induction est valide pour $u$ et montrons
    le cas $u \star a$~:
    \begin{align*}
      \delta^\star_{\powerset(\mathcal A)}(R,u\star a) &=
      \bigcup_{q \in \delta^\star_{\powerset(\mathcal A)}(R,u)}
      \delta_{\mathcal A}(q,a)\\
      &= \bigcup_{q \in \delta^\star_\mathcal A(R,u)} \delta_\mathcal A(q,a)\\
      &= \delta_\mathcal A^\star(R,u\star a)
    \end{align*}
  \end{itemize}
  D'où le résultat par induction. On voit alors que la condition pour que
  $u$ soit accepté, dans les deux automates, revient à
  \[\delta_{\powerset(\mathcal A)}^\star (Q_0,u) \cap F \neq \varnothing\]
  donc $\mathcal L_{\powerset(\mathcal A)} = \mathcal L_\mathcal A$.
\end{proof}

\begin{remark}
  Cette construction n'est pas gratuite en pratique~: elle fait passer d'un
  ensemble d'états à son ensemble des parties, ce qui donne une complexité
  exponentielle à la construction.
\end{remark}

On peut donc utiliser des automates non déterministes pour étudier les langages
reconnaissables. On introduit maintenant les $\varepsilon$-transitions, qui
ont plus de sens dans le contexte des automates non déterministes.

\begin{definition}[Automate avec $\varepsilon$-transitions]
  On définit un automate fini non déterministe avec $\varepsilon$-transitions
  comme un automate fini non déterministe, mais dans lequel la fonction de
  transition est de la forme
  $\delta : Q\times (\Sigma \cup \{\varepsilon\}) \partialto Q$.
\end{definition}

Pour définir l'acceptation d'un mot par un automate avec
$\varepsilon$-transitions, on utilisera le formalisme des traces, introduit dans
l'\cref{exo.traces.auto}.

\begin{definition}[Langage reconnu par un automate avec
    $\varepsilon$-transitions]
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate non déterministe avec
  $\varepsilon$-transitions sur $\Sigma$. On définit l'ensemble $\tr(u)$ des
  traces sur un mot $u$ comme l'ensemble des suites finies $(q_0,\ldots,q_n)$
  d'états de $Q$ où $q_0 \in Q_0$ et telles qu'il existe pour tout
  $i \in \{0,\ldots,n-1\}$ une lettre $a_i$ telle que les deux conditions
  suivantes sont vérifiées~:
  \begin{itemize}
  \item $\delta(q_i,a_i) = q_{i+1}$
  \item $u = a_0\star\cdots\star a_{n-1}$
  \end{itemize}
  On dit que $\mathcal A$ accepte le mot $u$
  s'il existe une suite $(q_0,\ldots,q_n) \in \tr(u)$ telle que $q_n \in F$.

  On définit le langage reconnu par $\mathcal A$ comme l'ensemble des mots
  reconnus par $\mathcal A$.
\end{definition}

Les traces dans un automate avec $\varepsilon$-transitions représentent juste
les exécutions possibles lors de la lecture d'un mot, mais où il est possible
d'effectuer gratuitement des transitions étiquetées par $\varepsilon$.

Là encore, il est clair qu'un automate sans $\varepsilon$-transition peut être
simulé par un automate sans $\varepsilon$-transition, en n'ajoutant aucune
$\varepsilon$-transition.

On introduit donc maintenant l'élimination des $\varepsilon$-transitions,
permettant de construire un automate sans $\varepsilon$-transition mais
reconnaissant le même langage.

L'idée de l'élimination des $\varepsilon$-transitions est assez simple~: au lieu
de faire des sauts spontanés dans une $\varepsilon$-transition, on décide de
faire une grande transition contenant toutes les $\varepsilon$-transitions ainsi
que la transition qui suit. Il nous faut aussi modifier l'ensemble des états
terminaux pour ajouter les états qui peuvent atteindre un état terminal
uniquement en effectuant des $\varepsilon$-transitions.

\begin{definition}[\'Elimination des $\varepsilon$-transitions]
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate avec
  $\varepsilon$-transitions sur $\Sigma$. On définit la relation $\to^\star$ sur
  les états de $\mathcal A$ comme la plus petite relation  réflexive et
  transitive contenant la relation
  \[q\to q' \defeq q' \in \delta(q,\varepsilon)\]

  On définit l'automate $\mathcal A_{\not\varepsilon}$ non déterministe sans
  $\varepsilon$-transition par la construction suivante~:
  \begin{itemize}
  \item $Q_{\mathcal A_{\not\varepsilon}} \defeq Q_\mathcal A$
  \item $Q_{0,\mathcal A_{\not\varepsilon}} \defeq Q_{0,\mathcal A}$
  \item $\displaystyle\delta_{\mathcal A_{\not\varepsilon}}(q,a) \defeq
    \bigcup_{{q' \in Q}\atop{q\to^\star q'}} \delta_{\mathcal A}(q',a)$
  \item $F_{\mathcal A_{\not\varepsilon}} =\{q \in Q
    \mid \exists q' \in Q, q \to^\star q' \land q' \in F_\mathcal A\}$
  \end{itemize}
\end{definition}

\begin{proposition}\label{prop.epsi.equiv}
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate avec
  $\varepsilon$-transitions sur $\Sigma$. Alors
  \[\mathcal L_{\mathcal A} = \mathcal L_{\mathcal A_{\not\varepsilon}}\]
\end{proposition}

\begin{proof}
  On prouve d'abord que $q'\in \delta_{\mathcal A_{\not\varepsilon}}(q,a)$ si et
  seulement s'il existe une suite finie $(q_0,\ldots,q_n)$ telle que~:
  \begin{itemize}
  \item $q_0 = q$
  \item $\forall i \in \{0,\ldots,n-2\}, q_{i+1} \in
    \delta_{\mathcal A}(q_i,\varepsilon)$
  \item $q_n \in \delta_{\mathcal A}(q_{n-1},a)$
  \item $q_n = q'$
  \end{itemize}
  Pour un sens, on remarque que dans une telle suite, $q_1 \to^\star q_{n-1}$
  donc $\delta_{\mathcal A_{\not\varepsilon}}(q,a)\supseteq \delta_\mathcal A(q_{n-1},a)$.
  Pour l'autre sens, on sait par définition qu'il existe $q''$ tel que
  $q\to^\star q''$ et $q'\in\delta_\mathcal A (q'',a)$, donc il nous reste à
  vérifier que si $q\to^\star q''$ alors il existe une suite d'états uniquement
  reliés par des $\varepsilon$-transition, ce qui se fait par induction sur
  $\to^\star$ (on laisse la vérification au lecteur).

  Ainsi, on a une trace $(q_0,\ldots,q_n)$ dans $\mathcal A$ pour un mot $u$
  donné si et seulement si $(q'_0,\ldots,q'_p)$, obtenue en supprimant les
  états reliés par des $\varepsilon$-transitions, est une trace pour $u$ dans
  $\mathcal A_{\not\varepsilon}$ (réciproquement si on peut ajouter des états
  reliés par des $\varepsilon$-transitions).

  De plus, un état $q_n$ est terminal dans $\mathcal A_{\not\varepsilon}$ si et
  seulement s'il existe une suite d'$\varepsilon$-transitions menant à un état
  terminal~: ainsi une trace terminant sur un tel état dans $\mathcal A$ donne
  une trace acceptante en ajoutant des $\varepsilon$-transitions et
  réciproquement on récupère une trace acceptante dans
  $\mathcal A_{\not\varepsilon}$ en supprimant ces $\varepsilon$-transitions.

  Ainsi
  \[\mathcal L_{\mathcal A} = \mathcal L_{\mathcal A_{\not\varepsilon}}\]
\end{proof}

On sait donc maintenant que les automates déterministes, non déterministes et
non déterministes avec $\varepsilon$-transitions, sont tous équivalents du
point de vue de la classe de langage qu'ils reconnaissent.

On peut maintenant prouver la stabilité des langages reconnaissables par
concaténation de langages et par étoile.

\begin{proposition}\label{prop.concat.ratio}
  Soit $\Sigma$ un alphabet et $\mathcal A, \mathcal A'$ deux automates non
  déterministes avec $\varepsilon$-transitions sur $\Sigma$. Alors il existe
  un automate reconnaissant
  \[\mathcal L_\mathcal A \star \mathcal L_{\mathcal A'}\]
\end{proposition}

\begin{proof}
  On construit l'automate $\mathcal A''$ dont les états est la somme directe des
  états de $\mathcal A$ et $\mathcal A'$ (pour simplifier les notations on va
  considérer les deux ensembles d'états disjoints et considérer leur union), les
  transitions sont uniquement celles définies au sein de $\mathcal A$ et
  $\mathcal A'$ sauf entre chaque état $q_f$ de $\mathcal A$ et chaque état
  initial $q_i$ de $\mathcal A'$ où l'on rajoute une transition
  $q_f\xrightarrow{\varepsilon} q_i$. Les états initiaux sont ceux de
  $\mathcal A$ et les états terminaux ceux de $\mathcal A'$.

  Accepter un mot dans cet automate signifie donc avoir une trace
  $(q_0,\ldots,q_n)$ commençant en un état initial de $\mathcal A$ et terminant
  dans un état terminal de $\mathcal A'$. Comme la seule façon de passer d'un
  état de $\mathcal A$ a un état de $\mathcal A'$ est d'utiliser une des
  $\varepsilon$-transitions ajoutées, on sait que la trace peut se décomposer
  en $(q_0,\ldots,q_p)$ et $(q_{p+1},\ldots,q_n)$ et ces deux traces sont
  acceptantes respectivement pour un mot dans $\mathcal L_\mathcal A$ et pour un
  mot dans $\mathcal L_{\mathcal A'}$, donc la trace est acceptant pour un
  mot dans $\mathcal L_\mathcal A \star \mathcal L_{\mathcal A'}$.

  Réciproquement, si on a deux traces $(q_0,\ldots,q_p)$ et
  $(q_{p+1},\ldots,q_n)$ pour respectivement $u \in \mathcal L_{\mathcal A}$ et
  $v\in\mathcal L_{\mathcal A'}$, alors $(q_0,\ldots,q_n)$ est une trace
  acceptante pour $u\star v$.
\end{proof}

On prouve de même qu'ajouter simplement des transitions entre les états
terminaux et initiaux d'un automate donne le langage de l'étoile. Comme la
preuve est très proche de la preuve précédente, nous préférons la donner en
exercice.

\begin{definition}[Automate étoile]
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate sur $\Sigma$. On définit
  l'automate étoile $\mathcal A^\star$ par~:
  \begin{itemize}
  \item $Q_{\mathcal A^\star} \defeq Q_\mathcal A \sqcup \{p\}$
  \item $Q_{0,\mathcal A^\star} \defeq \{p\}$
  \item $\delta_{\mathcal A^\star}$ est définie comme $\delta_\mathcal A$ mais en
    ajoutant des $\varepsilon$-transitions entre $p$ et chaque
    $q_0\in Q_{0,\mathcal A}$, ainsi qu'entre chaque $q_f \in F_\mathcal A$ et
    $p$.
  \item $F_{\mathcal A^\star} \defeq \{p\}$.
  \end{itemize}
\end{definition}

\begin{exercise}\label{prop.etoile.ratio}
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate sur $\Sigma$, montrer
  que
  \[\mathcal L_{\mathcal A^\star} = \mathcal L_{\mathcal A}^\star\]
\end{exercise}

On déduit donc des constructions effectuées la stabilité par les opérations
rationnelles.

\begin{corollary}
  Soit $\Sigma$ un alphabet. La classe $\Reco(\Sigma)$ contient la classe
  $\Ratio(\Sigma)$.
\end{corollary}

\begin{proof}
  On a déjà dit que $\varnothing \in \Reco(\Sigma)$ et que
  $\{a\}\in \Reco(\Sigma)$ pour tout $a \in \Sigma$. De plus, en utilisant la
  \cref{prop.union.ratio}, la \cref{prop.concat.ratio} et
  l'\cref{prop.etoile.ratio}, on en déduit que $\Reco$ est stable par union,
  concaténation et étoile. On en déduit donc, puisque $\Ratio(\Sigma)$ est la
  plus petite telle classe, que $\Ratio(\Sigma)\subseteq\Reco(\Sigma)$.
\end{proof}

Avant de montrer l'inclusion réciproque, il nous faut nous attarder sur les
propriétés des automates.

\subsection{Propriétés d'automates}

Plusieurs propriétés d'intérêt existent, à propos des automates. Pour faciliter
la génération d'une expression rationnelle à pratir d'un automate, nous allons
présenter des propriétés basiques à leur propos. La première est celle
d'avoir une table de transition totale plutôt que partielle.

\begin{definition}[Automate complet]
  Un automate $\mathcal A$ est dit complet si la fonction de transition $\delta$
  est une fonction totale.
\end{definition}

Il est facile d'assurer cette propriété en ajoutant un état dit \og puits\fg
vers lequel pointent toutes les transitions à ajouter, et les transitions
partant de cet état.

\begin{proposition}
  Soit $\mathcal A$ un automate sur un alphabet $\Sigma$, il existe un automate
  $\mathcal A'$ qui est complet et reconnaît le même langage que $\mathcal A$.
\end{proposition}

\begin{proof}
  On construit l'automate $\mathcal A'$ comme décrit ci-dessus~:
  \begin{itemize}
  \item $Q' \defeq Q \sqcup \{p\}$
  \item $q'_0 \defeq q_0$
  \item $\delta' : Q' \times \Sigma \to Q'$ est défini par disjonction de cas~:
    \begin{itemize}
    \item si $(q,a) \in \dom(\delta)$, alors $\delta'(q,a) = \delta(q,a)$
    \item sinon, $\delta'(q,a) = p$
    \end{itemize}
  \item $F' = F$
  \end{itemize}

  On veut maintenant prouver que les deux automates reconnaissent le même
  langage. Soit $u \in \Sigma^\star$, montrons que $\delta^\star(q_0,u)$ est
  indéfini si et seulement si $\delta'^\star(q_0,u) = p$ et que sinon
  $\delta'^\star(q_0,u) = \delta^\star(q_0,u)$, par induction sur $u$~:
  \begin{itemize}
  \item dans le cas de $\varepsilon$, on sait que
    $\delta'^\star(q_0,\varepsilon) = \delta^\star(q_0,\varepsilon) = q_0$.
  \item supposons l'hypothèse vraie pour $u$, et soit $a \in \Sigma$. Supposons
    que $\delta^\star(q_0,u\star a)$ est indéfinie, on a alors deux cas
    possibles~:
    \begin{itemize}
    \item Si $\delta^\star(q_0,u)$ est indéfinie, alors par hypothèse
      d'induction $\delta'^\star(q_0,u) = p$ et comme $\delta'(p,a) = p$, on en
      déduit que $\delta'^\star(q_0,u\star a) = p$.
    \item Si $\delta^\star(q_0,u) = q$ et $\delta(q,a)$ est indéfini, alors
      par hypothèse d'induction $\delta'^\star(q_0,u) = q$ et, par définition,
      $\delta'(q,a) = p$.
    \end{itemize}
    
    Réciproquement, si $\delta'^\star(q_0,u\star a) = p$ alors c'est que la
    transition a atteint un état puits à un moment, et cela correspondait à
    une transition non définie dans $\delta$ (la preuve est parfaitement
    analogue à celle du sens direct).

    Dans l'autre cas, si $\delta'^\star(q_0,u\star a) = q$ où $q \in Q$, alors
    on sait par induction que $\delta'^\star(q_0,u) = \delta(q_0,u) = q'$ par
    hypothèse d'induction, et $\delta'(q,a) = \delta(q,a)$ par définition,
    donc $\delta'^\star(q_0,u\star a) = \delta^\star(q_0,u\star a)$.
  \end{itemize}

  On en déduit donc~:
  \[\delta^\star(q_0,u) \in F \iff \delta'^\star(q_0,u)\in F\]
  ce qui est le résultat voulu.
\end{proof}

Une autre propriété importante sur un automate est celle d'automate émondé.
Pour donner une idée de leur intérêt, reprenons la construction précédente.
En complétant un automate, on ajoute un état puits, mais arriver à cet état
signifie forcément que la lecture du mot n'arrivera jamais à un état acceptant.
On peut donc, si on préfère minimiser le nombre d'états qui interviennent
effectivement dans l'automate, décider de supprimer notre état puits, mais aussi
tous les états qui n'arriveront jamais à un état acceptant. De tels états sont
dits co-accessibles. Un état accessible, lui, est un état qu'on peut atteindre
à la lecture d'un mot~: en effet, si un état mène à un état acceptant (ou même
est lui-même acceptant), cela n'a peut d'importance si aucun chemin ne mène à
lui.

On peut donc donner des définitions similaires à propos d'un automate pour
parler de tous ses états~: un automate accessible est un automate dont tous les
états sont accessibles et un automate co-accessible est un automate dont tous
les états sont co-accessibles. Un automate à la fois accessible et co-accessible
est appelé un automate émondé, et il est toujours possible de construire un
automate émondé, en ne gardant que les états traversés lors de traces
acceptantes.

\begin{proposition}
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate sur $\Sigma$. Alors
  il existe un automate $\mathcal A'$ émondé qui reconnaît le même langage que
  $\mathcal A$.
\end{proposition}

\begin{proof}
  On remarque que pour toute trace $(q_0,\ldots,q_n)$ acceptante, les états
  $q_i, i \in \{0,\ldots,n\}$ sont à la fois accessibles et co-accessibles.
  Ainsi, si une trace contient un état non accessible ou non co-accessible,
  alors elle n'est pas acceptante. Puisqu'un mot $u$ n'est accepté que lorsqu'il
  existe une trace acceptante pour $u$, l'ensemble des mots acceptés n'est pas
  changé en ne gardant que les états à la fois accessibles et co-accessibles. On
  en déduit que l'automate $\mathcal A'$ induit par $\mathcal A$ en ne prenant
  que les états intervenant dans des traces acceptantes reconnaît le même
  langage que $\mathcal A$.
\end{proof}

Enfin, parlons de la notion d'automate normalisé. Un tel automate est un
automate dans lequel on peut trouver trois parties~: l'état initial,
unique, le c\oe ur de l'automate et l'état terminal. Celui-ci permet d'avoir
une forme plus linéaire à un automate.

\begin{definition}[Automate normalisé]
  Soit $\Sigma$ un alphabet. Un automate normalisé sur $\Sigma$ est un automate
  sur $\Sigma$ tel qu'il existe un unique état initial, un unique état terminal,
  tel qu'il n'existe aucune transition d'un état vers l'état initial et aucune
  transition depuis l'état terminal.
\end{definition}

\begin{proposition}
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate sur $\Sigma$, il existe
  alors un automate non déterministe avec $\varepsilon$-transitions, normalisé,
  reconnaissant le même langage que $\mathcal A$.
\end{proposition}

\begin{proof}
  On construit l'automate simplement en ajoutant un nouvel état initial $q_0$
  et un nouvel état terminal $q_f$ et des $\varepsilon$-transitions depuis
  $q_0$ vers tout état anciennement initial, et de tout état anciennement
  terminal vers $q_f$.
\end{proof}

\begin{exercise}
  Montrer que l'automate construit précédemment reconnaît le même langage que
  $\mathcal A$.
\end{exercise}

On peut aussi procéder à l'élimination des $\varepsilon$-transitions sur un
tel automate, mais on remarque alors un problème~: si le langage contient
$\varepsilon$, alors il doit y avoir une transition de $q_0$ à $q_f$ étiquetée
par $\varepsilon$, ce qui ne peut pas s'éliminer en gardant $q_0$ et $q_f$
distincts. On a donc besoin d'ajouter que le langage reconnu par $\mathcal A$
ne contient par $\varepsilon$, si l'on veut renforcer le résultat en donnant un
automate sans $\varepsilon$-transitions normalisé.

On montre maintenant que $\Reco(\Sigma)\subseteq \Ratio(\Sigma)$. Pour montrer
cette inclusion, on va construire une expression rationnelle par un processus
d'élimination d'états depuis un automate. \'Etant donné un automate
$\mathcal A$, on peut considérer les étiquettes comme des expressions
rationnelles limitées à un caractère. Avec cette considération, effectuer deux
transitions $\xrightarrow a \xrightarrow b$ correspond à une seule transition
$\xrightarrow{ab}$. Cela nous donne alors une procédure pour regrouper des
transitions, et ainsi éliminer des états (puisque l'état du milieu entre la
transition $a$ et la transition $b$ peut alors être supprimé). On a ainsi un
algorithme qui construit un expression rationnelle pour un automate. On remarque
que les $\varepsilon$-transitions sont parfaitement adaptées dans ce contexte,
puisque $\Val(\varepsilon e) = \Val(e)$, comme on l'attend d'une
$\varepsilon$-transition.

La procédure à suivre est donc la suivante~:
\begin{itemize}
\item définir une notion plus générale d'automate fini qui permet d'utiliser des
  expressions rationnelles pour les étiquettes,
\item créer le processus d'élimination d'état,
\item montrer que ce processus conserve le langage reconnu.
\end{itemize}

\begin{definition}[Automate fini généralisé]
  Soit $\Sigma$ un alphabet, on appelle un automate fini généralisé un
  quadruplet $(Q,Q_0,\delta,F)$ tel que~:
  \begin{itemize}
  \item $Q$ est l'ensemble fini des états,
  \item $Q_0\subseteq Q$ est l'ensemble des états initiaux,
  \item $\delta : Q \times \Regex(\Sigma) \partialto \powerset(Q)$ est la
    fonction de transition généralisée,
  \item $F\subseteq Q$ est l'ensemble des terminaux.
  \end{itemize}
\end{definition}

\begin{definition}[Acceptation d'un mot par un automate généralisé]
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate généralisé sur $\Sigma$.
  On dit qu'un mot $u\in \Sigma^\star$ est accepté (ou reconnu) par $\mathcal A$
  s'il existe une décomposition $u = u_0\star\cdots\star u_{p-1}$ et une suite
  d'états $(q_0,\ldots,q_p)$ telles que~:
  \begin{itemize}
  \item $q_0 \in Q_0$
  \item $q_p \in F$
  \item $\forall i \in \{0,\ldots,p-1\}, \exists e \in \Regex(\Sigma),
    u_i \in \Val(e) \land q_{i+1}\in \delta(q_i,e)$
  \end{itemize}
\end{definition}

On voit ici qu'une inclusion évidente existe entre les automates non
déterministes et les automates généralisés~: il suffit de transformer
l'étiquette $a$ par le regex $a$. On veut donc maintenant construire le
processus d'élimination. On a dit précédemment qu'une suite de deux transitions
peut se transformer en une seule concaténation, ce qui donne l'idée suivante de
transformation~:

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
    \node[state] (q_0) {$q_0$};
    \node[state] (q_1) [right = of q_0] {$q_1$};
    \node[state] (q_2) [right = of q_1] {$q_2$};
    \node (use) [right = of q_2] {$\longmapsto$};
    \node[state] (q_3) [right = of use] {$q_0$};
    \node (use2) [right = of q_3] {};
    \node[state] (q_4) [right = of use2] {$q_2$};
    \path[->,>=latex]
    (q_0) edge node {$a$} (q_1)
    (q_1) edge node {$b$} (q_2)
    (q_3) edge node {$ab$} (q_4);
  \end{tikzpicture}
\end{figure}

En effectuant cette transformation entre chaque paire de transitions passant par
$q_1$, il semble donc possible d'éliminer l'état $q_1$. Cependant, un cas
important reste possible~: on peut avoir une boucle sur $q_1$. Dans ce cas, il
est nécessaire d'ajouter pour chaque expression $e$ étiquetant une boucle,
l'expression $ae^\star b$ au lieu de simplement $ab$~:

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
    \node[state] (q_0) {$q_0$};
    \node[state] (q_1) [right = of q_0] {$q_1$};
    \node[state] (q_2) [right = of q_1] {$q_2$};
    \node (use) [right = of q_2] {$\longmapsto$};
    \node[state] (q_3) [right = of use] {$q_0$};
    \node (use2) [right = of q_3] {};
    \node[state] (q_4) [right = of use2] {$q_2$};
    \path[->,>=latex]
    (q_0) edge node {$a$} (q_1)
    (q_1) edge node {$b$} (q_2)
    (q_1) edge [loop above] node {$e$} ()
    (q_3) edge node {$ae^\star b$} (q_4);
  \end{tikzpicture}
\end{figure}

Il reste un souci~: il est possible qu'il existe plusieurs transitions
distinctes entre deux états donnés. Pour contrer ça, on s'assure d'abord qu'on
peut, sans perte de généralité, considérer qu'un automate généralisé n'a qu'au
plus une transition d'un état à un autre.

On introduit une nouvelle notation~: on décrit les transitions avec $R_\delta$
définie par la formule suivante~:
\[R_\delta(q,e,q') \defeq q' \in \delta(q,e)\]
On définit aussi la notation $\sum e_i$ pour des expressions rationnelles
$e_1,\ldots,e_n$, comme $\varnothing$ si $n = 0$ et de façon naturelle en
itérant l'opération $+$ sinon.

\begin{proposition}
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate généralisé sur $\Sigma$.
  Il existe alors un automate généralisé $\mathcal A'$, équivalent à
  $\mathcal A$, tel que pour tous états $q,q'$ il existe exactement une
  expression $e$ telle que $R_\delta(q,e,q')$.
\end{proposition}

\begin{proof}
  On construit $\mathcal A'$ en remplaçant pour tous états $q,q'$ les
  expressions les reliant par l'unique expressions
  \[\sum_{e \in \Regex(\Sigma)\atop{R_\delta(q,e,q')}} e\]
  Soit un mot $u\in \Sigma^\star$. On considère une trace $(q_0,\ldots,q_n)$
  pour $u$, une décomposition $u = u_0\star\cdots\star u_{n-1}$ et une suite
  $e_0,\ldots, e_{n-1}$ telles que $u_i \in \Val(e_i)$ et
  $R_\delta(q_i,e_i,e_{i+1})$, pour tous $i \in \{0,\ldots,n-1\}$.
  Cette décomposition est aussi valide dans $\mathcal A'$, puisque si
  $a_i \in \Val(e_i)$, $u_i$ appartient à la somme des $e$ pour
  $R_\delta(q_i,e,q_{i+1})$. Réciproquement, appartenir à la somme signifie qu'on
  peut trouver $e$ tel que $R_\delta(q_i,e,q_{i+1})$ telle que
  $a_i \in \Val(e_i)$. On en déduit donc que les traces acceptantes sont
  identiques dans les deux automates, et comme les états initiaux et terminaux
  sont les mêmes, $\mathcal A$ et $\mathcal A'$ sont équivalents.
\end{proof}

\begin{remark}
  On ajoute potentiellement de nombreuses transitions en considérant des
  transitions de la forme $a\xrightarrow \varnothing b$, mais celles-ci ont le
  même rôle que l'absence de transition (puisque $u \in \Val(\varnothing)$ n'est
  pas possible). On peut donc maintenant définir l'unique expression reliant
  deux états, ce qu'on écrire $e(q,q')$. Ainsi accepter un mot $u$ signifie
  obtenir une trace $(q_0,\ldots,q_n)$ où $q_0$ est initial, $q_n$ terminal et
  une décomposition $u = u_1\star \cdots u_{n-1}$ où
  $u_i \in \Val(e(q_i,q_{i+1}))$.
\end{remark}

On introduit maintenant le lemme essentiel menant au théorème souhaité~:
éliminer un état avec la procédure définie plus tôt ne change pas le langage
calculé.

\begin{lemma}\label{lem.elim.state}
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate généralisé contenant
  exactement une transition entre chaque deux états. Soit $q$ un état ni initial
  ni terminal. On définit l'automate $\mathcal A'$ par~:
  \begin{itemize}
  \item $Q_{\mathcal A'} \defeq Q_{\mathcal A} \setminus \{q\}$
  \item $Q_{0,\mathcal A'} \defeq Q_{0,\mathcal A'}$
  \item $e(q_1,q_2) \defeq e(q_1,q) (e(q,q))^\star e(q,q_2) + e(q_1,q_2)$
  \item $F_{\mathcal A'} \defeq F_{\mathcal A}$
  \end{itemize}
  Alors $\mathcal A'$ reconnaît le même langage que $\mathcal A$.
\end{lemma}

\begin{proof}
  Si on trouve une trace $(q_0,\ldots,q_n)$ acceptante pour un mot $u$ dans
  $\mathcal A$, alors en supprimant les occurrences de $q$ dans cette trace
  on obtient une trace acceptante pour $u$ dans $\mathcal A'$, puisque pour
  $q_{i-1},q,q_{i+1}$ et deux facteurs $u_{i-1},u_i$ apparaissant dans la trace
  (respectivement la décomposition de $u$), on peut les remplacer par
  $q_i,q_{i+1}$ et $u_{i-1}\star u_i$, et cela donnera une transition valide pour
  $\mathcal A'$. Entre deux états $q_{i-1},q_i$ où $q$ n'apparaît pas, comme
  on sait que
  $\Val(e_{\mathcal A}(q_{i-1},q_i))\subseteq \Val(e_{\mathcal A'}(q_{i-1},q_i))$
  (car on a une union), on en déduit le résultat pour le reste de la trace.

  Réciproquement, si on a une trace valide pour $\mathcal A'$ alors, entre deux
  états $q_{i},q_{i+1}$, on a soit un mot $u_i$ qui est dans
  $\Val(e_{\mathcal A}(q_i,q_{i+1}))$, soit on peut remplacer ces deux états par
  $(q_i,q,q_{i+1})$ pour faire une trace valide pour $\mathcal A$.
\end{proof}

On peut donc enfin construire une expression régulière à partir d'un automate.

\begin{proposition}
  Soit un langage reconnaissable $\mathcal L$, alors il existe une expression
  régulière $e$ telle que $\Val(e) = \mathcal L$.
\end{proposition}

\begin{proof}
  On sait qu'un langage reconnaissable peut être reconnu par un automate non
  déterministe avec $\varepsilon$-transitions. On pose donc $\mathcal A$ un
  tel automate, reconnaissant $\mathcal L$. On le normalise et lui associe
  naturellement un automate généralisé $\mathcal A'$ qui contient exactement une
  transition entre deux de ses états. En utilisant le \cref{lem.elim.state},
  on sait donc qu'on peut éliminer n'importe quel état qui n'est ni initial ni
  terminal~: on peut donc itérer ce lemme pour obtenir un automate généralisé
  $\mathcal A''$ qui reconnait le même langage $\mathcal L$ que $\mathcal A'$,
  et qui ne contient qu'un état initial et un état terminal (car l'automate
  a été choisi normalisé). Notre automate est donc de la forme~:
  \begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance = 2cm, on grid, auto]
      \node[state,initial] (q_0) {$q_0$};
      \node[state,accepting] (q_1) [right = of q_0] {$q_1$};
      \path[->,>=latex]
      (q_0) edge node {$e$} (q_1);
    \end{tikzpicture}
  \end{figure}
  
  On en déduit donc que pour tout mot $u \in \Sigma^\star$, on a l'équvalence
  suivante~:
  \[u \in \mathcal L \iff u \in \Val(e)\]
  Donc il existe $e$ tel que $\mathcal L = \Val(e)$.
\end{proof}

On en déduit donc le théorème de Kleene~:

\begin{theorem}[Kleene]
  Soit $\Sigma$ un alphabet. Les classes $\Ratio(\Sigma)$ et $\Reco(\Sigma)$
  sont égales.
\end{theorem}

\begin{remark}
  Ces deux équivalences sont algorithmiques~: elles permettent de construire
  effectivement, étant donné un automate, une expression régulière et
  inversement de construire un automate depuis une expression régulière (il faut
  alors utiliser l'automate union, la concaténation et l'étoile d'automates pour
  obtenir l'automate depuis une expression régulière).
\end{remark}

Nous avons vu de nombreuses constructions à propos des automates. Ces
constructions renforce le fait qu'un langage reconnaissable est reconnu par de
nombreux automates. On peut donc se demander s'il existe un automate meilleur
que les autres, ce qui nous mène à la prochaine section~: la construction d'un
automate minimal.

\`A partir de maintenant, on parlera toujours de langage rationnel pour parler
indistinctement de langage reconnaissable ou rationnel, puisque les deux notions
sont équivalentes.

\section{Vers le théorème de Myhill-Nérode}

Le théorème au c\oe ur de cette section possède deux aspects~: le premier est
la notion d'automate minimal, que nous avons évoqué juste avant. Le deuxième
sera notre premier objectif~: donner un critère permettant de prouver qu'un
langage est (ou non) rationnel. Nous allons aborder cet aspect du théorème en
premier lieu.

\subsection{Conditions de rationnalité d'un langage}

Pour arriver à ce résultat, on va présenter un premier lemme important~: le
lemme de l'étoile. Celui-ci nous indique une condition nécessaire à ce qu'un
langage soit rationnel, mais non suffisante.

\begin{lemma}[de l'étoile]
  Soit un langage rationnel $\mathcal L$ sur un alphabet $\Sigma$. Alors il
  existe un entier $N \in \mathbb N$ tel que pour tout mot $u\in\mathcal L$ de
  longueur supérieure à $N$, il existe une décomposition $u = vws$ telle que
  \[\forall n \in \mathbb N, vw^ns \in \mathcal L\]
\end{lemma}

La preuve de ce résultat se base principalement sur l'idée de trouver une boucle
dans la lecture d'un mot~: si un mot est assez long, alors il finira par
repasser par un état, et on pourra alors itérer cette boucle.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
      \node[state,initial] (q_0) {$q_0$};
      \node[state] (q_1) [right = of q_0] {$q_i$};
      \node[state] (q_2) [right = of q_1] {$q_i$};
      \node[state,accepting] (q_3) [right = of q_2] {$q_f$};
      \path[->,>=latex]
      (q_0) edge node {$v$} (q_1)
      (q_1) edge node {$w$} (q_2)
      (q_2) edge node {$s$} (q_3);
  \end{tikzpicture}
\end{figure}

\begin{proof}
  Puisque $\mathcal L$ est un langage rationnel, on pose $\mathcal A$ un
  automate (déterministe, sans $\varepsilon$-transitions) reconnaissant
  $\mathcal L$. On pose $N = |Q| + 1$, prouvons que la propriété souhaitée est
  vraie pour ce choix de $N$~:

  Soit $u\in\mathcal L$ de longueur $n \geq N$. Comme $u \in \mathcal L$, on
  peut trouver une trace acceptante $(q_0,\ldots,q_n)$ pour $u$ dans
  $\mathcal A$. Comme $n \geq N$, on en déduit que $n > |Q|$, donc par le
  principe des tiroirs, on trouve $q$ tel qu'il existe au moins deux occurrences
  de $q$ dans notre trace. On coupe alors notre trace selon deux telles
  occurrences~: $(q_0,\ldots,q_i)$, $(q_i,\ldots,q_j)$ et $(q_j,\ldots,q_n)$
  où $q_i = q_j = q$. De même, on peut découper $u = vws$ de telle sorte que
  $(q_0,\ldots,q_i)$ est une trace pour $v$, $(q_i,\ldots,q_j)$ est une trace
  pour $w$ et $(q_j,\ldots,q_n)$ est une trace pour $s$. On en déduit alors
  qu'en concaténant $p$ fois la suite $(q_i,\ldots,q_j)$ au milieu, on obtient
  une trace acceptante pour $vw^ps$. Ainsi on en déduit
  \[\forall p \in \mathbb N, vw^ps\in \mathcal L\]

  D'où le résultat souhaité pour $N = |Q| + 1$.
\end{proof}

\begin{remark}
  Tout d'abord, il est possible que l'automate ne présente aucune boucle. Dans
  ce cas, le langage est fini puisque le nombre de traces possibles l'est. Notre
  lemme nous donne alors comme $N$ un nombre jamais atteint par un mot~: le
  lemme est alors vrai par vacuité.

  Un autre point à relever concerne le fait que, dans notre décomposition, on a
  aussi le fait que $vs \in \mathcal L$, car supprimer la boucle conserve aussi
  la validité de la trace.

  Enfin, un point plus important~: ce nombre $N$ existe pour un langage
  $\mathcal L$ donné, mais il n'est pas uniforme puisqu'il dépend du choix de
  l'automate. On pourrait considérer le $N$ minimal pour tous les automates
  possibles, mais celui-ci n'a pas de construction explicite \textit{a priori}.
  On va en fait pouvoir montrer que ce $N$ minimal correspond au $N$ associé à
  un automate particulier, et qu'on peut donc choisir un $N$ de façon uniforme
  en fonction de $\mathcal L$.
\end{remark}

\begin{exercise}
  En utilisant le lemme précédent, montrer que le langage suivante n'est pas
  rationnel~:
  \[\mathcal L \defeq \{0^n1^n\mid n \in \mathbb N\}\]
\end{exercise}

On souhaite maintenant affiner le résultat en cherchant une condition non
seulement nécessaire, mais aussi suffisante, permettant donc de caractériser les
langages rationnels.

Pour y arriver, on a besoin d'une premier définition~: celle de quotient gauche.

\begin{definition}[Quotient gauche]
  Soit $\Sigma$ un alphabet et $\mathcal L$ un langage. Pour tout
  $u \in \Sigma^\star$, on définit le quotient gauche (ou résiduel) de
  $\mathcal L$ par $u$ comme~:
  \[u^{-1}\mathcal L\defeq \{v \in \Sigma^\star\mid u\star v \in \mathcal L\}\]
\end{definition}

Le quotient gauche par $u$ peut se voir au niveau des automates~: si on prend
un automate qui reconnaît $\mathcal L$, la lecture de $u$ depuis l'état
initial mène à un état $q$, et l'ensemble $u^{-1}\mathcal L$ est l'ensemble des
mots acceptés si l'on remplace l'état initial par $q$, c'est-à-dire l'ensemble
des mots qui finissent la lecture de $u$ en une lecture acceptante. On remarque
en particulier que $\varepsilon \in u^{-1}\mathcal L$ si et seulement si
$u \in \mathcal L$.

Cela motive notre construction syntaxique~: les différents $u^{-1}\mathcal L$
peuvent naturellement former une structure d'automates, puisque les transitions
peuvent se définir par $\delta(u^{-1}\mathcal L,a) = (u\star a)^{-1}\mathcal L$.
On a aussi défini les états terminants avec la remarque précédente, et l'état
initial est simplement $\mathcal L = \varepsilon^{-1}\mathcal L$. Un tel
automate, qu'on appelle automate syntaxique, respecte notre définition
d'automate lorsque le nombre d'états est fini, ce qui nous donne en fait le
théorème de Myhill-Nérode.

\begin{theorem}[Myhill-Nérode]
  Soit $\Sigma$ un alphabet et $\mathcal L$ un langage sur $\Sigma$. Le langage
  $\mathcal L$ est rationnel si et seulement si l'ensemble
  $\{u^{-1}\mathcal L\mid u \in \Sigma^\star\}$ est fini.
\end{theorem}

\begin{proof}
  Supposons que $\mathcal L$ est rationnel. On trouve un automate $\mathcal A$
  déterministe reconnaissant $\mathcal L$. On construit alors une surjection de
  l'ensemble des états vers l'ensemble des $u^{-1}\mathcal L$ pour
  $u\in \Sigma^\star$. Pour cela, pour chaque état $q \in Q$ on définit
  l'automate $\mathcal A_q$ où l'état initial est remplacé par $q$. On définit
  alors l'ensemble
  \[f(q) \defeq \{u \in \Sigma^\star\mid \mathcal A_q \models u\}\]
  La fonction $f$ est surjective~: pour tout $u$, en prenant
  $q_u \defeq \delta(q_0,u)$, on voit que $f(q_u) = u^{-1}\mathcal L$. Ainsi,
  comme $Q$ est fini, on en déduit que
  $\{u^{-1}\mathcal L\mid u \in \Sigma^\star\}$ est fini aussi.

  Réciproquement, supposons que $\{u^{-1}\mathcal L\mid u \in \Sigma^\star\}$
  est fini. On construit alors l'automate syntaxique $\mathcal A_{\mathcal L}$~:
  \begin{itemize}
  \item $Q \defeq \{u^{-1}\mathcal L\mid u \in \Sigma^\star\}$
  \item $q_0 \defeq \mathcal L$
  \item $\delta(u^{-1}\mathcal L, a) \defeq (u\star a)^{-1}\mathcal L$
  \item $F \defeq \{q \in Q\mid \varepsilon \in q\}$
  \end{itemize}
  On veut vérifier que cet automate reconnaît bien $\mathcal L$. Par une
  induction directe sur $u \in \Sigma^\star$, on prouve que
  \[\forall u \in \Sigma^\star, \delta^\star(q_0,u) = u^{-1}\mathcal L\]
  donc $\mathcal A_\mathcal L \models u$ si et seulement si
  $\varepsilon \in u^{-1}\mathcal L$, ce qui signifie exactement que
  $u \in \mathcal L$ d'après la remarque précédente.
\end{proof}

Il existe donc, pour tout langage rationnel $\mathcal L$, un automate
naturellement associé.

On a ainsi un moyen de montrer à la fois qu'un langage est rationnel, et qu'un
langage n'est pas rationnel~: en exibant une infinité de résiduels, on en
déduit directement qu'un langage n'est pas rationnel, et ce critère est plus
précis que le lemme de l'étoile puisqu'il est exact.

\begin{exercise}
  On considère l'alphabet $\{a,b,c\}$, montrer que le langage
  \[\mathcal L \defeq \{a^nb^mc^p\mid (n,m,p)\in \mathbb N^3\}\]
  vérifie le lemme de l'étoile, mais n'est pas rationnel.
\end{exercise}

\subsection{Automate minimal}

On passe maintenant à l'autre aspect du théorème de Myhill-Nérode~: l'automate
syntaxique qu'on a construit est en fait l'automate minimal, au sens où tout
automate reconnaissant le même langage contiendra plus d'états.

Pour en donner une idée plus claire, on va introduire les notions de morphismes
d'automates et d'automate quotient. Pour simplifier, on ne parlera que
d'automates finis déterministes complets et accessibles.

\begin{definition}[Morphisme d'automate]
  Soit $\Sigma$ et $\mathcal A$, $\mathcal A'$ deux automates finis déterminstes
  sur $\Sigma$. On appelle morphisme d'automate $f : \mathcal A \to \mathcal A'$
  une fonction $f : Q_{\mathcal A} \to Q_{\mathcal A'}$ telle que~:
  \begin{itemize}
  \item $f(q_{0,\mathcal A}) = q_{0,\mathcal A'}$
  \item pour tous $q \in Q_{\mathcal A}, a \in \Sigma$,
    $f(\delta_\mathcal A(q,a)) = \delta_{\mathcal A'}(f(q),a)$
  \item pour tout $q \in F_\mathcal A, f(q) \in F_{\mathcal A'}$
  \end{itemize}
\end{definition}

Un morphisme d'automate est donc une façon de transformer l'automate
$\mathcal A$ en l'automate $\mathcal A'$. Remarquons que généralement, il est
tout à fait possible de n'avoir des morphismes que dans un sens, par exemple
pour
\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance = 2cm, on grid, auto]
      \node[state,initial] (q_0) {$q_0$};
      \node[state,accepting] (q_1) [above right = of q_0] {$q_1$};
      \node[state, accepting] (q_2) [below right = of q_0] {$q_2$};
      \path[->,>=latex]
      (q_0) edge node {$0$} (q_1)
      (q_0) edge node {$1$} (q_2)
      (q_1) edge [loop right] node {$0,1$} ()
      (q_2) edge [loop right] node {$0,1$} ();
      \node (use) [right = of q_0] {};
      \node (use2) [right = of use] {};
      \node[state, initial] (q_3) [right = of use2] {$q'_0$};
      \node[state, accepting] (q_4) [right = of q_3] {$q'_1$};
      \path[->,>=latex]
      (q_3) edge node {$0,1$} (q_4)
      (q_4) edge [loop right] node {$0,1$} ();
  \end{tikzpicture}
\end{figure}
On peut trouver un morphisme de l'automate de gauche vers l'automate de droite,
en prenant $f(q_1) = f(q_2) = q'_1$. Cependant, dans l'autre sens, on ne peut
pas conserver la transition $0,1$ entre $q'_0$ et $q'_1$ en associant une image
à $q'_1$.

Un premier théorème nous dit qu'au niveau des langages reconnus, un morphisme
donne une inclusion.

\begin{proposition}
  Soient $\mathcal A, \mathcal A'$ deux automates sur un alphabet $\Sigma$, et
  $f : \mathcal A \to \mathcal A'$ un morphisme d'automates. Alors
  \[\mathcal L_{\mathcal A} \subseteq \mathcal L_{\mathcal A'}\]
\end{proposition}

\begin{proof}
  On va noter $q,q_0,\ldots$ les états de $\mathcal A$ et $q',q'_0$ les états
  de $\mathcal A'$, de même $F$ et $F'$ pour respectivement l'ensemble des
  états terminaux de $\mathcal A$ et ceux de $\mathcal A'$.
  
  On voit tout d'abord que pour tout mot $u\in\Sigma^\star$, on a
  \[\delta^\star(f(q_0),u) = f(\delta^\star(q_0,u))\]
  et $f(q_0) = q'_0$. De plus, par définition, l'image de $f(F)\subseteq F'$,
  donc $\delta^\star(q_0,u) \in F \implies f(\delta^\star(q_0,u))\in F'$, d'où
  le résultat.
\end{proof}

Un autre résultat, peut-être moins intuitif, est que l'inclusion devient une
égalité dès lors que $f(F) = F'$ (en réutilisant les notations précédentes).

\begin{proposition}
  Si un morphisme d'automates $f : \mathcal A \to \mathcal A'$ est tel que
  $f(F) = F'$, alors $\mathcal L_\mathcal A = \mathcal L_{\mathcal A'}$.
\end{proposition}

\begin{proof}
  On réutilise les notations de la preuve précédente. Par contraposée, supposons
  que $u \notin \mathcal L_\mathcal A$. Cela signifie donc que
  $\delta^\star(q_0,u) \notin F$, donc $f(\delta^\star(q_0,u)) \notin F'$ puisque
  $F' = f(F)$, donc $\delta^\star(q'_0,u)\notin F'$ par l'argument précédent.

  Par contraposée, $\mathcal A'\models u \implies \mathcal A \models u$, d'où
  le résultat.
\end{proof}

On dit qu'un tel morphisme est surjectif (attention, cela ne signifie pas que le
morphisme est surjectif en tant que fonction $Q \to Q'$).

On peut alors prouver que l'automate syntaxique est minimal.

\begin{proposition}
  Soit $\mathcal A$ un automate fini déterministe complet et accessible sur un
  alphabet $\Sigma$. Il existe un morphisme surjectif
  $\mathcal A \to \mathcal A_{\mathcal L_\mathcal A}$ et surjectif sur les états.
\end{proposition}

\begin{proof}
  Comme on sait que $\mathcal A$ est accessible, on peut trouver pour tout état
  $q \in Q$ un mot $u(q)$ tel que $\delta(q_0,u(q)) = q$. On définit alors
  l'image de $q$ comme $(u(q))^{-1}\mathcal L_\mathcal A$. On montre d'abord que
  ce choix d'image ne dépend pas du mot $u(q)$ choisi. En effet, si
  $\delta(q_0,u) = \delta(q_0,v)$ alors pour tout $w \in \Sigma^\star$~:
  \[\mathcal A \models u\star w \iff \mathcal A \models v \star w\]
  donc $u^{-1}\mathcal L_\mathcal A = v^{-1}\mathcal L_\mathcal A$.

  Pour un état terminant dans l'automate syntaxique donné, on trouve un mot
  $u$ tel que cet état vaut $u^{-1}\mathcal L$. On peut alors considérer
  $\delta(q_0,u)$ pour obtenir un état qui est associé à cet état, et puisque
  $\varepsilon \in u^{-1}\mathcal L$, on en déduit que $\delta(q_0,u)\in F$,
  donc notre morphisme est surjectif. Il est même surjectif en tant que fonction
  entre états, puisque l'argument précédent donne pour tout $u^{-1}\mathcal L$
  un antécédent par le morhpisme~: $\delta(q_0,u)$.
\end{proof}

\begin{remark}
  En soi, le point important est la surjectivité sur les états. Cependant, comme
  nous allons le voir, l'existence d'un morphisme nous permet de montrer que
  l'automate minimal peut être obtenu à partir des autres automates, en
  regroupant les états.
\end{remark}

Nous cherchons maintenant à obtenir une construction explicite de l'automate
syntaxique à partir d'un automate donné. Pour cela, nous introduisons d'abord la
notion d'automate quotient. Ces quotients s'appliquent à ce qu'on va appeler des
congruences d'automates, qui sont des relations d'équivalence compatibles avec
la structure d'automate.

\begin{definition}[Congruence d'automate]
  Soit $\Sigma$ un alphabet, et $\mathcal A$ un automate fini déterministe sur
  $\Sigma$. Une relation $\sim \subseteq Q \times Q$ est appelée une congruence
  d'automate si toutes les conditions suivantes sont vérifiées~:
  \begin{itemize}
  \item $\sim$ est une relation d'équivalence.
  \item $\sim$ est compatible avec $\delta$~:
    \[\forall q,q' \in Q, q \sim q' \implies \forall a \in \Sigma,
    \delta(q,a) \sim \delta(q',a)\]
  \item $\sim$ sature $F$~:
    \[\forall q,q' \in Q, q \sim q' \implies (q \in F \iff q' \in F)\]
  \end{itemize}

  On peut alors définir l'automate quotient $\mathcal A/\sim$ par~:
  \begin{itemize}
  \item son ensemble d'états est $Q/\sim$.
  \item son état initial est la classe de $q_0$.
  \item pour tout $q \in Q$ et $a \in \Sigma$,
    $\delta(\overline q,a) =\delta(q,a)$
  \item l'ensemble des états terminaux est $\{\overline q_f \mid q_f \in F\}$.
  \end{itemize}
\end{definition}

\begin{remark}
  La compatibilité est essentielle pour que cette définition ait du sens,
  puisque l'on veut que le choix de $q$ dans une classe ne change pas le
  résultat de $\delta(q,a)$~: c'est le cas ici puisque si $q\sim q'$ alors
  $\delta(q,a) \sim \delta(q',a)$. Pour les états terminaux, dire qu'un ensemble
  d'état est terminal si tous ne sont pas terminaux semble changer le sens de
  l'automate, ce qui motive notre volonté de saturation (remarquons que la
  condition de saturation aurait pu se limiter à une implication, puisque la
  relation est symétrique dans tous les cas).
\end{remark}

On prouve alors que le quotient, comme attendu puisqu'on regroupe des états de
même comportement, ne change pas le langage reconnu.

\begin{proposition}
  Soit un automate $\mathcal A$ et une congruence d'automate sur $\mathcal A$.
  Alors
  \[\mathcal L_\mathcal A = \mathcal L_{\mathcal A/\sim}\]
\end{proposition}

\begin{proof}
  Par une récurrence sur $u$ qui ne pose aucune difficulté, on vérifie que
  \[\forall u \in \Sigma^\star,
  \delta^\star_{\mathcal A/\sim}(\overline{q_0},u)=
  \overline{\delta^\star(q_0,u)}\]
  Si $\delta^\star(q_0,u) \in F$ alors
  $\overline{\delta^\star(q_0,u)} \in F_{\mathcal A/\sim}$.
  Réciproquement, si $\overline{\delta^\star(q_0,u)}$, alors on sait qu'il
  existe $q$ dans cette classe tel que $q \in F$, et comme $\sim$ sature $F$,
  on en déduit que $\delta^\star(q_0,u) \in F$.

  On a donc l'égalité des deux langages.
\end{proof}

On donne un second résultat, relian la congruence et les morphismes.

\begin{proposition}
  Soient $\mathcal A, \mathcal A'$ deux automates sur le même alphabet $\Sigma$
  et $f : \mathcal A \to \mathcal A'$ un morphisme surjectif. Alors $f$ définit
  sur $\mathcal A$ une congruence d'automate par~:
  \[q\sim_f q' \defeq f(q) = f(q')\]
\end{proposition}

\begin{proof}
  On veut montrer que $\sim_f$ définit une congruence. Il est clair que c'est
  une relation d'équivalence, on prouve donc les deux autres points~:
  \begin{itemize}
  \item si $f(q) = f(q')$ et $a \in \Sigma$, alors
    \begin{align*}
      f(\delta(q,a)) &= \delta(f(q),a)\\
      &= \delta(f(q'),a)\\
      &= f(\delta(q',a))
    \end{align*}
    donc $\sim_f$ est compatible avec $\delta$.
  \item si $f(q) = f(q')$ et $q \in F$, alors $f(q) \in f(F)$, donc
    $f(q') \in f(F)$, d'où par surjectivité de $f$ que $q' \in F$.
  \end{itemize}
  Ainsi $\sim_f$ est une congruence.
\end{proof}

Vu la forme de $\sim_f$, il est clair que $\mathcal A/{\sim_f}$ est isomorphe à
$\mathcal A'$ (en prenant pour notion d'isomorphisme l'existence d'un morphisme
réciproque). On en déduit donc qu'on peut construire
$\mathcal A_{\mathcal L_\mathcal A}$ directement depuis $\mathcal A$ par un
quotient~: il se trouve que ce quotient peut être décrit de façon très concrète.

\begin{definition}[Congruence de Nérode]
  Soit $\mathcal A$ un automate sur un alphabet $\Sigma$. On définit la
  congruence de Nérode sur $\mathcal A$ par~:
  \[q \equiv q' \defeq \forall u \in \Sigma^\star,
  \delta^\star(q,u) \in F \iff \delta^\star(q',u) \in F\]
\end{definition}

On voit déjà que si on prend un mot $u$ tel que $\delta(q_0,u) = q$ et $v$ tel
que $\delta(q_0,v) = q'$, alors $q \equiv q'$ revient à dire que
$u^{-1}\mathcal L_\mathcal A = v^{-1}\mathcal L_\mathcal A$, ce qui confirme que
le quotient de $\mathcal A$ par $\equiv$ nous donne l'automate syntaxique. Pour
l'instant, notre construction de l'automate ne peut pas être automatisée~: on a
besoin de tester tous les mots pour déterminer si $q\sim q'$. Pour combler
cette lacune, on définit les approximations de la congruence de Nérode~:

\begin{definition}[Approximation de la congruence de Nérode]
  On définit l'approximation $n$ de la congruence de Nérode, notée $\equiv_n$,
  par
  \[q\equiv_n q' \defeq \forall u \in \Sigma^{<n}, \delta^\star(q,u)\in F \iff
  \delta^\star(q',u) \in F\]
\end{definition}

L'approximation consiste donc en la considération des premiers mots seulement.
On introduit maintenant un lemme essentiel, permettant de calculer effectivement
cette congruence pour tout $n$.

\begin{lemma}\label{lem.nerode.succ}
  Soit un automate $\mathcal A$ sur un alphabet $\Sigma$, deux états $q,q'$ de
  $\mathcal A$ et $n \in \mathbb N$. On a la relation suivante~:
  \[q \equiv_{n+1} q' \iff q\equiv_n q' \land \forall a \in \Sigma,
  \delta^\star(q,a)\equiv_n \delta^\star(q',a)\]
\end{lemma}

\begin{proof}
  Si $q\equiv_{n+1} q'$, alors pour tout $a\in \Sigma$ et $u \in \Sigma^{<n}$,
  on a $\delta(q,u\star a) \in F \iff \delta(q',u\star a) \in F$ par hypothèse.
  Mais alors, cela se réécrit en
  $\delta^\star(\delta(q,a),u)\in F \iff \delta^\star(\delta(q',a),u)\in F$, donc
  on en déduit que $\delta(q,a)\equiv_n \delta(q',a)$. Réciproquement, pour
  $u \in \Sigma^{< n + 1}$, on peut éliminer le cas où $u = \varepsilon$ qui est
  direct et considérer que $u = v\star a$ où $|v| < n$, ce qui nous permet
  d'utiliser l'hypothèse pour déduire que
  $\delta^\star(q,v\star a)\in F \iff \delta^\star(q',v\star a)$, donc que
  $q\equiv_{n+1} q'$.
\end{proof}

Le deuxième lemme essentiel nous dit que l'algorithme effectué en construisant
cette suite de congruence, lorsqu'il atteint un point stationnaire, donne un
résultat.

\begin{lemma}
  Soit un automate $\mathcal A$ sur un alphabet $\Sigma$. Si pour
  $n \in \mathbb N$, les relations $\equiv_n$ et $\equiv_{n+1}$ coïncident,
  alors pour tout $k \in \mathbb N$, $\equiv_{n+k}$ et $\equiv$ coïncident.
\end{lemma}

\begin{proof}
  Supposons que pour tous $q,q'$, on ait
  \[q\equiv_n q' \iff q\equiv_{n+1} q'\]
  alors par induction sur $k$, on prouve que $\equiv_{n+k}$ coïncide avec
  $\equiv_n$~:
  \begin{itemize}
  \item c'est évident pour $k = 0$.
  \item supposons que $\equiv_{n+k}$ et $\equiv_n$ coïncident. Alors, par le
    \cref{lem.nerode.succ}, on voit que $\equiv_{n+k+1}$ et $\equiv_{n+1}$
    coïncident, mais par hypothèse $\equiv_{n+1}$ et $\equiv_n$ coïncident,
    d'où le fait que $\equiv_{n+1}$ et $\equiv_n$ coïncident.
  \end{itemize}

  On veut maintenant prouver que $\equiv_n$ et $\equiv$ coïncident. Soit deux
  états $q,q'$ tels que $q\equiv_n q'$ et un mot $u \in \Sigma^\star$. Si
  $|u| < n$ alors par définition $\delta(q,u) \in F \iff \delta(q',u) \in F$.
  Sinon, alors $q\equiv_{|u|} q'$ puisque $\equiv_n$ coïncide avec $\equiv_k$
  pour tout $k > n$, d'où le résultat. La réciproque est immédiate.
\end{proof}

On a donc un algorithme permettant de calculer l'automate minimal d'un automate
complet~: on construit la congruence de Nérode par approximations successives
grâce au \cref{lem.nerode.succ} jusqu'à obtenir une partition stable des états,
et le quotient est alors directement l'automate minimal.

\subsection{Les langages reconnus par monoïde}

Pour clore ce chapitre, revenons aux considérations algébriques énoncées au
début. Dans celles-ci, on a vu qu'il était possible d'associer un langage à un
monoïde en utilisant la propriété universelle du monoïde libre. Nous allons
maintenant prouver qu'en réalité, les langages associés à des monoïdes finis
sont exactement les langages rationnels.

On commence par prouver un premier sens~: les langages reconnus par monoïdes
sont aussi reconnus par automates.

\begin{proposition}
  Soit $\Sigma$ un alphabet, $M$ un monoïde (de produit $\cdot$ et de neutre
  $e$) et $\mathcal L$ un langage reconnu par une fonction $h : \Sigma \to M$
  et $S\subseteq M$. Alors $\mathcal L \in \Reco(\Sigma)$.
\end{proposition}

\begin{proof}
  On construit l'automate $\mathcal A$ suivant~:
  \begin{itemize}
  \item $Q = M$
  \item $q_0 = e$
  \item $\delta(q,a) = q\cdot f(a)$
  \item $F = S$
  \end{itemize}

  Une récurrence immédiate sur $u$ permet de prouver que
  \[\forall u \in \Sigma^\star, \delta(q_0,u) = \prod_{i = 0}^{|u|-1} u_i\]
  Cette valeur est exactement celle de $\tilde h(u)$, et être reconnu par
  $\mathcal A$ correspond exactement à appartenir à $S$, d'où l'égalité de
  langage.
\end{proof}

Il nous reste donc à construire un monoïde à partir d'un automate. Pour cela,
on va utiliser la construction du monoïde des transitions.

\begin{definition}[Monoïde des transitions]
  Soit $\Sigma$ un alphabet et $\mathcal A$ un automate fini déterministe
  complet reconnaissant un langage $\mathcal L$. On définit le monoïde des
  transitions de $\mathcal A$, qu'on notera $M_\mathcal A$, par~:
  \begin{itemize}
  \item les éléments du monoïde sont les relations binaires
    $R\subseteq Q\times Q$.
  \item la multiplication est la composition de relations~:
    \[R\cdot R' \defeq \{(x,z) \mid \exists y \in Q, xRy\land yRz\}\]
  \item l'élément neutre est la relation
    \[\Delta_Q \defeq \{(q,q)\mid q \in Q\}\]
  \end{itemize}
\end{definition}

\begin{exercise}
  Prouver que $\mathcal M_{\mathcal A}$ est bien un monoïde.
\end{exercise}

Les éléments du monoïde sont les relations binaires. Cependant, les éléments
d'importances sont plus précisément les relations telles que pour tout couple
$(q,q')$, on a un chemin de $q$ vers $q'$ dans $\mathcal A$. On peut donc
simplement prendre la relation $(q,q') \defeq \delta(q,a) = q'$ paramétrée par
$a$ pour obtenir à travers $\delta^\star$ les relations contenant les chemins
entre états paramétrés par un mot $u$ donné. Un mot est acceptant quand l'état
$q_0$ est relié à un état terminal, donc le choix de $S$ est celui des
relations incluant un couple $(q_0,q_f)$ où $q_f \in F$. On en vient donc au
résultat à proprement parler.

\begin{proposition}
  Soit un automate fini déterministe complet $\mathcal A$ reconnaissant un
  langage $\mathcal L$ sur un alphabet $\Sigma$, alors la fonction
  \[\begin{array}{ccccc}
  h & : & \Sigma & \longrightarrow & M_\mathcal A\\
  & & a &\longmapsto & \{(q,q') \mid \delta(q,a) = q'\}
  \end{array}\]
  et la partie
  \[S \defeq \{R \in M_\mathcal A\mid
  R \cap (\{q_0\}\times F)\neq\varnothing\}\]
  reconnaissent le langage $\mathcal L$.
\end{proposition}

\begin{proof}
  Par induction sur la longueur de $u$, on montre que~:
  \[\forall u\in \Sigma^\star, \tilde h(u) =
  \{(q,q') \mid \delta^\star(q,u) = q'\}\]
  \begin{itemize}
  \item on sait que $\tilde h(\varepsilon)$ est l'élément neutre du monoïde,
    et que cet élément est $\{(q,q)\}$, or c'est aussi l'ensemble décrit par
    $\delta^\star(q,\varepsilon) = q'$.
  \item supposons que l'égalité est vraie pour un mot $u$, et soit
    $a \in \Sigma$. Alors
    \begin{align*}
      \tilde h(u\star a) &= h(u) \cdot \{(q,q')\mid \delta(q,a) = q'\}\\
      &= \{(q,q')\mid \delta^\star(q,u) = q'\}\cdot
      \{(q,q')\mid \delta(q,a) = q'\}\\
      &= \{(q,q'')\mid \exists q',
      \delta^\star(q,u) = q' \land \delta(q',a) = q''\}\\
      &= \{(q,q'')\mid \delta(\delta^\star(q,u),a) = q''\}\\
      &= \{(q,q')\mid \delta^\star(q,u\star a) = q'\}
    \end{align*}
  \end{itemize}
  D'où le résultat par induction. On sait donc que $\tilde h(u) \in S$ est
  équivalent à ce qu'il existe un couple
  $(q_0,q_f) \in \{(q,q')\mid \delta^\star(q,u) = q'\}$ où $q_f \in F$, ce
  qui revient à dire que $\delta^\star(q_0,u) \in F$, donc à ce que $\mathcal A$
  accepte $u$. Ainsi $M_\mathcal A$ reconnaît le même langage que
  $\mathcal A$.
\end{proof}
