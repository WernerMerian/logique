\chapter{Arithmétique et incomplétude}
\label{chp.arith}

\minitoc

\lettrine{L}{es} théorèmes d'incomplétude de Gödel sont certainement les
théorèmes les plus célèbres de la logique mathématique. C'est dans ce chapitre
que nous les étudions.

Tout d'abord, il est nécessaire d'étudier le lien entre la syntaxe et la
sémantique des formules arithmétiques, qu'on notera dans ce chapitre simplement
$\Formula$ (et de même, $\Prop$ signifiera directement l'ensemble des
propositions arithmétiques). En effet, il est important de développer avec
précision le lien entre les formules arithmétiques, les théories usuelles et
leurs modèles (en particulier, le modèle standard). L'objectif de cette première
section est d'aboutir à la représentation des fonctions RP par des prédicats
$\HierArithS 1$, et au lien entre l'arithmétique au sens logique et la
hiérarchie arithmétique telle que décrite au chapitre précédent, fondée sur le
calculabilité.

Sur ces bases, nous pouvons prouver le théorème d'indéfinissabilité de la vérité
de Tarski, ainsi que les théorèmes d'incomplétude. Pour pouvoir décrire au mieux
ces théorèmes, on s'attarde sur les conditions exactes permettant de prouver les
théorèmes.

Enfin, nous abordons la notion de traduction entre signatures et théories, pour
permettre de généraliser les théorèmes d'incomplétude au cas d'autres théories
permettant d'encoder l'arithmétique sans être des théories arithmétiques (des
théories construites sur une extension de la signature de l'arithmétique). Cela
permet en particulier de prouver que la théorie $\ZFC$ ne peut pas prouver
$\Coher(\ZFC)$.

\section{\'Etude de l'arithmétique du premier ordre}

Dans le \cref{chp.logpred}, nous avons défini un cadre général pour parler de
théories et de formules. En particulier, nous avons parlé en général de
signatures et de modèles. Dans le chapitre actuel, on se concentre uniquement
sur une signature, et sur ses modèles.

La signature qu'on fixe ici, celle de l'arithmétique, est définie par
\[\mathcal L_{\mathrm{arith}} \defeq \{0^0,S^1,+^2,\times^2,\leq^2\}\]

\subsection{Axiomatiser l'arithmétique}

Historiquement, l'idée d'axiomatiser l'arithmétique est venue d'un besoin de
fonder sur des bases clairement établies le manipulation des entiers (objets
parmi les plus primitifs et essentiels des mathématiques). Ainsi, les axiomes
de l'arithmétique servent en premier lieu à refléter le comportement du modèle
$(\bN,0,n \mapsto n+1, +, \times, \leq)$~: il est donc naturel que cette
structure soit un modèle de toute théorie arithmétique d'intérêt. Nous allons
donc avant tout étudier les théories admettant cette structure comme modèle
(et non forcément considérer les modèles d'une théorie donnée).

\begin{definition}[Modèle standard de l'arithmétique]
  On définit le modèle standard de l'arithmétique comme la structure sur la
  signature de l'arithmétique donnée précédemment~: $\bN$ muni de
  l'interprétation canonique des symboles arithmétiques.
\end{definition}

Pour axiomatiser le comportement de $\bN$, on peut donc donner la théorie
\[\Th(\bN)\defeq \{\varphi \in \Prop \mid \bN \models \varphi\}\]
mais cette théorie est inutilisable~: une théorie utilisable en pratique demande
à ce qu'on puisse écrire effectivement des preuves dans cette théorie. Dans le
cas présent, une preuve que $\Th(\bN)\vdash \varphi$ signifie que pour chaque
règle axiome $\Th(\bN) \vdash \psi$, il est nécessaire de prouver un énoncé de
la forme $\bN \models \psi$ (de plus, comme $\Th(\bN)$ est clos par conséquence
logique, on peut aussi bien prouver tout énoncé uniquement avec la règle
d'axiome). Le premier critère essentiel pour qu'une théorie soit utilisable est
donc sa récursivité.

\begin{definition}[Théorie récursivement axiomatisable]
  Soit $\Sigma$ une signature. Une théorie $\mathcal T \subseteq \Prop(\Sigma)$
  est dite récursivement axiomatisable (r.a.) si elle décrit un langage
  décidable de $\Prop(\Sigma)$ (vu comme un langage algébrique).
\end{definition}

\begin{remark}
  L'adjectif \og récursivement\fg ici fait référence à la théorie de la
  récursion, qui est l'ancien nom de la calculabilité. Les fonctions récursives
  au sens de Herbrand-Gödel étant antérieures à la notion de machine de Turing,
  les premiers termes employés pour désigner les fonctions calculables étaient
  liés à la récursivité. On peut trouver aussi l'expression \og effectivement
  axiomatisable\fg mais, pour ce cas-ci, le terme \og récursivement\fg est
  globalement resté.
\end{remark}

On peut se demander ce qu'il est possible de produire de plus si l'on affaiblit
la condition, et demande uniquement qu'une théorie soit une partie c.e. de
l'ensemble des propositions. Pour écrire une preuve, après tout, nous sommes
généralement d'abord convaincus des axiomes que nous utilisons, et il
peut donc s'avérer suffisant d'utiliser un algorithme qui énumère positivement
les axiomes, sans s'inquiéter des formules qui ne sont pas des axiomes.

En fait, cet affaiblissement n'en est pas un, comme le montre l'astuce de Craig.

\begin{lemma}[Astuce de Craig \cite{Craig1953-CRAOAW}]
  Soit $\mathcal T$ une partie c.e. de l'ensemble des formules, données
  par une énumération $(\varphi_i)_{i \in \bN}$. Alors la famille
  $\displaystyle\left(\bigwedge_{p=0}^{i-1} \varphi_p\right)_{i \in \bN}$
  est une partie décidable de l'ensemble des formules, logiquement équivalente à
  $\mathcal T$.
\end{lemma}

\begin{proof}
  On utilise simplement l'\cref{exo.enum.cr}. En effet, la famille de
  conjonctions est de longueur strictement croissante et la traduction canonique
  entre $\bN$ et $\Sigma^\star$ pour un alphabet $\Sigma$ préserve la longueur~:
  si $u$ est de longueur supérieure à $v$, alors son code $\godcod u$ est
  inférieur au code $\godcod v$.

  Le fait que les deux familles sont logiquement équivalentes est dû au fait
  que la conjonction permet de prouver chaque composante, et que l'ensemble
  des $(\varphi_i)_{i < p}$ permet de prouver la \ordinalnumeralfeminin{$p$}
  conjonction. Ainsi, toute formule de la première famille est prouvée par une
  partie finie de la deuxième famille et réciproquement.
\end{proof}

Ce lemme ne sert pas en pratique~: toutes les théories d'intérêt sont en fait
récursivement axiomatisables de façon évidente.

Cherchons maintenant une théorie décrivant le modèle standard $\bN$. D'après la
forme de la signature, il est nécessaire de décrire le comportement de $0$, de
l'opération successeur $n \mapsto n+1$, de l'addition, de la multiplication et
de la relation d'ordre $\leq$.

En fait, il est aisé de décrire $\leq$ à partir de $+$ en donnant l'équivalence
suivante~:
\[\forall n,m \in \bN, n \leq m \iff \exists k \in \bN, n + k = m\]
comme nous l'avons fait dans le \cref{chp.axiomes}. On pourrait donc simplement
ajouter $\leq$ comme une extension par définition~: on préfère le donner ici
pour des raisons pratiques apparaissant plus tard dans ce chapitre.

Les éléments $0$ et $S$ se définissent ensemble~: ils sont les constructeurs de
l'ensemble inductif $\bN$ et permettent avant tout d'énoncer que tout élément
est de la forme $0$ ou $S\;n$ avec $n$ respectant récursivement cette
spécification. Les points essentiels se résument en $3$ axiomes~:
\begin{axiom}[Non ambigüité des constructeurs]
  Aucun élément n'est à la fois un successeur et $0$~:
  \[\forall n, 0 \neq S\;n\]
\end{axiom}

\begin{axiom}[Injectivité du successeur]
  La fonction $S$ est injective~:
  \[\forall n\;m, S\;n = S\;m \implies n = m\]
\end{axiom}

\begin{axiom}[Filtrage par motif des entiers]
  Tout élément est $0$ ou un successeur~:
  \[\forall n, (n = 0) \lor (\exists m, n = S\;m)\]
\end{axiom}

Avec ces $3$ axiomes, on décrit que $\bN$ ne contient que $0$ et des itérations
de $S$, appliquées un nombre fini de fois jusqu'à atteindre $0$.

On souhaite maintenant axiomatiser les deux opérations $+$ et $\times$. Pour
cela, on a déjà donné des définitions récursives des opérations~: il nous
suffit de les utiliser ici.

\begin{axiom}[Définition de l'addition]
  On a les deux équations suivantes pour l'addition~:
  \[\forall n, n + 0 = n \qquad \forall n\;m, n + (S\;m) = S\;(n+m)\]
\end{axiom}

\begin{axiom}[Définition de la multiplication]
  On a les deux équations suivantes pour la multiplication~:
  \[\forall n, n \times 0 = n \qquad
  \forall n\;m, n \times (S\;m) = (n\times m) + n\]
\end{axiom}

Ces axiomes nous permettent de définir une première théorie, simple, décrivant
une partie de l'arithmétique.

\begin{definition}[Arithmétique de Robinson \cite{robinson1950}]
  On appelle arithmétique de Robinson la théorie formée par les $3$ axiomes
  définissant $0$ et $S$, les $2$ axiomes définissant l'addition et les $2$
  axiomes définissant la multiplication. On note $\ArithRobin$ cette théorie.
\end{definition}

Puisque cette théorie est finie, elle est évidemment r.a. Cette théorie est
très faible~: elle ne peut par exemple pas prouver la commutativité de
l'addition. Cependant, elle peut prouver des schémas de théorèmes évoquant
la commutativité de l'addition. Pour décrire ces schémas, on définit d'abord
l'encodage standard d'un entier.

\begin{definition}[Encodage standard d'un entier]
  Soit $n \in \bN$, on appelle encodage de $n$ le terme arithmétique
  $\encode n \in \Term$ défini par
  \[\encode 0 \defeq 0 \qquad \encode{n+1} \defeq S\;\encode n\]
\end{definition}

On peut maintenant prouver le fait suivant~: toute instance de commutativité
est prouvable.

\begin{proposition}
  Soient $n,m \in \bN$, alors l'énoncé
  $\encode n + \encode m = \encode m + \encode n$ est prouvable dans
  $\ArithRobin$.
\end{proposition}

\begin{proof}
  Pour prouver ce résultat, il nous suffit de montrer le fait suivant, évident~:
  pour tous $n,m \in \bN$, on peut prouver
  $\encode n + \encode m = \encode{n+m}$. On procède pour cela par récurrence
  sur $m$. Dans le cas où $m = 0$, on utilise le premier axiome de la définition
  de l'addition, et dans le cas où $m = S\;p$, on utilise le deuxième axiome
  et l'hypothèse d'induction.

  Ainsi, comme $n + m = m + n$, on peut directement en déduire le résultat.
\end{proof}

On remarque un fait essentiel ici~: la preuve n'utilise aucunement un argument
de récurrence exploitable dans $R$. En réalité, la récurrence effectuée ici est
de l'ordre de la meta-théorie. C'est en effet le fait que $\bN$ possède la
propriété de récurrence qui permet de faire cette preuve.

C'est donc par un point de vue extérieur à la théorie qu'on peut interpréter
l'idée de la commutativité. Cependant, la commutativité n'est pas prouvable dans
$\ArithRobin$. Par théorème de complétude, cela signifie qu'il existe un modèle
de $\ArithRobin$ qui ne vérifie pas la commutativité de $+$.

\begin{exercise}
  Montrer qu'il existe un modèle de $\ArithRobin$ qui dans lequel
  \[\forall n\;m, n + m = m + n\]
  n'est pas vérifié. En déduire que cet énoncé est indépendant de $\ArithRobin$.
\end{exercise}

On se heurte donc à une première limitation~: sans la récurrence au sein même de
la théorie, il n'est pas possible de prouver des énoncés vrais pour tout
élément, même s'il est possible de prouver des énoncés vrais pour tout élément
dit standard, c'est-à-dire (l'interprétation d'un terme) de la forme $\encode n$
pour $n \in \bN$.

Il convient donc d'ajouter le principe de récurrence. Il existe plusieurs
manières de l'énoncer, mais le plus naturel en logique du premier ordre est par
un schéma d'axiomes.

\begin{axiom}[Schéma de récurrence]\label{ax.rec}
  Pour toute formule $\varphi(\vec x, y)\in \Formula$, on définit l'axiome de
  récurrence associé
  \[\forall \vec x, \varphi(\vec x, 0) \implies
  (\forall y, \varphi(\vec x, y) \implies \varphi(\vec x, S\;y)) \implies
  \forall y, \varphi(\vec x, y)\]
\end{axiom}

La théorie de l'arithmétique de Peano (du premier ordre) est alors la théorie
naturelle incluant la récurrence.

\begin{definition}[Arithmétique de Peano \cite{Peano1889}]
  On définit l'arithmétique de Peano $\ArithPeano$ par l'ensemble d'axiomes de
  $\ArithRobin$ et du schéma de récurrence pour toutes les formules $\varphi$.
\end{definition}

Dans cette théorie, il est possible de prouver de nombreuses propriété
arithmétiques usuelles~: l'associativité et la commutativité de $+$ et de
$\times$, par exemple.

L'exercice suivant montre que l'arithmétique de Peano, bien qu'elle contienne
des modèles non standards (le \cref{thm.LS} nous l'assure quoi qu'il arrive),
ses modèles contiennent tous en un sens une copie de $\bN$.

\begin{exercise}
  Soit $\mathcal M \models \ArithPeano$. Montrer que $\bN$ est un sous-modèle
  en interprétant $n \in \bN$ par $\encode n$, et que tous les éléments de
  $\mathcal M \setminus \bN$ sont supérieurs à tous les éléments de $\bN$.

  Montrer que ce sous-modèle n'est pas (toujours) élémentaire.
\end{exercise}

\subsection{Encoder la calculabilité}

Les théories que nous avons vues permettent de prouver de nombreux résultats~:
l'arithmétique de Robinson par le biais de schémas de théorèmes, et
l'arithmétique de Peano grâce à la récurrence. Pourtant, la puissance
d'expressivité de l'arithmétique est déjà très forte avec un fragment de ces
théories.

Pour introduire ces fragments, on commence par définir les formules
$\HierArithS 0$.

\begin{definition}[Formules $\HierArithS 0$]\label{def.Sigma0}
  On définit l'ensemble des formules $\HierArithS 0$ par la grammaire
  suivante~:
  \begin{multline*}
    \varphi \Coloneq t = u \mid t \leq u \mid \top\mid \bot \mid \lnot \varphi
    \mid \varphi \land \psi \mid \varphi \lor \psi \mid \varphi \to \psi\\
    \mid \forall x, (x \leq v) \to \varphi \mid
    \exists x, (x \leq v) \land \varphi
  \end{multline*}
  où $t,u \in \Term$ et $v\in \Term$ est tel que $x \notin \VL(v)$.

  L'ensemble $\HierArithS 0$ est aussi nommé $\HierArithP 0$, de sorte que
  toutes les classes sont les mêmes à l'étage $0$.
\end{definition}

Une formule $\HierArithS 0$ est donc une formule dont toutes les quantifications
sont bornées. 

\begin{notation}
  On écrira naturellement $\forall x \leq t, \varphi$ et
  $\exists x \leq t, \varphi$ pour les deux quantifications bornées
  correspondantes.
\end{notation}

\begin{remark}
  Comme pour la hiérarchie de Lévy, il est important que le terme
  qui borne $x$ ne fasse pas apparaitre $x$, sans quoi il serait possible
  d'écrire par exemple $\forall x \leq x$, qui est une quantification non
  bornée.
\end{remark}

La valeur de vérité de ces formules dans $\bN$ est possible à déduire de façon
algorithmique, puisque toute formule $\HierArithS 0$ quantifie sur un nombre
fini de valeurs, qu'il est donc possible de tester. En fait, on a déjà vu grâce
aux \cref{fct.RP.1}, \ref{prop.PRBool}, \ref{fct.RP2} et \ref{fct.RP3}
le résultat suivant~:

\begin{proposition}
  Soit $\varphi\in \HierArithS 0$, alors l'ensemble $X$ défini par
  \[\vec x \in X \defeq \bN, \vec x \models \varphi\]
  est une relation RP.
\end{proposition}

La réciproque de cette proposition est fausse (nous l'admettons ici). Cependant,
il est possible d'encoder toutes les fonctions RP par des prédicats
$\HierArithS 1$, au sens suivant.

\begin{definition}[Hiérarchie Arithmétique - version 2]\label{def.HA2}
  On définit la hiérarchie arithmétique pour les formules de l'arithmétique
  par~:
  \begin{itemize}
  \item $\HierArithS 0 = \HierArithP 0$ est la classe donnée à
    la \cref{def.Sigma0}.
  \item si $\varphi \in \HierArithS n$, alors
    $\forall \vec x, \varphi \in \HierArithP{n+1}$.
  \item si $\varphi \in \HierArithP n$, alors
    $\exists \vec x, \varphi \in \HierArithS{n+1}$.
  \end{itemize}

  On définit aussi la hiérarchie arithmétique pour les parties de $\bN^k$ (pour
  tout $k \in \bN$) par~:
  \begin{itemize}
  \item $\HierArithS 0 = \HierArithP 0 = \HierArithD 0$ est la classe des
    parties de la forme $\{\vec x \in \bN^k\mid \bN\models\varphi(\vec x)\}$
    où $\varphi$ est une formule $\HierArithS 0$.
  \item $\HierArithS{n+1}$ est défini comme l'ensemble des parties
    $X \subseteq \bN^{k}$ telles qu'il existe une partie
    $Y \subseteq \bN^{k+p}$ qui est dans $\HierArithP n$ et telle que
    \[\forall \vec x \in \bN^k, \vec x \in X \iff
    \exists \vec y, (\vec x,\vec y) \in Y\]
  \item $\HierArithP{n+1}$ est défini comme l'ensemble des parties
    $X \subseteq \bN^k$ telles qu'il existe une partie
    $Y \subseteq \bN^{k+p}$ qui est dans $\HierArithS n$ et telle que
    \[\forall \vec x \in \bN^k, \vec x \in X \iff
    \forall \vec y, (\vec x, \vec y) \in Y\]
  \item $\HierArithD n = \HierArithS n \cap \HierArithP n$
  \end{itemize}
\end{definition}

En comparaison avec la \cref{def.HA1}, on posé un cas $0$ en plus, et on a
remplacé le fait de considérer des prédicats c.e. et co-c.e. par le fait de
considérer des formules.

Plusieurs points sont à relever~:
\begin{itemize}
\item puisqu'on sait que les parties $\HierArithD 0$ sont calculables par des
  fonctions RP, on sait déjà que $\HierArithD 1$ au sens de la \cref{def.HA1}
  contient les parties $\HierArithD 0$. De par la forme des quantifications,
  on en déduit que toute partie $\HierArithS n$ (resp. $\HierArithP n$, resp.
  $\HierArithD n$) au sens de la \cref{def.HA2} l'est aussi au sens de la
  \cref{def.HA1}. La réciproque est vraie (bien sûr, pour $n \geq 1$ puisqu'on
  n'a pas défini le cas $n = 0$ dans la \cref{def.HA1}), ce qui n'a besoin
  d'être prouvé qu'à l'étage $1$ de la hiérarchie, la montée dans la hiérarchie
  suivant la même construction dans les deux cas.
\item les parties de $\bN^k$ qui sont $\HierArithS n$ (resp. $\HierArithP n$)
  correspondent aux interprétations de formules $\HierArithS n$ (resp.
  $\HierArithP n$).
\item il n'y a pas de classe $\HierArithD n$ pour les formules. Cela s'explique
  par le fait qu'une formule ne peut qu'avoir l'un des deux
  quantificateurs $\forall / \exists$ en tête. Dans la hiérarchie de Lévy, la
  classification se faisait entre des classes d'équivalence pour la
  prouvabilité dans $\ZFC$, mais nous souhaitons ici garder un aspect purement
  syntaxique, l'aspect sémantique étant joué par les parties de $\bN^k$.
\item puisque toute formule est équivalente à une formule en forme prénexe
  d'après l'\cref{exo.prenexe}, toute formule arithmétique appartient à l'une
  des classes de la hiérarchie arithmétique.
\end{itemize}

On souhaite donc prouver la conjecture suivante, suffisante pour faire coïncider
les deux versions de la hiérarchie arithmétique~:

\begin{conjecture}
  Pour toute fonction $f : \bN^k \to \bN$ RP, il existe un énoncé
  $\HierArithS 1$ représentant $f$.
\end{conjecture}

Précisons la notion de représentation.

\begin{definition}[Représentation d'une fonction d'entiers]
  Soit $f : \bN^k \to \bN$. On dit que $f$ est représentée par une formule
  $\varphi(\vec x,y) \in \Formula$ à $k+1$ variable libres lorsque
  \[\forall \vec n\in \bN, \forall m \in \bN,
  f(\vec n) = m \iff \bN\models \varphi(\encode{\vec n}, \encode m)\]
\end{definition}

Une autre façon d'énoncer la conjecture est de dire que toute fonction RP est
de graphe $\HierArithS 1$.

La forme de la conjecture nous pousse directement vers une induction sur la
structure de la classe RP. Pour les projections, la fonction successeur et la
fonction nulle, aucun problème n'apparaît. En effet,
elles sont représentées respectivement par
\begin{itemize}
\item la formule $y = x_i$ (dont tout $\vec x$ et $y$ constituent l'ensemble des
  variables libres)~;
\item la formule $y = S\;x$~;
\item la formule $y = 0$.
\end{itemize}

Pour la composition, il suffit simplement d'écrire les choses comme on s'y
attend~:

\begin{proposition}
  Soient $f_1,\ldots,f_p : \bN^k \to \bN$ des fonctions (totales) représentées
  respectivement par $\varphi_1,\ldots,\varphi_p$ et $g : \bN^p \to \bN$ une
  fonction représentée par la formule $\psi$. Alors $g\circ (f_1,\ldots,f_p)$
  est représentée par la formule
  \[\chi(\vec x, y) \defeq \exists \vec z,
  \left(\bigwedge_{i = 1}^p \varphi_i(\vec x, z_i)\right) \land
  (\psi(\vec z, y))\]
\end{proposition}

\begin{proof}
  Il suffit de vérifier l'équivalence pour $\vec n \in \bN^k, m \in \bN$.
  On sait que $\bN\models \chi(\encode{\vec n}, \encode m)$ si et
  seulement si on peut trouver $\vec z \in \bN^p$ tel que
  \begin{itemize}
  \item pour tout $i$, $\bN\models \varphi_i(\encode{\vec n}, \encode{z_i})$,
    ce qui est équivalent à ce que $\encode{z_i} = \encode{f_i(\vec n)}$
  \item $\bN\models\psi(\encode{\vec z}, \encode m)$, ce qui est équivalent à
    ce que $\encode m = \encode{g(\vec z)}$.
  \end{itemize}
  Par définition de la composition, les deux énoncés
  $\bN\models \chi(\encode{\vec n},\encode m)$
  et $m = (g\circ(f_1,\ldots,f_p)) (\vec n)$ sont donc équivalents.
\end{proof}

\begin{remark}
  Cette proposition ne parle \emphexpr{que d'entiers standards}. Il est
  important de garder à l'esprit que $\chi$, par exemple, peut se comporter
  de manière arbitraire dans un modèle donné, sur les entiers non standards.
\end{remark}

Ainsi, si les $f_i$ sont représentées par des formules $\HierArithS 1$ et
$g$ est représentée par une formule $\HierArithS 1$, on peut représentée
$g\circ (f_1,\ldots,f_p)$ par une formule $\HierArithS 1$ (il suffit de mettre
la formule $\chi$ précédente sous forme prénexe pour avoir une suite de
quantifications existentielles non bornées, puis des quantifications bornées).

On peut même représenter la minimisation non bornée.

\begin{proposition}
  Soit $f : \bN^{n+1} \to \bN$ représentée par une formule $\varphi$. Alors la
  fonction $\mu(f) : \bN^n \to \bN$ est représentée par la formule
  \[\psi(\vec x, y) \defeq (\forall a < y, \lnot \varphi(\vec x,a,0))
  \land \varphi(\vec x,y,0)\]
\end{proposition}

\begin{proof}
  Pour $\vec n \in \bN^n$ et $m \in \bN$,
  $\bN \models \psi(\encode{\vec n},\encode m)$ si et seulement si
  \begin{itemize}
  \item pour tout $p < m$, $\lnot \varphi(\encode{\vec n},p,0)$, ce qui est
    équivalent (par représentation de $f$) à ce que $f(\vec n,p) \neq 0$
  \item $\varphi(\encode{\vec n},\encode m,0)$, ce qui est équivalent à ce que
    $f(\vec n,m) = 0$.
  \end{itemize}
  Ainsi, $\psi(\encode{\vec n}, \encode m)$ est vraie si et
  seulement si $m$ est le plus petit point d'annulation de $f(\vec n,-)$, si
  et seulement si $m = \mu(f)(\vec n)$.
\end{proof}

\begin{remark}
  L'expression $\lnot\varphi(\vec x, a, 0)$ n'est pas \latinexpr{a priori} dans
  la classe $\HierArithS 1$, puisque si $\varphi$ a une quantification $\exists$
  non bornée, alors elle est $\HierArithP 1$. On peut cependant remplacer
  $\lnot\varphi(\vec x,a,0)$ par $\exists k, \varphi(\vec x, a, S\;k)$ qui
  représente le même graphe étant donné qu'un élément est non nul si et
  seulement s'il est un successeur.
\end{remark}

Il nous reste à montrer qu'une fonction obtenue par schéma de récursion peut,
elle aussi, se représenter par une formule $\HierArithS 1$.

L'obstacle majeur à cette représentation est qu'un couple d'équations du type
\begin{align*}
  f(\vec n,0) &\defeq g(\vec n) \\
  f(\vec n, S\;m) &\defeq h(\vec n,m,f(\vec n,m))
\end{align*}
doit s'utiliser un nombre arbitrairement de fois pour calculer la valeur de
$f(\vec n,m)$ (par calculer, on entend la production d'une suite d'équations
permettant d'établir $f(\vec n,m) = \encode k$ pour un certain entier $k$).

Il existe une façon simple d'encoder ce calcul~: on peut considérer une liste
des valeurs $f(\vec n,k)$ pour $k < m$. Ainsi, on peut caractériser la fonction
$f$ par l'existence d'une liste dont le premier élément est $g(\vec n)$ et tel
que chaque élément vérifie la relation de récurrence par rapport à l'élément
suivant.

C'est ce que nous allons faire, mais nous ne pouvons pas pour cela utiliser la
fonction d'encodage $\alpha_\star$ de la \cref{def.bij.pairing}, puisqu'elle
se calcule par une fonction RP (il faut donc au préalable montrer que les
fonctions RP peuvent se représenter, ce que l'on cherche déjà à faire). On
introduit donc la fonction $\beta$ de Gödel, permettant d'effectuer un encodage
des listes. Cette fonction demande quelques outils de base d'arithmétique.
Puisque ce cours s'intéresse à la logique avant tout, nous laissons en exercice
la preuve du lemme permettant l'encodage de la fonction. Nous donnons aussi
l'énoncé du théorème des restes chinois, sous une version orientée pour nos
besoins.

\begin{theorem}[Restes chinois]\label{thm.chinois}
  Soient $d_0,\ldots,d_n$ des entiers premiers entre eux deux à deux, et
  $a_0,\ldots,a_n$ des entiers tels que
  \[\forall i \leq n, 0 \leq a_i < d_i\]
  alors il existe un entier $a$ tel que pour tout $i \leq n$, on a
  \[a_i = a \% d_i\]
  (où $\%$ dénote le reste par la division euclidienne).
\end{theorem}

\begin{lemma}\label{lem.beta}
  Pour tout entier $n$, il existe une infinité d'entiers $d$ tels que la
  famille
  \[d_i \defeq 1 + (n+1)d\]
  est constituée d'entiers premiers entre eux deux à deux.
\end{lemma}

\begin{exercise}
  Prouver le \cref{lem.beta}.
\end{exercise}

\begin{definition}[Fonction $\beta$ de Gödel]\label{def.beta}
  La fonction $\beta$ est donnée par
  \[\beta(d,a,i) = a \% (1 + (1 + i) d)\]
\end{definition}

On vérifie que $\beta$ permet bien d'encoder les
suites finies d'entiers.

\begin{proposition}
  Le graphe de $\beta$ est $\HierArithS 0$, et pour toute liste d'entiers
  $\ell \in \List(\bN)$ il existe deux entiers $a,d$ tels que
  \[\forall i < |\ell|, \beta(d,a,i) = \ell_i\]
\end{proposition}

\begin{proof}
  On peut écrire le graphe de $\beta$ par l'énoncé
  \[B(d,a,i,y) \defeq \exists p < a, a = p \times (1 + (1 + i) d) + y\]

  Soit $\ell \in \List(\bN)$. D'après le \cref{lem.beta}, on peut trouver
  une infinité d'entiers $d$ tels que la famille des $d_i$ de taille $|\ell|$
  est constituée d'entiers premiers entre eux deux à deux. Puisqu'il en existe
  une infinite, il en existe au moins un qui est supérieur à la valeur de tous
  les $\ell_i$~: soit $d$ un tel entier. On en déduit donc que
  $\ell_i < 1 + (i+1)d$ pour tout $i$, ce qui nous permet donc d'utiliser
  le \cref{thm.chinois} pour en déduire qu'il existe $a$ tel que
  $\beta(d,a,i) = \ell_i$ pour tout $i$.
\end{proof}

\begin{remark}
  Cette preuve montre aussi qu'il existe une infinité d'encodages d'une liste
  $\ell$ donnée. Heureusement, puisque nous ne souhaitons utiliser cette
  fonction que pour définir une trace du calcul, dans une quantification
  existentielle, la non injectivité du codage n'importe pas.
\end{remark}

On peut désormais encoder une définition récursive primitive par un énoncé
$\HierArithS 1$.

\begin{proposition}
  Soit $f : \bN^p \to \bN$ et $g : \bN^{p+2} \to \bN$ des fonctions représentées
  respectivement par $\varphi$ et $\psi$. Alors la fonction $\rec(f,g)$ est
  représentée par
  \begin{multline*}
    \chi(\vec x,y,z) \defeq \exists a, \exists d,
    (\exists k, B(a,d,0,k) \land \varphi(\vec x, k)) \land B(a,d,y,z) \land \\
    \forall i \leq y, \exists t,t' \leq a, \Big(
    B(a,d,i,t) \land B(a,d,i+1,t') \land
    \psi(\vec x,i,t,t') \Big)
  \end{multline*}
\end{proposition}

\begin{exercise}
  Prouver l'énoncé précédent.
\end{exercise}

On en conclut le théorème suivant.

\begin{theorem}[Représentation des fonctions totales calculables]
  \label{thm.repr.Sigma1}
  Toute fonction totale calculable est représentable par une formule
  arithmétique $\HierArithS 1$. C'est en particulier le cas pour toute fonction
  RP.
\end{theorem}

\begin{proof}
  On a donné dans les propositions précédentes des représentations
  $\HierArithS 1$ des schémas de composition, de récursion, et du schéma $\mu$.
  On en déduit le résultat.
\end{proof}

On en déduit plusieurs faits~:
\begin{itemize}
\item le graphe de toute façon calculable totale est $\HierArithS 1$.
\item les problèmes c.e. sont tous $\HierArithS 1$ (puisqu'ils sont de la
  forme $\exists x, \varphi$ avec $\varphi$ un énoncé $\HierArithS 1$), donc
  les problèmes co-c.e. sont tous $\HierArithP 1$ et les problèmes
  décidables sont $\HierArithD 1$.
\item les deux définitions de la hiérarchie arithmétique (\cref{def.HA1} et
  \cref{def.HA2}) sont équivalentes.
\end{itemize}

Ce théorème de représentation nous donne un fait important dans notre recherche
d'une théorie de l'arithmétique~: les énoncés $\HierArithS 1$ nous permettent
d'encoder les fonctions calculables.

\section{Théories de l'arithmétique}

Nous cherchons maintenant les conséquences du théorème de représentation sur les
théories arithmétiques en général. La première conséquence est, finalement, peu
surprenante~: il est possible d'encoder l'ensemble $\Formula$, ainsi que les
arbres de preuves, de façon calculable. Cela se fait même en pratique avec des
programmes informatiques comme Rocq \cite{Coq-refman} ou Lean \cite{LeanPaper}.
Il est donc possible, d'après le \cref{thm.repr.Sigma1}, d'écrire une formule
qui encode une démonstration. On appelle ce processus l'arithmétisation de la
syntaxe.

\subsection{Arithmétisation de la syntaxe}

Pour étudier ce processus, on donne d'abord l'hypothèse permettant de fonder
l'ensemble des résultats~: la $\Sigma$-complétude.

\begin{definition}[$\Sigma$-complétude]
  Soit $\mathcal T$ une théorie arithmétique. On dit qu'elle est
  $\Sigma$-complète si la condition suivante est vérifiée~:
  \[\forall \varphi(\vec x) \in \HierArithS 0, \forall \vec n \in \bN^k,
  \bN,\vec n\models \varphi (\vec x)\implies
  \mathcal T \vdash \varphi(\encode{\vec n})\]
\end{definition}

\begin{proposition}
  Si $\mathcal T$ est une théorie $\Sigma$-complète, alors pour tout énoncé
  $\varphi(\vec x) \in \HierArithS 1$, on a
  \[\forall \vec n \in \bN^k, \bN,\vec n \models\varphi(\vec x)\implies
  \mathcal T \vdash \varphi(\encode{\vec n})\]
\end{proposition}

\begin{proof}
  On peut écrire $\varphi(\vec x) = \exists y, \psi(\vec x,y)$ où
  $\psi \in \HierArithS 0$. Alors, savoir que
  $\bN,\vec n \models \varphi(\vec x)$ signifie qu'on trouve un entier $m$ tel
  que $\bN, \vec n,m\models \psi(\vec x, y)$, ce qui suffit par
  $\Sigma$-cohérence à prouver que
  $\mathcal T\vdash \psi(\encode{\vec n},\encode m)$, ce qui donne le résultat
  par introduction de l'existentielle.
\end{proof}

\begin{remark}
  Une théorie $\Sigma$-complète prouve donc tout énoncé $\HierArithS 1$ vrai
  dans $\bN$, mais elle peut prouver de nombreux autres résultats qui sont, eux,
  faux dans $\bN$. On voit ici s'appliquer le principe que les énoncés
  existentiels sont stables par sur-modèle, puisque $\bN$ peut toujours être
  encodé dans un sous-modèle d'une théorie arithmétique (simplement par
  l'encodage des entiers standards).
\end{remark}

La conséquence principale de cette proposition est que toute fonction
calculable peut s'écrire dans une théorie $\Sigma$-complète.

On peut désormais procéder à l'arithmétisation de la syntaxe. Ce processus est,
dans la plupart des ouvrages, fastidieux. On peut par exemple mentionner
\cite{cori1993logique} dans lequel sont introduits les codages de Gödel et
les lemmes prouvant différents énoncés techniques montrant la calculabilité de
plusieurs fonctions syntaxiques.

Dans notre cas, la \cref{prop.PU.RPG} encapsule déjà toutes les difficultés de
ces preuves. On peut très facilement se convaincre par exemple que pour une
formule $\varphi$, il est aisé de définir par la \cref{prop.PU.gram} la
fonction retournant $\varphi[t/x]$ (nous avons d'ailleurs déjà donné une
esquisse de démonstration dans le \cref{chp.recur}). On énonce donc simplement
les faits de récursivité importants, dont on laisse le lecteur se convaincre de
la véracité à l'aune des constructions sur les fonctions RPG.

\begin{definition}[Codage de Gödel - version 2]
  Soit $\Sigma$ un alphabet et $\mathcal L$ un langage algébrique sur
  $\Sigma$. On appelle codage de Gödel de ce langage la fonction
  \[\makeFun{\godcod -}{\mathcal L}{\bN}{u}{f_{\Sigma}(u)}\]
  où $f_{\Sigma}$, la fonction de traduction RPG, est celle de la
  \cref{def.trad.RPG}.
\end{definition}

\begin{proposition}\label{prop.subst.repr}
  La fonction suivante est calculable totale~:
  \[\makeFun{\Subst}{\bN^3}{\bN}{(\godcod \varphi, \godcod t,i)}
            {\godcod{\varphi[t/x_i]}}\]
\end{proposition}

On définit de plus le langage des arbres de preuves.

\begin{definition}[Arbres de preuve]
  On définit l'ensemble des arbres de preuve comme le langage obtenu en
  encodant les règles telles que
  \begin{prooftree}
    \AxiomC{$S_1$}
    \AxiomC{$\cdots$}
    \AxiomC{$S_n$}
    \RightLabel{r}
    \TrinaryInfC{$S$}
  \end{prooftree}
  par $\langle r,S_1,\cdots,S_n,S\rangle$ où $ ``\langle "$, $ ``\rangle"$ et
  $ ``,"$ sont de nouveaux symboles.
\end{definition}

Le langage des arbres de preuves n'est pas algébrique à cause des cas tels que
$\varphi[t/x]$ pour la règle $\exists_\mathrm i$. Cependant, puisqu'il est
calculable de décider une telle règle, le langage reste décidable (il est même
RPG), et on peut encore définir le codage de Gödel des arbres, ainsi que des
fonctions par induction sur ces arbres.

\begin{proposition}
  L'ensemble des arbres de preuves est un langage RPG. On possède une fonction
  RPG qui à un arbre $\pi$ associe son séquent $\Gamma\vdash \varphi$
  conclusion. Pour une théorie $\mathcal T$ r.a., le langage des séquents
  conclusion $\Gamma\vdash \varphi$ tels que
  $\Gamma\subseteq \mathcal T$ est aussi RPG.
\end{proposition}

\begin{notation}
  On définit $\Proof{\mathcal T}$ pour l'ensemble calculable des arbres de
  preuve
  de conclusion $\Gamma \vdash \varphi$ où $\Gamma\subseteq \mathcal T$. On
  définit aussi la relation $\pi\vdash \varphi$ comme le fait que $\varphi$ est
  la conclusion de $\pi$. Cette relation est bien sûr calculable.
\end{notation}

Avec cette proposition, on peut donc définir les arbres $\pi$ témoignant du
fait que $\mathcal T \vdash \varphi$, puisque cela correspond exactement à
un arbre de preuve bien formé donc la conclusion est $\Gamma\vdash \varphi$ où
$\Gamma$ n'est constitué que de formules de $\mathcal T$. On en déduit le
lemme central permettant les théorèmes d'incomplétude.

\begin{lemma}
  Soit $\mathcal T$ une théorie r.a. L'ensemble
  \[\Th(\mathcal T) \defeq \{\godcod \varphi\mid
  \varphi \in \Prop,\mathcal T \vdash \varphi\}\]
  est c.e.
\end{lemma}

En fait, l'ensemble $\Th(\mathcal T)$ est un ensemble incalculable. Cela fait
l'objet d'un théorème historiquement important~: le théorème de Church. Il
répond à l'\foreignexpr{Entscheidungsproblem},
un problème posé initialement par Behmann \cite{Mancosu2015HEINRICHB1}
mais repris ensuite par Hilbert \cite{hilbert1928grundzüge}, consistant à
trouver un algorithme (ou une \og méthode finitaire\fg pour reprendre les mots
de l'époque) qui, étant donnée une proposition, décide si cette proposition est
vraie ou fausse.

Le problème était hautement difficile, car il fallait d'abord donner une notion
consensuelle de méthode finitaire et de calcul. C'est en résolvant ce problème
indépendamment que Church et Turing ont énoncé la \cref{thesis.CT}, qui suffit
à répondre négativement au problème.

\'Evidemment, l'énoncé historique de ce théorème est très éloigné de celui que
nous en donnons actuellement. En particulier, nous parlons d'une théorie
arithmétique satisfaisant certaines conditions, mais les théorèmes d'origine
s'appliquaient à des théories telles que
l'\foreignexpr{engere Funktionenkalkül} de Hilbert.

\begin{theorem}[Church \cite{Church1936AnUP}\cite{turing1936a}]
  Soit $\mathcal T$ une théorie arithmétique $\Sigma$-complète. Alors l'ensemble
  $\Th(\mathcal T)$ est non calculable.
\end{theorem}

\begin{proof}
  Par représentation des relations $\HierArithS 1$, on peut représenter
  directement le problème de l'arrêt par un prédicat $K_{\mathrm{arith}}$~:
  \[\forall n \in \bN,
  (\mathcal T \vdash K_{\mathrm{arith}}(\encode{n})) \iff \Enum_n(n)\convcal\]
  mais alors, on en déduit une réduction
  $K \TuringRed\Th(\mathcal T)$, donc $\Th(\mathcal T)$ est
  c.e.-difficile pour la réduction Turing.
\end{proof}

\begin{remark}
  Dans le cas d'une théorie $\Sigma$-complète et r.a. on en déduit donc que
  $\Th(\mathcal T)$ est un ensemble c.e.-complet.
\end{remark}

Par représentation des énoncés $\HierArithS 1$ (qui sont exactement les
ensembles c.e.) on peut donc construire un prédicat permettant de définir la
prouvabilité.

\begin{definition}
  Soit $\mathcal T$ une théorie arithmétique r.a. Par le lemme précédent, on
  pose un énoncé $\HierArithS 1$, noté $\DemT{\mathcal T}$, tel que
  \[\forall n,m \in \bN^2, (\bN,(n,m) \models \DemT{\mathcal T}) \iff
  \exists \pi \in \Proof{\mathcal T}, \exists \varphi \in \Formula,
  n = \godcod \pi \land m = \godcod \varphi \land \pi \vdash \varphi\]

  On définit aussi
  \[\ThT{\mathcal T}(x) \defeq \exists y, \DemT{\mathcal T}(y,x)\]
  qui vérifie
  \[\bN,n\models \ThT{\mathcal T}(x) \iff \exists \varphi \in \Formula,
  n = \godcod \varphi \land
  \mathcal T \vdash \varphi\]
\end{definition}

Avec ce lemme, on sait donc que la prouvabilité d'un énoncé peut s'énoncer au
sein même de la syntaxe de l'arithmétique. Si on considère maintenant une
théorie $\mathcal T$ qui est $\Sigma$-complète, on sait (puisque les énoncés
$\HierArithS 1$ vrais sont prouvables) que si
$\mathcal T \vdash \varphi$, alors
$\mathcal T \vdash \ThT{\mathcal T}(\encode{\godcod \varphi})$. Par
contre, la réciproque n'a pas de raison d'être vraie, puisque l'énoncé n'est
vérifié que pour les entiers standards, et on peut imaginer l'existence
d'entiers non standard témoignant par exemple de
$\ThT{\mathcal T}(\encode{\godcod\varphi})$.

Il manque un élément pour pouvoir arriver aux théorèmes d'incomplétude~: un
théorème de point fixe. Le premier théorème d'incomplétude consiste globalement
à écrire un énoncé de la forme
\begin{quotation}
  cet énoncé est faux.
\end{quotation}

Pour écrire un tel énoncé, il faut avant tout être capable d'écrire un énoncé
pouvant parler de lui-même. Cet aspect récursif fait penser à la définition de
la factorielle développée avec le \cref{thm.Kleene.fix}.

Puisque les formules peuvent parler d'elles-mêmes par un codage de Gödel, et
que les opérations syntaxiques peuvent aussi être traduites, il devient
possible de prouver un théorème de récursion analogue.

\begin{lemma}[Point fixe \cite{Godel1931-GDEBFU}]\label{lem.fix.godel}
  Soit $\mathcal T$ une théorie $\Sigma$-complète. Alors pour toute formule
  $\alpha(x)\in\Formula $ à (au plus) une seule variable libre, il existe une
  proposition $\varphi \in \Prop$ telle que
  \[\mathcal T \vdash \varphi \iff \alpha(\encode{\godcod \varphi})\]
\end{lemma}

\begin{proof}
  D'après la \cref{prop.subst.repr} et le \cref{thm.repr.Sigma1}, on peut
  trouver un prédicat $\Subst(n,m,p,k)$ exprimant sur $\bN^4$ la relation
  \[\Subst(n,m,p,k) \iff \exists \varphi \in \Formula, \exists t \in \Term,
  \begin{cases}
    n = \godcod \varphi \\
    m = \godcod t \\
    k = \godcod {\varphi[t/x_p]}
  \end{cases}\]

  On pose alors les deux formules
  \begin{align*}
    \delta(x_0) &\defeq \exists y,
    (\Subst(x_0,x_0,0,y) \land \alpha(y)) \\
    \varphi &\defeq \delta[\encode{\godcod \delta}/x_0]
  \end{align*}
  On remarque d'abord que $\varphi$ est bien une formule close. On peut
  maintenant vérifier l'équivalence~:
  \begin{align*}
    \mathcal T \vdash& \Subst(\encode{\godcod\delta},\encode{\godcod\delta},
    0,y) \iff y = \encode{\godcod{\delta[\encode{\godcod\delta}/x_0]}} &
    \text{par représentation de }\Subst \\
    \mathcal T \vdash& \Subst(\encode{\godcod\delta},\encode{\godcod\delta},
    0,y) \iff y = \encode{\godcod{\varphi}} &
    \text{par définition de }\varphi \\
    \mathcal T \vdash& \exists y,
    (\Subst(\encode{\godcod\delta},\encode{\godcod\delta}, 0,y) \land \alpha(y))
    \iff \\
    &\exists y, (y = \encode{\godcod{\varphi}} \land \alpha(y))
    & \text{par propriété de l'équivalence}\\
    \mathcal T \vdash& \varphi \iff \alpha(\encode{\godcod \varphi}) &
    \text{en réduisant l'égalité}
  \end{align*}
  D'où le résultat.
\end{proof}

\begin{remark}
  La forme de $\delta$ fait fortement penser à la fonction utilisée pour le
  \cref{thm.Kleene.fix}~: $\Subst$ joue le rôle de l'application de fonction,
  puisqu'en voyant une formule $\varphi(x)$ comme une fonction de $x$, la
  substitution consiste en une application explicite. Une différence notable est
  qu'ici, c'est la substitution qui apparait explicitement, le fait que toute
  formule puisse être traité comme une fonction étant déjà acquis. Au contraire,
  avec l'énumération $\Enum$, on a utilisé le lemme $s_n^m$ pour transformer en
  objet explicite une fonction en $x$, mais l'application était automatique.
\end{remark}

Nous pouvons désormais prouver les théorèmes centraux sur la logique de
l'arithmétique.

\subsection{Premier théorème d'incomplétude}

On combine désormais les deux propriétés~: être r.a. pour pouvoir parler d'une
théorie au sein de la calculabilité, et être $\Sigma$-complet pour pouvoir
exprimer la calculabilité au sein de la théorie. On étudie ainsi des théories
qui peuvent exprimer des propriétés sur elles-mêmes.

La possibilité de parler de soi-même est intuitivement ce qui mène aux
arguments diagonaux, et cette situation nous invite donc à en utilsier un.
En étudiant le procédé diagonal et la façon dont il construit un point fixe, on
en déduit qu'il suffit ici de faire la même chose que pour d'autres arguments
par contradiction~: on prend pour $\alpha$ la négation, ce qui mènerait donc à
quelque chose comme
\[\mathcal T \vdash \varphi \iff \lnot \varphi\]
qui exprimerait l'incohérence de $\mathcal T$. Il y a donc un problème dans
cette définition intuitive (car $\mathcal T$ est simplement une théorie r.a. et
$\Sigma$-complète).

En réalité, notre théorème de point fixe nous dit seulement qu'on peut
construire des points fixes pour des formules de l'arithmétique. Pour pouvoir
faire la démonstration précédente, il nous faudrait donc pouvoir éxprimer par
une formule un énoncé $V$ tel que $V(\encode{\godcod\varphi}) \iff \varphi$.

En allant dans l'autre sens, cela montre qu'on ne peut pas construire de
tel énoncé.

\begin{theorem}[Indéfinissabilité de la vérité]\label{thm.ver.indef}
  Soit $\mathcal T$ une théorie $\Sigma$-complète. S'il existe un prédicat
  arithmétique $V(x)$ tel que
  \[\forall \varphi \in \Prop, \mathcal T \vdash
  V(\encode{\godcod\varphi}) \iff \varphi\]
  alors $\mathcal T$ est incohérente.
\end{theorem}

\begin{proof}
  Si un tel prédicat existe, alors on peut construire par le
  \cref{lem.fix.godel} une formule $\varphi$ telle que
  \[\mathcal T \vdash \varphi \iff \lnot V(\encode{\godcod{\varphi}})\]
  mais alors, puisque
  \[\mathcal T \vdash V(\encode{\godcod\varphi}) \iff \varphi\]
  on en déduit que $\mathcal T \vdash \varphi \iff \lnot \varphi$, donc que
  $\mathcal T \vdash \bot$, c'est-à-dire que $\mathcal T$ est incohérente.
\end{proof}

\begin{exercise}
  En utilisant le \cref{thm.ver.indef}, montrer qu'il n'existe aucun prédicat
  $V(x)$ tel que
  \[\forall \varphi \in \Prop, \bN \models \varphi \iff \bN \models
  V(\encode{\godcod{\varphi}})\]
  Plus généralement, montrer que cela fonctionne pour n'importe quelle théorie
  $\mathcal T$ qui est $\Sigma$-complète et n'importe quel modèle $\mathcal M$
  de $\mathcal T$~: il n'existe pas de formule $V(x)$ à une variable libre telle
  que
  \[\forall \varphi \in \Prop, \mathcal M \models \varphi \iff
  \mathcal M \models V(\encode{\godcod \varphi})\]
\end{exercise}

Le théorème de point fixe ne peut donc pas s'appliquer au cas de la satisfaction
sémantique. Cependant, on a déjà vu un énoncé très proche, mais qui aborde la
satisfaction syntaxique à la place~: $\ThT{\mathcal T}$.

\begin{definition}[Formule $G$ de Gödel]
  Soit $\mathcal T$ une théorie $\Sigma$-complète et r.a. On définit $G$ comme
  la proposition obtenue par le \cref{lem.fix.godel} telle que
  \[\mathcal T \vdash G \iff \lnot \ThT{\mathcal T}(\encode{\godcod{G}})\]
\end{definition}

Cette formule énonce donc qu'elle est elle-même indémontrable. On remarque un
fait important~: l'utilisation de la négation n'est pas anodin du point de vue
de la calculabilité. En effet, dans les constructions de $\DemT{\mathcal T}$,
de $\Subst$, et par conséquent, dans celle du \cref{lem.fix.godel},
nous employons uniquement des énoncés $\HierArithS 1$. Dans le cas de $G$,
au contraire, on obtient un énoncé $\HierArithP 1$ puisqu'on nie un énoncé
$\HierArithS 1$. On peut comprendre la portée universelle de l'énoncé comme le
fait que, pour n'importe quel code d'arbre de preuve $\godcod \pi$, ce code ne
représente pas une preuve de $G$. On peut donc énoncer une première version du
premier théorème d'incomplétude.

\begin{theorem}[Premier théorème d'incomplétude - version faible]
  Soit $\mathcal T$ une théorie cohérente, $\Sigma$-complète et r.a. Alors il
  existe un énoncé $G \in \HierArithP 1$ tel que $G$ est vrai dans $\bN$ et non
  démontrable dans $\mathcal T$.
\end{theorem}

\begin{proof}
  L'énoncé $G$ a déjà été donné. Il nous suffit de montrer que $G$ est non
  prouvable pour en déduire que $\bN \models G$, puisque par définition
  \[\bN \models \ThT{\mathcal T}(\encode{\godcod G}) \iff
  \mathcal T \vdash G\]
  On suppose que $G$ est démontrable~: on trouve donc un arbre de preuve
  $\pi \vdash G$ dont les prémisses sont dans $\mathcal T$. Comme on sait par
  définition que $G$ est démontrable si et seulement
  $\lnot\ThT{\mathcal T}(\encode{\godcod G})$ l'est, on en déduit
  \[\mathcal T \vdash \lnot\ThT{\mathcal T}(\encode{\godcod G})\]
  mais de plus, puisque $\DemT{\mathcal T}$ est un prédicat $\HierArithS 1$ et
  que $\mathcal T$ est $\Sigma$-complète, par le fait que
  $\bN\models \DemT{\mathcal T}(\encode{\godcod{\pi}},\encode{\godcod G})$,
  on en déduit que
  \[\mathcal T \vdash \DemT{\mathcal T}
  (\encode{\godcod{\pi}},\encode{\godcod G})\]
  donc $\mathcal T \vdash \ThT{\mathcal T}(\encode{\godcod G})$, ce qui est
  contradictoire avec la cohérence de $\mathcal T$.
\end{proof}

Cet énoncé suffit par exemple à montrer que tout énoncé arithmétique vrai dans
$\bN$ n'est pas forcément prouvable dans n'importe quelle théorie utilisable et
suffisamment expressive. Cependant, cela ne constitue pas un énoncé
d'incomplétude~: une théorie pourrait être complète en vérifiant
$\mathcal T \vdash \lnot G$.

On va donc ajouter une condition, qui est un renforcement de la condition de
cohérence. La cohérence nous indique qu'il existe des énoncés non démontrables,
mais elle ne place aucune condition sur les énoncés non démontrables en
question. On introduit alors la $\Sigma$-cohérence (ou $1$-cohérence, selon les
auteurs).

\begin{definition}[Théorie $\Sigma$-cohérente]
  Une théorie $\mathcal T$ est dite $\Sigma$-cohérente s'il n'existe aucune
  proposition $\varphi \in \HierArithS 1$ telle que
  \[(\mathcal T \vdash \varphi) \land (\bN \models \lnot\varphi)\]
\end{definition}

L'énoncé devient alors véritablement un énoncé d'incomplétude.

\begin{theorem}[Premier théorème d'incomplétude de Gödel
    \cite{Godel1931-GDEBFU}]\label{thm.godel.incompl1}
  Soit $\mathcal T$ une théorie arithmétique à la fois $\Sigma$-complète,
  $\Sigma$-cohérente et r.a. Il existe un énoncé $G \in \HierArithP 1$ tel que
  $\mathcal T \nvdash G$ et $\mathcal T \nvdash \lnot G$.
\end{theorem}

\begin{proof}
  On reprend donc le raisonnement précédent. On sait que $G$ est non
  démontrable dans $\mathcal T$ et qu'elle est vraie dans $\bN$. Comme $G$ est
  une proposition $\HierArithP 1$, $\lnot G$ est (équivalente à une proposition)
  $\HierArithS 1$ et $\bN \models \lnot\lnot G$ (puisque $\bN\models G$).
  Par $\Sigma$-cohérence, on en déduit que $G$ n'est pas démontrable dans
  $\mathcal T$.
\end{proof}

Ce théorème est largement suffisant pour la pratique. Les théories utiles pour
formaliser les mathématiques, qui sont les théories pour lesquelles on souhaite
appliquer ce théorème, sont généralement au moins $\Sigma$-complètes pour
permettre d'exprimer les fonctions utiles pour un mathématicien, sont
récursivement axiomatisable pour être utilisables, et sont $\Sigma$-cohérentes
puisqu'on souhaite d'abord refléter la vérité dans $\bN$ (inatteignable par une
théorie logique d'après le \cref{thm.ver.indef}). Enfin, le fait de les
utiliser pour faire un travail mathématique repose sur la prémisse que ces
théories d'usage sont cohérentes.

\begin{exercise}[Le cas historique de l'$\omega$-cohérence]
  Dans \cite{Godel1931-GDEBFU}, Gödel n'utilise pas l'hypothse de
  $\Sigma$-cohérence. A la place, il utilise l'hypothèse dite
  d'$\omega$-cohérence. Une théorie $\mathcal T$ est dite $\omega$-cohérente
  quand pour tout énoncé $\varphi(x)$, on ne peut avoir à la fois les deux
  faits suivants~:
  \[\forall n \in \bN, \mathcal T \vdash \varphi(\encode n) \qquad
  \mathcal T \vdash \lnot(\forall x, \varphi(x))\]
  Montrer que toute théorie $\omega$-cohérente est $\Sigma$-cohérente. En
  déduire la version historique du premier théorème d'incomplétude de Gödel.
\end{exercise}

La condition d'$\omega$-cohérence à la place de la $\Sigma$-cohérence est, elle
aussi, largement suffisante dans la pratique. Pour autant, il est possible
d'améliorer le premier théorème d'incomplétude pour supprimer ces conditions
de cohérence renforcées. C'est l'astuce de Rosser (\foreignexpr{Rosser's trick}
en anglais).

\begin{definition}[Formule de Rosser]
  Soit $\mathcal T$ une théorie à la fois $\Sigma$-complète et r.a. On
  pose $\Not$ le prédicat représentant le graphe
  \[\Not(\godcod \varphi, \godcod \psi) \defeq \psi = \lnot \varphi\]
  On définit le prédicat
  \[\DemBisT{\mathcal T}(x,y) \defeq \DemT{\mathcal T}(x,y) \land
  (\exists y', \Not(y,y') \land \forall x' < x,
  \lnot \DemT{\mathcal T}(x',y'))\]

  On définit la formule de Rosser $G'$ par l'application du \cref{lem.fix.godel}
  de sorte qu'on a l'équivalence
  \[\mathcal T \vdash G' \iff \lnot
  \exists x, \DemBisT{\mathcal T}(x, \encode{\godcod{G'}})\]
\end{definition}

L'énoncé $G'$ est donc une variant de l'énoncé $G$, dans lequel on ajoute une
condition de non démonstration. Si on fixe une énumération des preuves dans
$\mathcal T$, l'énoncé $\DemBisT{\mathcal T}(\godcod \pi, \godcod\varphi)$
énonce que $\pi$ est une preuve de $\varphi$, mais aussi qu'aucune autre preuve
de $\lnot \varphi$ n'a été énumérée jusqu'alors.

Avec ce nouveau prédicat, la simple cohérence suffit pour obtenir une
formule indécidable~: le fait que $G'$ implique
$\lnot\ThT{\mathcal T}(\encode{\godcod{G'}})$ permet de montrer que $G'$ n'est
pas prouvable, et la condition sur le fait qu'aucune preuve plus courte
n'existe permet alors d'obtenir directement une contradiction en supposant que
$\lnot G'$ est prouvable, comme nous allons le montrer. Cependant, cette preuve
demande une hypothèse supplémentaire sur $\mathcal T$~: elle suppose que
$\mathcal T$ permet de comparer tout élément à un élément standard.

\begin{theorem}[Théorème d'incomplétude de Gödel-Rosser
    \cite{Godel1931-GDEBFU}\cite{Rosser1936}]
  \label{thm.godel.rosser}
  Soit $\mathcal T$ une théorie cohérente, $\Sigma$-complète et récursivement
  axiomatisable. On suppose de plus que le schéma suivant est prouvable~:
  \[\forall n \in \bN, \mathcal T \vdash \forall x,
  x \leq \encode n \iff \encode n \nless x \]
  Alors il existe un énoncé $G'$ tel que $\mathcal T \nvdash G'$ et
  $\mathcal T \nvdash \lnot G'$.
\end{theorem}

\begin{proof}
  On doit donc prouver deux résultat~:
  \begin{itemize}
  \item supposons qu'il existe une démonstration de $G'$. On trouve donc $\pi$
    tel que
    $\bN\models\DemT{\mathcal T}(\encode{\godcod \pi},\encode{\godcod{G'}})$.
    On applique donc le fait que $\mathcal T$ représente les graphes
    $\HierArithS 1$~:
    \begin{align*}
      \mathcal T \vdash& \DemT{\mathcal T}
      (\encode{\godcod \pi},\encode{\godcod{G'}}) \\
      \forall n \in \bN,\quad\mathcal T
      \vdash& \lnot \DemT{\mathcal T}(\encode n, \encode{\godcod{G'}})
      & \text{par cohérence de }\mathcal T \\
      \mathcal T \vdash & \DemT{\mathcal T} \land \bigwedge_{n < \encode\pi}
      \lnot\DemT{\mathcal T}(\encode n,\encode{\godcod{G'}}) \\
      \mathcal T \vdash & \DemT{\mathcal T} \land
      \forall x < \encode{\godcod{G'}}, \lnot
      \DemT{\mathcal T}(x,\encode{\godcod{G'}}) \\
      \mathcal T \vdash & \exists x,
      \DemBisT{\mathcal T}(x,\encode{\godcod{G'}}) \\
      \mathcal T \vdash & \lnot G' & \text{par définition de }G'
    \end{align*}
    ce qui contredit la cohérence de $\mathcal T$.
  \item supposons qu'il existe une démonstration de $\lnot G'$. On trouve
    donc $\pi$ tel que
    $\bN \models \DemT{\mathcal T}(\encode{\godcod\pi},\encode{\godcod{G'}})$
    d'où~:
    \begin{align*}
      \mathcal T \vdash& \DemT{\mathcal T}(\encode{\godcod\pi},
      \encode{\godcod{G'}}) & \text{par représentation des graphes }
      \HierArithS 1\\
      \mathcal T \vdash& \DemBisT{\mathcal T}(x,\encode{\godcod{G'}})\implies
      (\encode{\godcod{G'}} < x\\ & \implies \lnot\DemT{\mathcal T}
      (\encode{\godcod\pi}, \encode{\godcod{G'}}))
      &\text{où } x \text{ est une nouvelle variable}\\
      \mathcal T \vdash& \DemBisT{\mathcal T}(x,\encode{\godcod{G'}}) \implies
      \encode{\godcod\pi}\nless x \\
      \mathcal T\vdash& \DemBisT{\mathcal T}(x, \encode{\godcod{G'}}) \implies
      x \leq \encode{\godcod\pi} & \text{par hypothèse sur } \mathcal T
    \end{align*}
    De plus, comme $\mathcal T \vdash \lnot G'$, puisque deux
    propriétés équivalentes sont de négations équivalentes et par propriété de
    $G'$, on en déduit
    \[\mathcal T\vdash\exists x,\DemBisT{\mathcal T}(x,\encode{\godcod{G'}})\]
    par cette proposition et la précédente, on a~:
    \begin{align*}
      \mathcal T \vdash & \exists z \leq \encode{\godcod{G'}},
      \DemBisT{\mathcal T}(x, \encode{\godcod{G'}}) \\
      \mathcal T \vdash & \bigvee_{n \leq \godcod\pi}
      \DemT{\mathcal T}(\encode n, \encode{\godcod{G'}})
      & \text{en affaiblissant l'énoncé }\DemBisT{\mathcal T}\\
      \forall n \in \bN, \mathcal T \vdash & \lnot \DemT{\mathcal T}(\encode n,
      \encode{\godcod{G'}}) & \text{par cohérence de }\mathcal T \\
      \mathcal T \vdash & \bigwedge_{n \leq \godcod\pi}\lnot\DemT{\mathcal T}
      (\encode{n},\encode{\godcod{G'}}) \\
      \mathcal T \vdash & \bot 
    \end{align*}
    ce qui contredit la cohérence de $\mathcal T$.
  \end{itemize}
  
  Ainsi ni $\mathcal T \vdash G'$, ni $\mathcal T \vdash \lnot G'$.
\end{proof}

\begin{exercise}
  Montrer que $\ArithRobin$ est $\Sigma$-complète. En déduire que
  $\ArithRobin$ et $\ArithPeano$ sont toutes les deux des théories incomplètes.
\end{exercise}

\subsection{Second théorème d'incomplétude}

Le premier théorème d'incomplétude d'incomplétude nous permet de montrer que
toute théorie suffisante pour des besoins mathématiques concrets, est
automatiquement une théorie incomplète. Pour cela, l'énoncé (qu'il s'agisse de
$G$ ou de $G'$) est purement symbolique et logique~: cet énoncé n'énonce aucun
fait d'intérêt en lui-même. Le second théorème d'incomplétude, lui, permet
de donner un cas essentiel d'énoncé indémontrable.

L'idée du second théorème part d'un postulat simple~: notre démonstration
précédente du \cref{thm.godel.incompl1} pourrait être rendue formelle. C'est le
cas de toutes les démonstration qui se veulent valides mathématiquement, et
celle-ci particulièrement peut se formaliser en donnant des arguments purement
finiraires. Ces arguments finitaires, eux, peuvent s'exprimer directement à
l'aide de récurrences.

Pour exprimer les propriétés de cette internalisation, on introduit les
conditions de Hilbert-Bernays.

\begin{definition}[Conditions de Hilbert-Bernays \cite{Hilbert1974-HILGDM-5}]
  Soit $\mathcal T$ une théorie munie d'une fonction
  $\square : \Prop \to \Prop$. On dit que $(\mathcal T,\square)$ vérifie les
  conditions de Hilbert-Bernays lorsque les trois propriétés suivantes sont
  vérifiées~:
  \begin{equation}\label{eq.HB.1}
    \forall \varphi \in \Prop, \quad
    \big(\mathcal T \vdash \varphi\big) \implies \big(\mathcal T \vdash
    \square\varphi\big)
  \end{equation}
  \begin{equation}\label{eq.HB.2}
    \forall \varphi, \psi \in \Prop, \\
    \mathcal T \vdash \Th(\square(\varphi \implies \psi)) \implies
    \big( \square \varphi\implies \square(\psi)\big)
  \end{equation}
  \begin{equation}\label{eq.HB.3}
    \forall \varphi \in \Prop, \quad
    \mathcal T \vdash \square \varphi \implies \square\square \varphi
  \end{equation}
\end{definition}

La fonction $\square$ représente ici la formule $\ThT{\mathcal T}$, que l'on
note ainsi pour être plus compact (et ne pas réécrire des encodages imbriqués).
En considérant que $\square\varphi$ signifie que $\varphi$ est prouvable dans
$\mathcal T$, les trois conditions signifient respectivement~:
\begin{itemize}
\item si $\mathcal T$ prouve $\varphi$, alors $\square\varphi$ est prouvable
  aussi dans $\mathcal T$. La condition correspond au fait que
  $\ThT{\mathcal T}$ capture tous
  les énoncés démontrables par $\mathcal T$. Remarquons que $\ThT{\mathcal T}$
  peut aussi bien être prouvable pour d'autres énoncés, vis à vis des conditions
  de Hilbert-Bernays.
\item si $\mathcal T$ prouve $\varphi \implies \psi$, alors la prouvabilité de
  $\varphi$ entraine celle de $\psi$ (et ceci est prouvable dans $\mathcal T$).
  Cette condition signifie que le \latinexpr{modus ponens} est un principe
  logique applicable au sein même de $\mathcal T$~: la théorie est suffisamment
  forte pour l'internaliser.
\item au sein même de $\mathcal T$, on peut internaliser une démonstration.
  Cette condition est donc une version interne de la première condition.
\end{itemize}

On montre d'abord que $\ArithPeano$, qui est par excellence la théorie
arithmétique possédant le principe de récurrence, vérifie bien les conditions
pour $\square(\varphi) \defeq \ThT{\ArithPeano}(\encode{\godcod\varphi})$.

\begin{proposition}\label{prop.HB.PA}
  Soit $\mathcal T$ une théorie r.a. dont $\ArithPeano$ est une conséquence.
  Cette théorie satisfait les conditions de Hilbert-Bernays pour
  \[\square \varphi \defeq \Th_{\mathcal T}(\encode{\godcod\varphi})\]
\end{proposition}

\begin{proof}
  Par la définition prise de $\square$, il est automatique que la première
  condition est vérifiée~: $\square$ représente la prouvabilité dans
  $\mathcal T$.

  Pour la deuxième condition, en posant $\Imp$ la
  formule représentant les triplets $(\varphi,\psi,\varphi \implies \psi)$, on
  souhaite prouver
  \[\ArithPeano\vdash \forall x\;y\;z, \Imp(x,y,z) \land
  \ThT{\mathcal T}(z) \land
  \ThT{\mathcal T}(x) \implies \ThT{\mathcal T}(y)\]

  Pour la troisième condition, on peut se ramener à prouver
  \[\ArithPeano\vdash \forall x\;y,
  \Subst(\encode{\godcod{\ThT{\mathcal T} x_0}},0,x,y) \land
  \ThT{\mathcal T}(x) \implies \ThT{\mathcal T}(y)\]
  signifiant que, si $y = \encode{\godcod{\square \varphi}}$ et que
  $\varphi$ est prouvable, alors $y$ aussi.

  Puisque $\mathcal T \vdash \ArithPeano$, on en déduit que $\square$ vérifie
  les conditions de Hilbert-Bernays dans $\mathcal T$.
\end{proof}

Nous ne donnons pas explicitement la preuve des deux énoncés soulevés, car
ces deux énoncés sont très techniques (et peu intéressants) à prouver. Il
suffit simplement de décrire le processus de démonstration initial, à
l'intérieur de la théorie $\ArithPeano$. Cela demande alors de répéter de
nombreuses preuves par récurrence, qui justifient syntaxiquement ce que nous
comprenons déjà intuitivement. De plus, la démonstration de ces deux
formules dépend de l'écriture exacte de $\Th$ et de $\Dem$.

Plutôt que de démontrer directement le second théorème d'incomplétude, on se
propose d'en donner une version plus générale (dont la démonstration est presque
identique).

\begin{theorem}[Löb]\label{thm.Lob}
  Soit $\mathcal T$ une théorie r.a. et $\Sigma$-complète, et soit $\Th(x)$ une
  formule à une variable libre telle que
  $\varphi \mapsto \Th(\encode{\godcod\varphi})$ vérifie les conditions de
  Hilbert-Bernays. Alors pour toute proposition $\varphi$, si
  \[\mathcal T \vdash \Th(\encode{\godcod \varphi}) \implies \varphi\]
  alors $\mathcal T \vdash \varphi$.
\end{theorem}

\begin{proof}
  Soit $\varphi$ une telle proposition.
  Puisque $\mathcal T$ est $\Sigma$-complète, on peut considérer une proposition
  $\psi$ telle que
  \[\mathcal T \vdash \psi \iff (\Th(\encode{\godcod \psi}) \implies \varphi)\]
  par le \cref{lem.fix.godel}. On a alors
  \begin{align*}
    \mathcal T \vdash & \psi \implies (\square \psi \implies \varphi) \\
    \mathcal T \vdash & \square(\psi \implies (\square \psi \implies \varphi))
    & \text{par la condition } \ref{eq.HB.1}
    \\
    \mathcal T \vdash & \square \psi \implies (\square\square \psi \implies
    \square\varphi) & \text{par la condition } \ref{eq.HB.2}\\
  \end{align*}
  On sait alors, par la condition \ref{eq.HB.3}, que
  $\mathcal T \vdash \square \psi \implies \square \square \psi$, ce qui
  nous donne alors
  \begin{align*}
    \mathcal T \vdash & \square \psi \implies \square\varphi \\
    \mathcal T \vdash & \square \psi \implies \varphi
    & \text{par hypothèse} \\
  \end{align*}
  Alors, on en déduit que $\psi$ est démontrable puisqu'elle est équivalente à
  $\square \psi \implies \varphi$, mais par la condition \ref{eq.HB.1}, on
  en déduit aussi que $\mathcal T \vdash \square \psi$. Puisque
  $\psi$ est équivalente à $\square \psi \implies \varphi$, et que
  $\psi$ est prouvable, on en déduit finalement que
  $\mathcal T \vdash \varphi$.
\end{proof}

Avec ce résultat, le second théorème d'incomplétude est obtenu simplement en
considérant $\varphi \defeq \bot$.

\begin{theorem}[Second théorème d'incomplétude de Gödel
  \cite{Godel1931-GDEBFU}]
  Soit $\mathcal T$ une théorie r.a. qui est $\Sigma$-complète et cohérente,
  prouvant la théorie $\ArithPeano$. Alors l'énoncé
  \[\Coher(\mathcal T) \defeq \lnot \ThT{\mathcal T}(\encode{\godcod\bot})\]
  n'est pas démontrable dans $\mathcal T$.
\end{theorem}

\begin{proof}
  On sait par la \cref{prop.HB.PA} que l'énoncé $\ThT{\mathcal T}$ vérifie les
  conditions de Hilbert-Bernays. On applique donc le \cref{thm.Lob} en
  choisissant $\varphi \defeq \bot$ pour en déduire que, si
  \[\mathcal T \vdash \Coher(\mathcal T)\]
  qui est équivalente à $\ThT{\mathcal T}(\encode{\godcod\bot}) \implies \bot$,
  alors $\mathcal T \vdash \bot$. Par contraposée, puisque
  $\mathcal T \nvdash \bot$ (par cohérence), on en déduit que
  $\mathcal T \nvdash \Coher(\mathcal T)$.
\end{proof}

\subsection{Théories non arithmétiques}

Les théorèmes tels qu'énoncés précédemment permettent de déduire que
la théorie $\ArithPeano$ et d'autres théories arithmétiques, sont incomplètes
et ne peuvent pas prouver leur propre cohérence. Pour une théorie non
directement arithmétique, comme $\ZFC$, il est nécessaire d'introduire un moyen
de transformer les énoncés arithmétiques en énoncés de $\ZFC$. Pour cela, on
emploie la notion de traduction.

\begin{definition}[Traduction de théories]
  Soient $\Sigma, \Sigma'$ deux signatures du premier ordre, $\mathcal T$ une
  théorie sur $\Sigma$ et $\mathcal T'$ une théorie sur $\Sigma'$. On appelle
  traduction de $\mathcal T'$ dans $\mathcal T$ une fonction
  \[\makeFunName{T}{\Sigma'}{\Formula(\Sigma)}\]
  et une formule $\Psi$ unaire telles que
  \begin{itemize}
  \item pour tout symbole de relation $r \in \Sigma'$ d'arité $n$,
    $T(r)$ est une formule à (au plus) $n$ variables libres.
  \item pour tout symbole de fonction $f \in \Sigma'$ d'arité $n$,
    $T(f)$ est une formule à (au plus) $n + 1$ variables libres.
  \item pour tout symbole de fonction $f \in \Sigma'$ d'arité $n$,
    \[\mathcal T \vdash \forall \vec x ^{\Psi},\exists ! y^{\Psi},
    T(f)(\vec x, y)\]
    où la relativisation $\forall \vec x^{\Psi}$ est définie en
    \cref{def.relativisation}.
  \item pour tout axiome $\varphi \in \mathcal T'$,
    $\mathcal T \vdash T(\varphi)$ où $T(\varphi)$ est définie inductivement
    depuis $\varphi$ en suivant un procédé analogue à la traduction sans
    symbole de fonction (\cref{def.trad.sans.fun}), où la formule utilisée pour
    traduire $f$ est $T(f)$, où on remplace $R(t_1,\ldots,t_n)$ par
    $T(R)[x_1,\ldots,x_n/t_1,\ldots,t_n]$, et où on relativise toutes les
    quantification par rapport à $\Psi$.
  \end{itemize}
\end{definition}

\begin{exercise}
  Construire une traduction de $\ArithPeano$ vers $\Zermelo$ (définie en
  \cref{subsec.frag.ZFC}).
\end{exercise}

\begin{proposition}
  Soient $\Sigma, \Sigma'$ deux signature, $\mathcal T$ et $\mathcal T'$ des
  théories respectivement sur $\Sigma$ et $\Sigma'$. Soient $(T,\Psi)$
  une traduction de
  $\mathcal T'$ vers $\mathcal T$, $\Gamma \in \List(\Formula(\Sigma'))$ et
  $\varphi \in \List(\Formula(\Sigma'))$, toutes ces formules ayant leurs
  variables libres dans $\vec x$. Alors
  \[\Gamma \vdash \Sigma' \implies R(\Gamma), \overrightarrow{\Psi(x)} \vdash
  R(\varphi)\]
  Ainsi, les théorèmes de $\mathcal T'$ sont tous des théorèmes de
  $\mathcal T$ modulo traduction.
\end{proposition}

\begin{exercise}
  Prouver la proposition précédente.
\end{exercise}

Avec la notion de traduction, il est désormais possible d'étendre les
théorèmes d'incomplétude de Gödel et d'indéfinissabilité de la vérité au cas de
théories plus générales.

\begin{theorem}[Incomplétude]
  Soit $\mathcal T$ une théorie cohérente et r.a. sur une signature $\Sigma$
  telle qu'il existe une traduction de $\ArithPeano$ dans $\mathcal T$, alors
  $\mathcal T$ est incomplète ne peut pas prouver l'énoncé $\Coher(\mathcal T)$.
\end{theorem}

\begin{theorem}[Indéfinissabilité de la vérité]
  Soit $\mathcal T$ une théorie cohérente sur une signature finie $\Sigma$ telle
  qu'il existe une traduction $(T,\Psi)$ de $\ArithRobin$ dans $\mathcal T$,
  alors il n'existe aucune formule $V(x)$ à une variable libre telle que
  \[\forall \varphi \in \Formula(\Sigma),
  \mathcal T\vdash \varphi \iff V(R(\encode{\godcod{\varphi}}))\]
\end{theorem}

On en déduit donc, comme annoncé dans le \cref{chp.modZFC}, qu'il n'est pas
possible de construire dans $\ZFC$ un modèle de $\ZFC$, ou de trouver un énoncé
qui permette d'exprimer la vérité d'un énoncé quelconque donné.

\paragraph{Conclusions méta-mathématiques parcimonieuses}
Il est important de définir clairement ce que permettent de dire mais aussi ce
que ne permettent pas de dire ces théorèmes d'incomplétude. Tout d'abord,
il faut se rappeler qu'en tant que théorèmes, ce sont simplement des relations
démontrées entre objets mathématiques. Les objets mis en jeu ici sont des
théories logiques, et les théorèmes énoncent des limitations sur ces objets.
Ces démonstrations, elles, sont écrites dans la méta-théorie, aussi appelée plus
simplement la théorie ambiante, et si celle-ci a intuitivement le même
comportement que la théorie objet (celle étudiée), il n'est pas pour autant
automatique que les deux idées coïncident.

Cependant, le fait est clair que les preuves effectuées dans la méta-théorie
peuvent se réécrire dans la théorie objet. C'est précisément ce fait (ou sa
potentialité) qui convainc de la validité d'une démonstration, ce qui signifie
qu'une preuve irréfutable de la cohérence de $\ZFC$, par exemple, pourrait
automatiquement s'internaliser au sein de $\ZFC$ (si on décide de travailler
en théorie des ensembles, et qu'on accepte les manipulations ensemblistes
usuelles). On aurait alors bien une preuve que $\ZFC \vdash \Coher(\ZFC)$, puis
par conséquence que $\ZFC \vdash \bot$. Cela signifie donc que ces théorèmes,
en pratique, nous poussent effectivement à ne plus poursuivre de preuve de
la cohérence de $\ZFC$, comme pouvaient le chercher les mathématiciens suivant
le programme de Hilbert.

De plus, dans notre méta-théorie, nous avons bien un objet $\bN$, qui témoigne
que la théorie $\ArithPeano$ est cohérente. Cela peut se justifier par le fait
que $\ZFC \vdash \Coher(\ArithPeano)$. On peut donc trouver de nombreux modèles
de $\ArithPeano$, et certains modèles vérifieront $\lnot\Coher(\ArithPeano)$
d'après le théorème de complétude (sinon, si tous les modèles vérifiaient un
énoncé, celui-ci serait prouvable). Ce fait, contre-intuitif à
première vue, doit cependant être remis dans son contexte~: les énoncés tels que
$\ThT{\ArithPeano}$, représentés en tant que prédicat $\HierArithS 1$, n'ont
un sens bien défini que pour les entiers standards. Un modèle vérifiant
l'incohérence de $\ArithPeano$, lui, trouvera cette preuve d'incohérence dans
des entiers non standards (des éléments du modèle qui ne sont pas de la forme
$\encode n$).

Le même phénomène est présent lorsqu'on étudie $\ZFC$~: l'impossibilité de
construire des modèles de $\ZFC$ ne signifie pas qu'il n'existe aucun ensemble
vérifiant tous les axiomes de notre théorie $\ZFC$ ambiante. Au contraire, on
peut même prouver le contraire, puisqu'il est possible par les
\cref{thm.compacite} et \cref{thm.reflexion} de montrer la cohérence relative
de $\ZFC$ avec l'ajout dans la théorie d'un ensemble (un symbole de constante)
$M$ et de toutes les formules $\varphi^M$ où $\varphi \in \ZFC$. Ainsi, ne pas
pouvoir construire un modèle de $\ZFC$ dans $\ZFC$ signifie que l'ensemble
$\Prop$ construit au sein de la théorie peut contenir strictement plus
d'élément que l'ensemble des propositions telles qu'on l'entend dans la
meta-théorie, exactement comme les entiers des théories arithmétique peuvent
être non standards.
