\chapter{Arithmétique et incomplétude}
\label{chp.arith}

\minitoc

\lettrine{L}{es} théorèmes d'incomplétude de Gödel sont certainement les
théorèmes les plus célèbres de la logique mathématique. C'est dans ce chapitre
que nous les étudions.

Tout d'abord, il est nécessaire d'étudier le lien entre la syntaxe et la
sémantique des formules arithmétiques, qu'on notera dans ce chapitre simplement
$\Formula$ (et de même, $\Prop$ signifiera directement l'ensemble des
propositions arithmétiques). En effet, il est important de développer avec
précision le lien entre les formules arithmétiques, les théories usuelles et
leurs modèles (en particulier, le modèle standard). L'objectif de cette première
section est d'aboutir à la représentation des fonctions RP par des prédicats
$\HierArithS 0$, et au lien entre l'arithmétique au sens logique et la
hiérarchie arithmétique telle que décrite au chapitre précédent, basé sur le
calculabilité.

Sur ces bases, nous pouvons prouver le théorème d'indéfinissabilité de la vérité
de Tarski, ainsi que les théorèmes d'incomplétude. Pour pouvoir décrire au mieux
ces théorèmes, on s'attarde sur les conditions exactes permettant de prouver les
théorèmes.

Enfin, nous abordons la notion de traduction entre signatures et théories, pour
permettre de généraliser les théorèmes d'incomplétude au cas d'autres théories
permettant d'encoder l'arithmétique sans être des théories arithmétiques (des
théories construites sur une extension de la signature de l'arithmétique). Cela
permet en particulier de prouver que la théorie $\ZFC$ ne peut pas prouver
$\Coher(\ZFC)$.

\section{\'Etude de l'arithmétique du premier ordre}

Dans le \cref{chp.logpred}, nous avons défini un cadre général pour parler de
théories et de formules. En particulier, nous avons parlé en général de
signatures et de modèles. Dans le chapitre actuel, on se concentre uniquement
sur une signature, et sur ses modèles.

La signature qu'on fixe ici, celle de l'arithmétique, est définie par
\[\mathcal L_{\mathrm{arith}} \defeq \{0^0,S^1,+^2,\times^2,\leq^2\}\]

\subsection{Axiomatiser l'arithmétique}

Historiquement, l'idée d'axiomatiser l'arithmétique est venue d'un besoin de
fonder sur des bases clairement établies le manipulation des entiers (objets
parmi les plus primitifs et essentiels des mathématiques). Ainsi, les axiomes
de l'arithmétique servent en premier lieu à refléter le comportement du modèle
$(\bN,0,n \mapsto n+1, +, \times, \leq)$~: il est donc naturel que cette
structure soit un modèle de toute théorie arithmétique d'intérêt. Nous allons
donc avant tout étudier les théories admettant cette structure comme modèle
(et non forcément considérer les modèles d'une théorie donnée).

\begin{definition}[Modèle standard de l'arithmétique]
  On définit le modèle standard de l'arithmétique comme la structure sur la
  signature de l'arithmétique donnée précédemment~: $\bN$ muni de
  l'interprétation canonique des symboles arithmétiques.
\end{definition}

Pour axiomatiser le comportement de $\bN$, on peut donc donner la théorie
\[\Th(\bN)\defeq \{\varphi \in \Prop \mid \bN \models \varphi\}\]
mais cette théorie est inutilisable~: une théorie utilisable en pratique demande
à ce qu'on puisse écrire effectivement des preuves dans cette théorie. Dans le
cas présent, une preuve que $\Th(\bN)\vdash \varphi$ signifie que pour chaque
règle axiome $\Th(\bN) \vdash \psi$, il est nécessaire de prouver un énoncé de
la forme $\bN \models \psi$ (de plus, comme $\Th(\bN)$ est clos par conséquence
logique, on peut aussi bien prouver tout énoncé uniquement avec la règle
d'axiome). Le premier critère essentiel pour qu'une théorie soit utilisable est
donc sa récursivité.

\begin{definition}[Théorie récursivement axiomatisable]
  Soit $\Sigma$ une signature. Une théorie $\mathcal T \subseteq \Prop(\Sigma)$
  est dite récursivement axiomatisable (r.a.) si elle décrit un langage
  décidable de $\Prop(\Sigma)$ (vu comme un langage algébrique).
\end{definition}

\begin{remark}
  L'adjectif \og récursivement\fg ici fait référence à la théorie de la
  récursion, qui est l'ancien nom de la calculabilité. Les fonctions récursives
  au sens de Herbrand-Gödel étant antérieures à la notion de machine de Turing,
  les premiers termes employés pour désigner les fonctions calculables étaient
  liés à la récursivité. On peut trouver aussi l'expression \og effectivement
  axiomatisable\fg mais, pour ce cas-ci, le terme \og récursivement\fg est
  globalement resté.
\end{remark}

On peut se demander ce qu'il est possible de produire de plus si l'on affaiblit
la condition, et demande uniquement qu'une théorie soit une partie c.e. de
l'ensemble des propositions. Pour écrire une preuve, après tout, nous sommes
généralement d'abord convaincus des axiomes que nous utilisons, et il
peut donc s'avérer suffisant d'utiliser un algorithme qui énumère positivement
les axiomes, sans s'inquiéter des formules qui ne sont pas des axiomes.

En fait, cet affaiblissement n'en est pas un, comme le montre l'astuce de Craig.

\begin{lemma}[Astuce de Craig \cite{Craig1953-CRAOAW}]
  Soit $\mathcal T$ une partie c.e. de l'ensemble des formules, données
  par une énumération $(\varphi_i)_{i \in \bN}$. Alors la famille
  $\displaystyle\left(\bigwedge_{p=0}^{i-1} \varphi_p\right)_{i \in \bN}$
  est une partie décidable de l'ensemble des formules, logiquement équivalente à
  $\mathcal T$.
\end{lemma}

\begin{proof}
  On utilise simplement l'\cref{exo.enum.cr}. En effet, la famille de
  conjonctions est de longueur strictement croissante et la traduction canonique
  entre $\bN$ et $\Sigma^\star$ pour un alphabet $\Sigma$ préserve la longueur~:
  si $u$ est de longueur supérieure à $v$, alors son code $\godcod u$ est
  inférieur au code $\godcod v$.

  Le fait que les deux familles sont logiquement équivalentes est dû au fait
  que la conjonction permet de prouver chaque composante, et que l'ensemble
  des $(\varphi_i)_{i < p}$ permet de prouver la \ordinalnumeralfeminin{$p$}
  conjonction. Ainsi, toute formule de la première famille est prouvée par une
  partie finie de la deuxième famille et réciproquement.
\end{proof}

Ce lemme ne sert pas en pratique~: toutes les théories d'intérêt sont en fait
récursivement axiomatisables de façon évidente.

Cherchons maintenant une théorie décrivant le modèle standard $\bN$. D'après la
forme de la signature, il est nécessaire de décrire le comportement de $0$, de
l'opération successeur $n \mapsto n+1$, de l'addition, de la multiplication et
de la relation d'ordre $\leq$.

En fait, il est aisé de décrire $\leq$ à partir de $+$ en donnant l'équivalence
suivante~:
\[\forall n,m \in \bN, n \leq m \iff \exists k \in \bN, n + k = m\]
comme nous l'avons fait dans le \cref{chp.axiomes}. On pourrait donc simplement
ajouter $\leq$ comme une extension par définition~: on préfère le donner ici
pour des raisons pratiques apparaissant plus tard dans ce chapitre.

Les éléments $0$ et $S$ se définissent ensemble~: ils sont les constructeurs de
l'ensemble inductif $\bN$ et permettent avant tout d'énoncer que tout élément
est de la forme $0$ ou $S\;n$ avec $n$ respectant récursivement cette
spécification. Les points essentiels se résument en $3$ axiomes~:
\begin{axiom}[Non ambigüité des constructeurs]
  Aucun élément n'est à la fois un successeur et $0$~:
  \[\forall n, 0 \neq S\;n\]
\end{axiom}

\begin{axiom}[Injectivité du successeur]
  La fonction $S$ est injective~:
  \[\forall n\;m, S\;n = S\;m \implies n = m\]
\end{axiom}

\begin{axiom}[Filtrage par motif des entiers]
  Tout élément est $0$ ou un successeur~:
  \[\forall n, (n = 0) \lor (\exists m, n = S\;m)\]
\end{axiom}

Avec ces $3$ axiomes, on décrit que $\bN$ ne contient que $0$ et des itérations
de $S$, appliquées un nombre fini de fois jusqu'à atteindre $0$.

On souhaite maintenant axiomatiser les deux opérations $+$ et $\times$. Pour
cela, on a déjà donné des définitions récursives des opérations~: il nous
suffit de les utiliser ici.

\begin{axiom}[Définition de l'addition]
  On a les deux équations suivantes pour l'addition~:
  \[\forall n, n + 0 = n \qquad \forall n\;m, n + (S\;m) = S\;(n+m)\]
\end{axiom}

\begin{axiom}[Définition de la multiplication]
  On a les deux équations suivantes pour la multiplication~:
  \[\forall n, n \times 0 = n \qquad
  \forall n\;m, n \times (S\;m) = (n\times m) + n\]
\end{axiom}

Ces axiomes nous permettent de définir une première théorie, simple, décrivant
une partie de l'arithmétique.

\begin{definition}[Arithmétique de Robinson]
  On appelle arithmétique de Robinson la théorie formée par les $3$ axiomes
  définissant $0$ et $S$, les $2$ axiomes définissant l'addition et les $2$
  axiomes définissant la multiplication. On note $\ArithRobin$ cette théorie.
\end{definition}

Puisque cette théorie est finie, elle est évidemment r.a. Cette théorie est
très faible~: elle ne peut par exemple pas prouver la commutativité de
l'addition. Cependant, elle peut prouver des schémas de théorèmes évoquant
la commutativité de l'addition. Pour décrire ces schémas, on définit d'abord
l'encodage standard d'un entier.

\begin{definition}[Encodage standard d'un entier]
  Soit $n \in \bN$, on appelle encodage de $n$ le terme arithmétique
  $\encode n \in \Term$ défini par
  \[\encode 0 \defeq 0 \qquad \encode{n+1} \defeq S\;\encode n\]
\end{definition}

On peut maintenant prouver le fait suivant~: toute instance de commutativité
est prouvable.

\begin{proposition}
  Soient $n,m \in \bN$, alors l'énoncé
  $\encode n + \encode m = \encode m + \encode n$ est prouvable dans
  $\ArithRobin$.
\end{proposition}

\begin{proof}
  Pour prouver ce résultat, il nous suffit de montrer le fait suivant, évident~:
  pour tous $n,m \in \bN$, on peut prouver
  $\encode n + \encode m = \encode{n+m}$. On procède pour cela par récurrence
  sur $m$. Dans le cas où $m = 0$, on utilise le premier axiome de la définition
  de l'addition, et dans le cas où $m = S\;p$, on utilise le deuxième axiome
  et l'hypothèse d'induction.

  Ainsi, comme $n + m = m + n$, on peut directement en déduire le résultat.
\end{proof}

On remarque un fait essentiel ici~: la preuve n'utilise aucunement un argument
de récurrence exploitable dans $R$. En réalité, la récurrence effectuée ici est
de l'ordre de la meta-théorie. C'est en effet le fait que $\bN$ possède la
propriété de récurrence qui permet de faire cette preuve.

C'est donc par un point de vue extérieur à la théorie qu'on peut interpréter
l'idée de la commutativité. Cependant, la commutativité n'est pas prouvable dans
$\ArithRobin$. Par théorème de complétude, cela signifie qu'il existe un modèle
de $\ArithRobin$ qui ne vérifie pas la commutativité de $+$.

\begin{exercise}
  Montrer qu'il existe un modèle de $\ArithRobin$ qui dans lequel
  \[\forall n\;m, n + m = m + n\]
  n'est pas vérifié. En déduire que cet énoncé est indépendant de $\ArithRobin$.
\end{exercise}

On se heurte donc à une première limitation~: sans la récurrence au sein même de
la théorie, il n'est pas possible de prouver des énoncés vrais pour tout
élément, même s'il est possible de prouver des énoncés vrais pour tout élément
dit standard, c'est-à-dire (l'interprétation d'un terme) de la forme $\encode n$
pour $n \in \bN$.

Il convient donc d'ajouter le principe de récurrence. Il existe plusieurs
manières de l'énoncer, mais le plus naturel en logique du premier ordre est par
un schéma d'axiomes.

\begin{axiom}[Schéma de récurrence]
  Pour toute formule $\varphi(\vec x, y)\in \Formula$, on définit l'axiome de
  récurrence associé
  \[\forall \vec x, \varphi(\vec x, 0) \implies
  (\forall y, \varphi(\vec x, y) \implies \varphi(\vec x, S\;y)) \implies
  \forall y, \varphi(\vec x, y)\]
\end{axiom}

La théorie de l'arithmétique de Peano (du premier ordre) est alors la théorie
naturelle incluant la récurrence.

\begin{definition}[Arithmétique de Peano]
  On définit l'arithmétique de Peano $\ArithPeano$ par l'ensemble d'axiomes de
  $\ArithRobin$ et du schéma de récurrence pour toutes les formules $\varphi$.
\end{definition}

Dans cette théorie, il est possible de prouver de nombreuses propriété
arithmétiques usuelles~: l'associativité et la commutativité de $+$ et de
$\times$, par exemple.

L'exercice suivant montre que l'arithmétique de Peano, bien qu'elle contienne
des modèles non standards (le \cref{thm.LS} nous l'assure quoi qu'il arrive),
ses modèles contiennent tous en un sens une copie de $\bN$.

\begin{exercise}
  Soit $\mathcal M \models \ArithPeano$. Montrer que $\bN$ est un sous-modèle
  en interprétant $n \in \bN$ par $\encode n$, et que tous les éléments de
  $\mathcal M \setminus \bN$ sont supérieurs à tous les éléments de $\bN$.

  Montrer que ce sous-modèle n'est pas élémentaire.
\end{exercise}

\subsection{Encoder la calculabilité}

Les théories que nous avons vues permettent de prouver de nombreux résultats~:
l'arithmétique de Robinson par le biais de schémas de théorèmes, et
l'arithmétique de Peano grâce à la récurrence. Pourtant, la puissance
d'expressivité de l'arithmétique est déjà très forte avec un fragment de ces
théories.

Pour introduire ces fragments, on commence par définir les formules
$\HierArithS 0$.

\begin{definition}[Formules $\HierArithS 0$]\label{def.Sigma0}
  On définit l'ensemble des formules $\HierArithS 0$ par la grammaire
  suivante~:
  \begin{multline*}
    \varphi \Coloneq t = u \mid t \leq u \mid \top\mid \bot \mid \lnot \varphi
    \mid \varphi \land \psi \mid \varphi \lor \psi \mid \varphi \to \psi\\
    \mid \forall x, (x \leq v) \to \varphi \mid
    \exists x, (x \leq v) \land \varphi
  \end{multline*}
  où $t,u \in \Term$ et $v\in \Term$ est tel que $x \notin \VL(v)$.

  L'ensemble $\HierArithS 0$ est aussi nommé $\HierArithP 0$, de sorte que
  toutes les classes sont les mêmes à l'étage $0$.
\end{definition}

Une formule $\HierArithS 0$ est donc une formule dont toutes les quantifications
sont bornées. 

\begin{notation}
  On écrira naturellement $\forall x \leq t, \varphi$ et
  $\exists x \leq t, \varphi$ pour les deux quantifications bornées
  correspondantes.
\end{notation}

\begin{remark}
  Comme pour la hiérarchie de Lévy, il est important que le terme
  qui borne $x$ ne fasse pas apparaitre $x$, sans quoi il serait possible
  d'écrire par exemple $\forall x \leq x$, qui est une quantification non
  bornée.
\end{remark}

La valeur de vérité de ces formules dans $\bN$ est possible à déduire de façon
algorithmique, puisque toute formule $\HierArithS 0$ quantifie sur un nombre
fini de valeurs, qu'il est donc possible de tester. En fait, on a déjà vu grâce
aux \cref{fct.RP.1}, \ref{prop.PRBool}, \ref{fct.RP2} et \ref{fct.RP3}
le résultat suivant~:

\begin{proposition}
  Soit $\varphi\in \HierArithS 0$, alors l'ensemble $X$ défini par
  \[\vec x \in X \defeq \bN, \vec x \models \varphi\]
  est une relation RP.
\end{proposition}

La réciproque de cette proposition est fausse (nous l'admettons ici). Cependant,
il est possible d'encoder toutes les fonctions RP par des prédicats
$\HierArithS 1$, au sens suivant.

\begin{definition}[Hiérarchie Arithmétique - version 2]\label{def.HA2}
  On définit la hiérarchie arithmétique pour les formules de l'arithmétique
  par~:
  \begin{itemize}
  \item $\HierArithS 0 = \HierArithP 0$ est la classe donnée à
    la \cref{def.Sigma0}.
  \item si $\varphi \in \HierArithS n$, alors
    $\forall \vec x, \varphi \in \HierArithP{n+1}$.
  \item si $\varphi \in \HierArithP n$, alors
    $\exists \vec x, \varphi \in \HierArithS{n+1}$.
  \end{itemize}

  On définit aussi la hiérarchie arithmétique pour les parties de $\bN^k$ (pour
  tout $k \in \bN$) par~:
  \begin{itemize}
  \item $\HierArithS 0 = \HierArithP 0 = \HierArithD 0$ est la classe des
    parties de la forme $\{\vec x \in \bN^k\mid \bN\models\varphi(\vec x)\}$
  \item $\HierArithS{n+1}$ est défini comme l'ensemble des parties
    $X \subseteq \bN^{k}$ telles qu'il existe une partie
    $Y \subseteq \bN^{k+p}$ qui est dans $\HierArithP n$ et telle que
    \[\forall \vec x \in \bN^k, \vec x \in X \iff
    \exists \vec y, (\vec x,\vec y) \in Y\]
  \item $\HierArithP{n+1}$ est défini comme l'ensemble des parties
    $X \subseteq \bN^k$ telles qu'il existe une partie
    $Y \subseteq \bN^{k+p}$ qui est dans $\HierArithS n$ et telle que
    \[\forall \vec x \in \bN^k, \vec x \in X \iff
    \forall \vec y, (\vec x, \vec y) \in Y\]
  \item $\HierArithD n = \HierArithS n \cap \HierArithP n$
  \end{itemize}
\end{definition}

En comparaison avec la \cref{def.HA1}, on posé un cas $0$ en plus, et on a
remplacé le fait de considérer des prédicats c.e. et co-c.e. par le fait de
considérer des formules.

Plusieurs points sont à relever~:
\begin{itemize}
\item puisqu'on sait que les parties $\HierArithD 0$ sont calculables par des
  fonctions RP, on sait déjà que $\HierArithD 1$ au sens de la \cref{def.HA1}
  contient les parties $\HierArithD 0$. De par la forme des quantifications,
  on en déduit que toute partie $\HierArithS n$ (resp. $\HierArithP n$, resp.
  $\HierArithD n$) au sens de la \cref{def.HA2} l'est aussi au sens de la
  \cref{def.HA1}. La réciproque est vraie (bien sûr, pour $n \geq 1$ puisqu'on
  n'a pas défini le cas $n = 0$ dans la \cref{def.HA1}), ce qui n'a besoin
  d'être prouvé qu'à l'étage $1$ de la hiérarchie, la montée dans la hiérarchie
  suivant la même construction dans les deux cas.
\item les parties de $\bN^k$ qui sont $\HierArithS n$ (resp. $\HierArithP n$)
  correspondent aux interprétations de formules $\HierArithS n$ (resp.
  $\HierArithP n$).
\item il n'y a pas de classe $\HierArithD n$ pour les formules. Cela s'explique
  par le fait qu'une formule ne peut qu'avoir l'un des deux
  quantificateurs $\forall / \exists$ en tête. Dans la hiérarchie de Lévy, la
  classification se faisait entre des classes d'équivalence pour la
  prouvabilité dans $\ZFC$, mais nous souhaitons ici garder un aspect purement
  syntaxique, l'aspect sémantique étant joué par les parties de $\bN^k$.
\item puisque toute formule est équivalente à une formule en forme prénexe
  d'après l'\cref{exo.prenexe}, toute formule arithmétique appartient à l'une
  des classes de la hiérarchie arithmétique.
\end{itemize}

On souhaite donc prouver la conjecture suivante, suffisante pour faire coïncider
les deux versions de la hiérarchie arithmétique~:

\begin{conjecture}
  Pour toute fonction $f : \bN^k \to \bN$ RP, il existe un énoncé
  $\HierArithS 1$ représentant $f$.
\end{conjecture}

Précisons la notion de représentation.

\begin{definition}[Représentation d'une fonction d'entiers]
  Soit $f : \bN^k \to \bN$. On dit que $f$ est représentée par une formule
  $\varphi(\vec x,y) \in \Formula$ à $k+1$ variable libres lorsque
  \[\forall \vec n\in \bN, \forall m \in \bN,
  f(\vec n) = m \iff \bN\models \varphi(\encode{\vec n}, \encode m)\]
\end{definition}

Une autre façon d'énoncer la conjecture est de dire que toute fonction RP est
de graphe $\HierArithS 1$.

La forme de la conjecture nous pousse directement vers une induction sur la
structure de la classe RP. Pour les projections, la fonction successeur et la
fonction nulle, aucun problème n'apparaît. En effet,
elles sont représentées respectivement par
\begin{itemize}
\item la formule $y = x_i$ (dont tout $\vec x$ et $y$ constituent l'ensemble des
  variables libres)~;
\item la formule $y = S\;x$~;
\item la formule $y = 0$.
\end{itemize}

Pour la composition, il suffit simplement d'écrire les choses comme on s'y
attend~:

\begin{proposition}
  Soient $f_1,\ldots,f_p : \bN^k \to \bN$ des fonctions (totales) représentées
  respectivement par $\varphi_1,\ldots,\varphi_p$ et $g : \bN^p \to \bN$ une
  fonction représentée par la formule $\psi$. Alors $g\circ (f_1,\ldots,f_p)$
  est représentée par la formule
  \[\chi(\vec x, y) \defeq \exists \vec z,
  \left(\bigwedge_{i = 1}^p \varphi_i(\vec x, z_i)\right) \land
  (\psi(\vec z, y))\]
\end{proposition}

\begin{proof}
  Il suffit de vérifier l'équivalence pour $\vec n \in \bN^k, m \in \bN$.
  On sait que $\bN\models \chi(\encode{\vec n}, \encode m)$ si et
  seulement si on peut trouver $\vec z \in \bN^p$ tel que
  \begin{itemize}
  \item pour tout $i$, $\bN\models \varphi_i(\encode{\vec n}, \encode{z_i})$,
    ce qui est équivalent à ce que $\encode{z_i} = \encode{f_i(\vec n)}$
  \item $\bN\models\psi(\encode{\vec z}, \encode m)$, ce qui est équivalent à
    ce que $\encode m = \encode{g(\vec z)}$.
  \end{itemize}
  Par définition de la composition, les deux énoncés
  $\bN\models \chi(\encode{\vec n},\encode m)$
  et $m = (g\circ(f_1,\ldots,f_p)) (\vec n)$ sont donc équivalents.
\end{proof}

\begin{remark}
  Cette proposition ne parle \emphexpr{que d'entiers standards}. Il est
  important de garder à l'esprit que $\chi$, par exemple, peut se comporter
  de manière arbitraire dans un modèle donné, sur les entiers non standards.
\end{remark}

Ainsi, si les $f_i$ sont représentées par des formules $\HierArithS 1$ et
$g$ est représentée par une formule $\HierArithS 1$, on peut représentée
$g\circ (f_1,\ldots,f_p)$ par une formule $\HierArithS 1$ (il suffit de mettre
la formule $\chi$ précédente sous forme prénexe pour avoir une suite de
quantifications existentielles non bornées, puis des quantifications bornées).

On peut aussi représenter la minimisation non bornée.

\begin{proposition}
  Soit $f : \bN^{n+1} \to \bN$ représentée par une formule $\varphi$. Alors la
  fonction $\mu(f) : \bN^n \to \bN$ est représentée par la formule
  \[\psi(\vec x, y) \defeq (\forall a < y, \lnot \varphi(\vec x,a,0))
  \land \varphi(\vec x,y,0)\]
\end{proposition}

\begin{proof}
  Pour $\vec n \in \bN^n$ et $m \in \bN$,
  $\bN \models \psi(\encode{\vec n},\encode m)$ si et seulement si
  \begin{itemize}
  \item pour tout $p < m$, $\lnot \varphi(\encode{\vec n},p,0)$, ce qui est
    équivalent (par représentation de $f$) à ce que $f(\vec n,p) \neq 0$
  \item $\varphi(\encode{\vec n},\encode m,0)$, ce qui est équivalent à ce que
    $f(\vec n,m) = 0$.
  \end{itemize}
  Ainsi, $\psi(\encode{\vec n}, \encode m)$ est vraie si et
  seulement si $m$ est le plus petit point d'annulation de $f(\vec n,-)$, si
  et seulement si $m = \mu(f)(\vec n)$.
\end{proof}

\begin{remark}
  L'expression $\lnot\varphi(\vec x, a, 0)$ n'est pas \latinexpr{a priori} dans
  la classe $\HierArithS 1$, puisque si $\varphi$ a une quantification $\exists$
  non bornée, alors elle est 
\end{remark}

Il nous reste à montrer qu'une fonction obtenue par schéma de récursion peut,
elle aussi, se représenter par une formule $\HierArithS 1$.

L'obstacle majeur à cette représentation est qu'un couple d'équations du type
\begin{align*}
  f(\vec n,0) &\defeq g(\vec n) \\
  f(\vec n, S\;m) &\defeq h(\vec n,m,f(\vec n,m))
\end{align*}
doit s'utiliser un nombre arbitrairement de fois pour calculer la valeur de
$f(\vec n,m)$ (par calculer, on entend la production d'une suite d'équations
permettant d'établir $f(\vec n,m) = \encode k$ pour un certain entier $k$).

Il existe une façon simple d'encoder ce calcul~: on peut considérer une liste
des valeurs $f(\vec n,k)$ pour $k < m$. Ainsi, on peut caractériser la fonction
$f$ par l'existence d'une liste dont le premier élément est $g(\vec n)$ et tel
que chaque élément vérifie la relation de récurrence par rapport à l'élément
suivant.

C'est ce que nous allons faire, mais nous ne pouvons pas pour cela utiliser la
fonction d'encodage $\alpha_\star$ de la \cref{def.bij.pairing}, puisqu'elle
se calcule par une fonction RP (il faut donc au préalable montrer que les
fonctions RP peuvent se représenter, ce que l'on cherche déjà à faire). On
introduit donc la fonction $\beta$ de Gödel, permettant d'effectuer un encodage
des listes. Cette fonction demande quelques outils de base d'arithmétique.
Puisque ce cours s'intéresse à la logique avant tout, nous laissons en exercice
la preuve du lemme permettant l'encodage de la fonction. Nous donnons aussi
l'énoncé du théorème des restes chinois, sous une version orientée pour nos
besoins.

\begin{theorem}[Restes chinois]\label{thm.chinois}
  Soient $d_0,\ldots,d_n$ des entiers premiers entre eux deux à deux, et
  $a_0,\ldots,a_n$ des entiers tels que
  \[\forall i \leq n, 0 \leq a_i < d_i\]
  alors il existe un entier $a$ tel que pour tout $i \leq n$, on a
  \[a_i = a \% d_i\]
  (où $\%$ dénote le reste par la division euclidienne).
\end{theorem}

\begin{lemma}\label{lem.beta}
  Pour tout entier $n$, il existe une infinité d'entiers $d$ tels que la
  famille
  \[d_i \defeq 1 + (n+1)d\]
  est constituée d'entiers premiers entre eux deux à deux.
\end{lemma}

\begin{exercise}
  Prouver le \cref{lem.beta}.
\end{exercise}

\begin{definition}[Fonction $\beta$ de Gödel]\label{def.beta}
  La fonction $\beta$ est donnée par
  \[\beta(d,a,i) = a \% (1 + (1 + i) d)\]
\end{definition}

On vérifie que $\beta$ permet bien d'encoder les
suites finies d'entiers.

\begin{proposition}
  Le graphe de $\beta$ est $\HierArithS 0$, et pour toute liste d'entiers
  $\ell \in \List(\bN)$ il existe deux entiers $a,d$ tels que
  \[\forall i < |\ell|, \beta(d,a,i) = \ell_i\]
\end{proposition}

\begin{proof}
  On peut écrire le graphe de $\beta$ par l'énoncé
  \[B(d,a,i,y) \defeq \exists p < a, a = p \times (1 + (1 + i) d) + y\]

  Soit $\ell \in \List(\bN)$. D'après le \cref{lem.beta}, on peut trouver
  une infinité d'entiers $d$ tels que la famille des $d_i$ de taille $|\ell|$
  est constituée d'entiers premiers entre eux deux à deux. Puisqu'il en existe
  une infinite, il en existe au moins un qui est supérieur à la valeur de tous
  les $\ell_i$~: soit $d$ un tel entier. On en déduit donc que
  $\ell_i < 1 + (i+1)d$ pour tout $i$, ce qui nous permet donc d'utiliser
  le \cref{thm.chinois} pour en déduire qu'il existe $a$ tel que
  $\beta(d,a,i) = \ell_i$ pour tout $i$.
\end{proof}

\begin{remark}
  Cette preuve montre aussi qu'il existe une infinité d'encodages d'une liste
  $\ell$ donnée. Heureusement, puisque nous ne souhaitons utiliser cette
  fonction que pour définir une trace du calcul, dans une quantification
  existentielle, la non injectivité du codage n'importe pas.
\end{remark}

On peut désormais encoder une définition récursive primitive par un énoncé
$\HierArithS 1$.

\begin{proposition}
  Soit $f : \bN^p \to \bN$ et $g : \bN^{p+2} \to \bN$ des fonctions représentées
  respectivement par $\varphi$ et $\psi$. Alors la fonction $\rec(f,g)$ est
  représentée par
  \begin{multline*}
    \chi(\vec x,y,z) \defeq \exists a, \exists d,
    (\exists k, B(a,d,0,k) \land \varphi(\vec x, k)) \land B(a,d,y,z) \land \\
    \forall i \leq y, \exists t,t' \leq a, \Big(
    B(a,d,i,t) \land B(a,d,i+1,t') \land
    \psi(\vec x,i,t,t') \Big)
  \end{multline*}
\end{proposition}

\begin{exercise}
  Prouver l'énoncé précédent.
\end{exercise}

On en conclut le théorème suivant.

\begin{theorem}[Représentation des fonctions totales calculables]
  \label{thm.repr.Sigma1}
  Toute fonction totale calculable est représentable par une formule
  arithmétique $\HierArithS 1$. C'est en particulier le cas pour toute fonction
  RP.
\end{theorem}

\begin{proof}
  On a donné dans les propositions précédentes des représentations
  $\HierArithS 1$ des schémas de composition, de récursion, et du schéma $\mu$.
  On en déduit le résultat.
\end{proof}

On en déduit plusieurs faits~:
\begin{itemize}
\item le graphe de toute façon calculable totale est $\HierArithS 1$.
\item les problèmes c.e. sont tous $\HierArithS 1$ (puisqu'ils sont de la
  forme $\exists x, \varphi$ avec $\varphi$ un énoncé $\HierArithS 1$), donc
  les problèmes co-c.e. sont tous $\HierArithP 1$ et les problèmes
  décidables sont $\HierArithD 1$.
\item les deux définitions de la hiérarchie arithmétique (\cref{def.HA1} et
  \cref{def.HA2}) sont équivalentes.
\end{itemize}

Ce théorème de représentation nous donne un fait important dans notre recherche
d'une théorie de l'arithmétique~: les énoncés $\HierArithS 1$ nous permettent
d'encoder les fonctions calculables.

\section{Théories de l'arithmétique}

Nous cherchons maintenant les conséquences du théorème de représentation sur les
théories arithmétiques en général. La première conséquence est, finalement, peu
surprenante~: il est possible d'encoder l'ensemble $\Formula$, ainsi que les
arbres de preuves, de façon calculable. Cela se fait même en pratique avec des
programmes informatiques comme Rocq \cite{Coq-refman} ou Lean \cite{LeanPaper}.
Il est donc possible, d'après le \cref{thm.repr.Sigma1}, d'écrire une formule
qui encode une démonstration. On appelle ce processus l'arithmétisation de la
syntaxe.

\subsection{Arithmétisation de la syntaxe}

Pour étudier ce processus, on donne d'abord l'hypothèse permettant de fonder
l'ensemble des résultats~: la $\Sigma$-complétude.

\begin{definition}[$\Sigma$-complétude]
  Soit $\mathcal T$ une théorie arithmétique. On dit qu'elle est
  $\Sigma$-complète si la condition suivante est vérifiée~:
  \[\forall \varphi(\vec x) \in \HierArithS 0, \forall \vec n \in \bN^k,
  \bN,\vec n\models \varphi (\vec x)\implies
  \mathcal T \vdash \varphi(\encode{\vec n})\]
\end{definition}

\begin{proposition}
  Si $\mathcal T$ est une théorie $\Sigma$-complète, alors pour tout énoncé
  $\varphi(\vec x) \in \HierArithS 1$, on a
  \[\forall \vec n \in \bN^k, \bN,\vec n \models\varphi(\vec x)\implies
  \mathcal T \vdash \varphi(\encode{\vec n})\]
\end{proposition}

\begin{proof}
  On peut écrire $\varphi(\vec x) = \exists y, \psi(\vec x,y)$ où
  $\psi \in \HierArithS 0$. Alors, savoir que
  $\bN,\vec n \models \varphi(\vec x)$ signifie qu'on trouve un entier $m$ tel
  que $\bN, \vec n,m\models \psi(\vec x, y)$, ce qui suffit par
  $\Sigma$-cohérence à prouver que
  $\mathcal T\vdash \psi(\encode{\vec n},\encode m)$, ce qui donne le résultat
  par introduction de l'existentielle.
\end{proof}

\begin{remark}
  Une théorie $\Sigma$-complète prouve donc tout énoncé $\HierArithS 1$ vrai
  dans $\bN$, mais elle peut prouver de nombreux autres résultats qui sont, eux,
  faux dans $\bN$. On voit ici s'appliquer le principe que les énoncés
  existentiels sont stables par sur-modèle, puisque $\bN$ peut toujours être
  encodé dans un sous-modèle d'une théorie arithmétique (simplement par
  l'encodage des entiers standards).
\end{remark}

La conséquence principale de cette proposition est que toute fonction
calculable peut s'écrire dans une théorie $\Sigma$-complète.

On peut désormais procéder à l'arithmétisation de la syntaxe. Ce processus est,
dans la plupart des ouvrages, fastidieux. On peut par exemple mentionner
\cite{cori1993logique} dans lequel sont introduits les codages de Gödel et
les lemmes prouvant différents énoncés techniques montrant la calculabilité de
plusieurs fonctions syntaxiques.

Dans notre cas, la \cref{prop.PU.RPG} encapsule déjà toutes les difficultés de
ces preuves. On peut très facilement se convaincre par exemple que pour une
formule $\varphi$, il est aisé de définir par la \cref{prop.PU.gram} la
fonction retournant $\varphi[t/x]$ (nous avons d'ailleurs déjà donné une
esquisse de démonstration dans le \cref{chp.recur}). On énonce donc simplement
les faits de récursivité importants, dont on laisse le lecteur se convaincre de
la véracité à l'aune des constructions sur les fonctions RPG.

\begin{definition}[Codage de Gödel - version 2]
  Soit $\Sigma$ un alphabet et $\mathcal L$ un langage algébrique sur
  $\Sigma$. On appelle codage de Gödel de ce langage la fonction
  \[\makeFun{\godcod -}{\mathcal L}{\bN}{u}{f_{\Sigma}(u)}\]
  où $f_{\Sigma}$, la fonction de traduction RPG, est celle de la
  \cref{def.trad.RPG}.
\end{definition}

\begin{proposition}\label{prop.subst.repr}
  La fonction suivante est calculable totale~:
  \[\makeFun{\Subst}{\bN^3}{\bN}{(\godcod \varphi, \godcod t,i)}
            {\godcod{\varphi[t/x_i]}}\]
\end{proposition}

On définit de plus le langage des arbres de preuves.

\begin{definition}[Arbres de preuve]
  On définit l'ensemble des arbres de preuve comme le langage obtenu en
  encodant les règles telles que
  \begin{prooftree}
    \AxiomC{$S_1$}
    \AxiomC{$\cdots$}
    \AxiomC{$S_n$}
    \RightLabel{r}
    \TrinaryInfC{$S$}
  \end{prooftree}
  par $\langle r,S_1,\cdots,S_n,S\rangle$ où $ ``\langle "$, $ ``\rangle"$ et
  $ ``,"$ sont de nouveaux symboles.
\end{definition}

Le langage des arbres de preuves n'est pas algébrique à cause des cas tels que
$\varphi[t/x]$ pour la règle $\exists_\mathrm i$. Cependant, puisqu'il est
calculable de décider une telle règle, le langage reste décidable (il est même
RPG), et on peut encore définir le codage de Gödel des arbres, ainsi que des
fonctions par induction sur ces arbres.

\begin{proposition}
  L'ensemble des arbres de preuves est un langage RPG. On possède une fonction
  RPG qui à un arbre $\pi$ associe son séquent $\Gamma\vdash \varphi$
  conclusion. Pour une théorie $\mathcal T$ r.a., le langage des séquents
  conclusion $\Gamma\vdash \varphi$ tels que
  $\Gamma\subseteq \mathcal T$ est aussi RPG.
\end{proposition}

\begin{notation}
  On définit $\Proof{\mathcal T}$ pour l'ensemble calculable des arbres de
  preuve
  de conclusion $\Gamma \vdash \varphi$ où $\Gamma\subseteq \mathcal T$. On
  définit aussi la relation $\pi\vdash \varphi$ comme le fait que $\varphi$ est
  la conclusion de $\pi$. Cette relation est bien sûr calculable.
\end{notation}

Avec cette proposition, on peut donc définir les arbres $\pi$ témoignant du
fait que $\mathcal T \vdash \varphi$, puisque cela correspond exactement à
un arbre de preuve bien formé donc la conclusion est $\Gamma\vdash \varphi$ où
$\Gamma$ n'est constitué que de formules de $\mathcal T$. On en déduit le
lemme central permettant les théorèmes d'incomplétude.

\begin{lemma}
  L'ensemble
  \[\Th(\mathcal T) \defeq \{\godcod \varphi\mid
  \varphi \in \Prop,\mathcal T \vdash \varphi\}\]
  est c.e.
\end{lemma}

Par représentation des énoncés $\HierArithS 1$ (qui sont exactement les
ensembles c.e.) on peut donc construire un prédicat permettant de définir la
prouvabilité.

\begin{definition}
  Soit $\mathcal T$ une théorie arithmétique r.a. Par le lemme précédent, on
  pose un énoncé $\HierArithS 1$, noté $\DemT{\mathcal T}$, tel que
  \[\forall n,m \in \bN^2, (\bN,(n,m) \models \DemT{\mathcal T}) \iff
  \exists \pi \in \Proof{\mathcal T}, \exists \varphi \in \Formula,
  n = \godcod \pi \land m = \godcod \varphi \land \pi \vdash \varphi\]

  On définit aussi
  \[\ThT{\mathcal T}(x) \defeq \exists y, \DemT{\mathcal T}(y,x)\]
  qui vérifie
  \[\bN,n\models \ThT{\mathcal T}(x) \iff \exists \varphi \in \Formula,
  \mathcal T \vdash \varphi\]
\end{definition}

Avec ce lemme, on sait donc que la prouvabilité d'un énoncé peut s'énoncer au
sein même de la syntaxe de l'arithmétique. Si on considère maintenant une
théorie $\mathcal T$ qui est $\Sigma$-complète, on sait (puisque les énoncés
$\HierArithS 1$ vrais sont prouvables) que si
$\mathcal T \vdash \varphi$, alors
$\mathcal T \vdash \ThT{\mathcal T}(\encode{\godcod \varphi})$. Par
contre, la réciproque n'a pas de raison d'être vraie, puisque l'énoncé n'est
vérifié que pour les entiers standards, et on peut imaginer l'existence
d'entiers non standard témoignant par exemple de
$\ThT{\mathcal T}(\encode{\godcod\varphi})$.

Il manque un élément pour pouvoir arriver aux théorèmes d'incomplétude~: un
théorème de point fixe. Le premier théorème d'incomplétude consiste globalement
à écrire un énoncé de la forme
\quotation{cet énoncé est faux}
d'après Gödel lui-même \cite{Godel1931-GDEBFU}.

Pour écrire un tel énoncé, il faut avant tout être capable d'écrire un énoncé
pouvant parler de lui-même. Cet aspect récursif fait penser à la définition de
la factorielle développée avec le \cref{thm.Kleene.fix}.

Puisque les formules peuvent parler d'elles-mêmes par un codage de Gödel, et
que les opérations syntaxiques peuvent aussi être traduites, il devient
possible de prouver un théorème de récursion analogue.

\begin{lemma}[Point fixe \cite{Godel1931-GDEBFU}]\label{lem.fix.godel}
  Soit $\mathcal T$ une théorie $\Sigma$-complète. Alors pour toute formule
  $\alpha(x)\in\Formula $ à (au plus) une seule variable libre, il existe une
  proposition $\varphi \in \Prop$ telle que
  \[\mathcal T \vdash \varphi \iff \alpha(\encode{\godcod \varphi})\]
\end{lemma}

\begin{proof}
  D'après la \cref{prop.subst.repr} et le \cref{thm.repr.Sigma1}, on peut
  trouver un prédicat $\Subst(n,m,p,k)$ exprimant sur $\bN^4$ la relation
  \[\Subst(n,m,p,k) \iff \exists \varphi \in \Formula, \exists t \in \Term,
  \begin{cases}
    n = \godcod \varphi \\
    m = \godcod t \\
    k = \godcod {\varphi[t/x_p]}
  \end{cases}\]

  On pose alors les deux formules
  \begin{align*}
    \delta(x_0) &\defeq \exists y,
    (\Subst(x_0,x_0,0,y) \land \alpha(y)) \\
    \varphi &\defeq \delta[\encode{\godcod \delta}/x_0]
  \end{align*}
  On remarque d'abord que $\varphi$ est bien une formule close. On peut
  maintenant vérifier l'équivalence~:
  \begin{align*}
    \mathcal T \vdash& \Subst(\encode{\godcod\delta},\encode{\godcod\delta},
    0,y) \iff y = \encode{\godcod{\delta[\encode{\godcod\delta}/x_0]}} &
    \text{par représentation de }\Subst \\
    \mathcal T \vdash& \Subst(\encode{\godcod\delta},\encode{\godcod\delta},
    0,y) \iff y = \encode{\godcod{\varphi}} &
    \text{par définition de }\varphi \\
    \mathcal T \vdash& \exists y,
    (\Subst(\encode{\godcod\delta},\encode{\godcod\delta}, 0,y) \land \alpha(y))
    \iff \\
    &\exists y, (y = \encode{\godcod{\varphi}} \land \alpha(y))
    & \text{par propriété de l'équivalence}\\
    \mathcal T \vdash& \varphi \iff \alpha(\encode{\godcod \varphi}) &
    \text{en réduisant l'égalité}
  \end{align*}
  D'où le résultat.
\end{proof}

\begin{remark}
  La forme de $\delta$ fait fortement penser à la fonction utilisée pour le
  \cref{thm.Kleene.fix}~: $\Subst$ joue le rôle de l'application de fonction,
  puisqu'en voyant une formule $\varphi(x)$ comme une fonction de $x$, la
  substitution consiste en une application explicite. Une différence notable est
  qu'ici, c'est la substitution qui apparait explicitement, le fait que toute
  formule puisse être traité comme une fonction étant déjà acquis. Au contraire,
  avec l'énumération $\Enum$, on a utilisé le lemme $s_n^m$ pour transformer en
  objet explicite une fonction en $x$, mais l'application était automatique.
\end{remark}

Nous pouvons désormais prouver les théorèmes centraux sur la logique de
l'arithmétique.

\section{Théorèmes d'incomplétude}

On peut désormais combiner les conséquences à la fois de la $\Sigma$-complétude,
et d'être une théorie r.a. Ces conséquences vont nous donner directement le
premier théorème d'incomplétude.

\subsection{Vers le premier théorème d'incomplétude}

En étudiant le procédé diagonal et la façon dont il construit un point fixe, on
en déduit qu'il suffit ici de faire la même chose que pour d'autres arguments
par contradiction~: on prend pour $\alpha$ la négation, ce qui mènerait donc à
quelque chose comme
\[\mathcal T \vdash \varphi \iff \lnot \varphi\]
qui exprimerait l'incohérence de $\mathcal T$. Il y a donc un problème dans
cette définition intuitive (car $\mathcal T$ est simplement une théorie r.a. et
$\Sigma$-complète).

En réalité, notre théorème de point fixe nous dit seulement qu'on peut
construire des points fixes pour des formules de l'arithmétique. Pour pouvoir
faire la démonstration précédente, il nous faudrait donc pouvoir éxprimer par
une formule un énoncé $V$ tel que $V(\encode{\godcod\varphi}) \iff \varphi$.

En allant dans l'autre sens, cela montre qu'on ne peut pas construire de
tel énoncé.

\begin{theorem}[Indéfinissabilité de la vérité]\label{thm.ver.indef}
  Soit $\mathcal T$ une théorie $\Sigma$-complète. S'il existe un prédicat
  arithmétique $V(x)$ tel que
  \[\forall \varphi \in \Prop, \mathcal T \vdash
  V(\encode{\godcod\varphi}) \iff \varphi\]
  alors $\mathcal T$ est incohérente.
\end{theorem}

\begin{proof}
  Si un tel prédicat existe, alors on peut construire par le
  \cref{lem.fix.godel} une formule $\varphi$ telle que
  \[\mathcal T \vdash \varphi \iff \lnot V(\encode{\godcod{\varphi}})\]
  mais alors, puisque
  \[\mathcal T \vdash V(\encode{\godcod\varphi}) \iff \varphi\]
  on en déduit que $\mathcal T \vdash \varphi \iff \lnot \varphi$, donc que
  $\mathcal T \vdash \bot$, c'est-à-dire que $\mathcal T$ est incohérente.
\end{proof}

\begin{exercise}
  En utilisant le \cref{thm.ver.indef}, montrer qu'il n'existe aucun prédicat
  $V(x)$ tel que
  \[\forall \varphi \in \Prop, \bN \models \varphi \iff \bN \models
  V(\encode{\godcod{\varphi}})\]
  Plus généralement, montrer que cela fonctionne pour n'importe quelle théorie
  $\mathcal T$ qui est $\Sigma$-complète et n'importe quel modèle $\mathcal M$
  de $\mathcal T$~: il n'existe pas de formule $V(x)$ à une variable libre telle
  que
  \[\forall \varphi \in \Prop, \mathcal M \models \varphi \iff
  \mathcal M \models V(\encode{\godcod \varphi})\]
\end{exercise}

Le théorème de point fixe ne peut donc pas s'appliquer au cas de la satisfaction
sémantique. Cependant, on a déjà vu un énoncé très proche, mais qui aborde la
satisfaction sémantique à la place~: $\ThT{\mathcal T}$.

\begin{definition}[Formule $G$ de Gödel]
  Soit $\mathcal T$ une théorie $\Sigma$-complète et r.a. On définit $G$ comme
  la proposition obtenue par le \cref{lem.fix.godel} telle que
  \[\mathcal T \vdash G \iff \lnot \ThT{\mathcal T}(\encode{\godcod{G}})\]
\end{definition}

Cette formule énonce donc qu'elle est elle-même indémontrable. On remarque un
fait important~: l'utilisation de la négation n'est pas anodin du point de vue
de la calculabilité. En effet, dans les constructions de $\DemT{\mathcal T}$,
de $\Subst$, par conséquent, de la construction du \cref{lem.fix.godel},
nous employons uniquement des énoncés $\HierArithS 1$. Dans le cas de $G$,
au contraire, on obtient un énoncé $\HierArithP 1$ puisqu'on nie un énoncé
$\HierArithS 1$. On peut comprendre la portée universelle de l'énoncé comme le
fait que, pour n'importe quel code d'arbre de preuve $\godcod \pi$, ce code ne
représente pas une preuve de $G$. On peut donc énoncer une première version du
premier théorème d'incomplétude.

\begin{theorem}[Premier théorème d'incomplétude - version faible]
  Soit $\mathcal T$ une théorie cohérente, $\Sigma$-complète et r.a. Alors il
  existe un énoncé $G \in \HierArithP 1$ tel que $G$ est vrai dans $\bN$ et non
  démontrable dans $\mathcal T$.
\end{theorem}

\begin{proof}
  L'énoncé $G$ a déjà été donné. Il nous suffit de montrer que $G$ est non
  prouvable pour en déduire que $\bN \models G$, puisque par définition
  \[\bN \models \ThT{\mathcal T}(\encode{\godcod G}) \iff
  \mathcal T \vdash G\]
  On suppose donc que $G$ est démontrable~: on trouve donc un arbre de preuve
  $\pi \vdash G$ dont les prémisses sont dans $\mathcal T$. Comme on sait par
  définition que $G$ est démontrable si et seulement
  $\lnot\ThT{\mathcal T}(\encode{\godcod G})$ l'est, on en déduit
  \[\mathcal T \vdash \lnot\ThT{\mathcal T}(\encode{\godcod G})\]
  mais de plus, puisque $\DemT{\mathcal T}$ est un prédicat $\HierArithS 1$ et
  que $\mathcal T$ est $\Sigma$-complète, par le fait que
  $\bN\models \DemT{\mathcal T}(\encode{\godcod{\pi}},\encode{\godcod G})$,
  on en déduit que
  \[\mathcal T \vdash \DemT{\mathcal T}
  (\encode{\godcod{\pi}},\encode{\godcod G})\]
  donc $\mathcal T \vdash \ThT{\mathcal T}(\encode{\godcod G})$, ce qui est
  contradictoire avec la cohérence de $\mathcal T$.
\end{proof}

Cet énoncé suffit par exemple à montrer que tout énoncé arithmétique vrai dans
$\bN$ n'est pas forcément prouvable dans n'importe quelle théorie utilisable et
suffisamment expressive. Cependant, cela ne constitue pas un énoncé
d'incomplétude~: une théorie pourrait être complète en vérifiant
$\mathcal T \vdash \lnot G$.

On va donc ajouter une condition, qui est un renforcement de la condition de
cohérence. La cohérence nous indique qu'il existe des énoncés non démontrables,
mais elle ne place aucune condition sur les énoncés non démontrables en
question. On introduit alors la $\Sigma$-cohérence (ou $1$-cohérence, selon les
auteurs).

\begin{definition}[Théorie $\Sigma$-cohérente]
  Une théorie $\mathcal T$ est dite $\Sigma$-cohérente s'il n'existe aucune
  proposition $\varphi \in \HierArithS 1$ telle que
  \[(\mathcal T \vdash \varphi) \land (\bN \models \lnot\varphi)\]
\end{definition}

L'énoncé devient alors véritablement un énoncé d'incomplétude.

\begin{theorem}[Premier théorème d'incomplétude de Gödel
    \cite{Godel1931-GDEBFU}]
  Soit $\mathcal T$ une théorie arithmétique à la fois $\Sigma$-complète,
  $\Sigma$-cohérente et r.a. Il existe un énoncé $G \in \HierArithP 1$ tel que
  $\mathcal T \nvdash G$ et $\mathcal T \nvdash \lnot G$.
\end{theorem}

\begin{proof}
  On reprend donc le raisonnement précédent. On sait que $G$ est non
  démontrable dans $\mathcal T$ et qu'elle est vraie dans $\bN$. Comme $G$ est
  une proposition $\HierArithP 1$, $\lnot G$ est (équivalente à une proposition)
  $\HierArithS 1$ et $\bN \models \lnot\lnot G$ (puisque $\bN\models G$).
  Par $\Sigma$-cohérence, on en déduit que $G$ n'est pas démontrable dans
  $\mathcal T$.
\end{proof}

Ce théorème est largement suffisant pour la pratique. Les théories utiles pour
formaliser les mathématiques, qui sont les théories pour lesquelles on souhaite
appliquer ce théorème, sont généralement au moins $\Sigma$-complètes pour
permettre d'exprimer les fonctions utiles pour un mathématicien, sont
récursivement axiomatisable pour être utilisables, et sont $\Sigma$-cohérentes
puisqu'on souhaite d'abord refléter la vérité dans $\bN$ (inatteignable par une
théorie logique d'après le \cref{thm.ver.indef}).

\begin{exercise}[Le cas historique de l'$\omega$-cohérence]
  Dans \cite{Godel1931-GDEBFU}, Gödel n'utilise pas l'hypothse de
  $\Sigma$-cohérence. A la place, il utilise l'hypothèse dite
  d'$\omega$-cohérence. Une théorie $\mathcal T$ est dite $\omega$-cohérente
  quand pour tout énoncé $\varphi(x)$, on ne peut avoir à la fois les deux
  faits suivants~:
  \[\forall n \in \bN, \mathcal T \vdash \varphi(\encode n) \qquad
  \mathcal T \vdash \exists x, \lnot \varphi(x)\]
  Montrer que toute théorie $\omega$-cohérente est $\Sigma$-cohérente. En
  déduire la version historique du premier théorème d'incomplétude de Gödel.
\end{exercise}
